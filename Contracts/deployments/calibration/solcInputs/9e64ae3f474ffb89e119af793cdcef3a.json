{
  "language": "Solidity",
  "sources": {
    "@ensdomains/buffer/contracts/Buffer.sol": {
      "content": "// SPDX-License-Identifier: BSD-2-Clause\npragma solidity ^0.8.4;\n\n/**\n* @dev A library for working with mutable byte buffers in Solidity.\n*\n* Byte buffers are mutable and expandable, and provide a variety of primitives\n* for appending to them. At any time you can fetch a bytes object containing the\n* current contents of the buffer. The bytes object should not be stored between\n* operations, as it may change due to resizing of the buffer.\n*/\nlibrary Buffer {\n    /**\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\n    *      a capacity. The capacity may be longer than the current value, in\n    *      which case it can be extended without the need to allocate more memory.\n    */\n    struct buffer {\n        bytes buf;\n        uint capacity;\n    }\n\n    /**\n    * @dev Initializes a buffer with an initial capacity.\n    * @param buf The buffer to initialize.\n    * @param capacity The number of bytes of space to allocate the buffer.\n    * @return The buffer, for chaining.\n    */\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\n        if (capacity % 32 != 0) {\n            capacity += 32 - (capacity % 32);\n        }\n        // Allocate space for the buffer data\n        buf.capacity = capacity;\n        assembly {\n            let ptr := mload(0x40)\n            mstore(buf, ptr)\n            mstore(ptr, 0)\n            let fpm := add(32, add(ptr, capacity))\n            if lt(fpm, ptr) {\n                revert(0, 0)\n            }\n            mstore(0x40, fpm)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Initializes a new buffer from an existing bytes object.\n    *      Changes to the buffer may mutate the original value.\n    * @param b The bytes object to initialize the buffer with.\n    * @return A new buffer.\n    */\n    function fromBytes(bytes memory b) internal pure returns(buffer memory) {\n        buffer memory buf;\n        buf.buf = b;\n        buf.capacity = b.length;\n        return buf;\n    }\n\n    function resize(buffer memory buf, uint capacity) private pure {\n        bytes memory oldbuf = buf.buf;\n        init(buf, capacity);\n        append(buf, oldbuf);\n    }\n\n    /**\n    * @dev Sets buffer length to 0.\n    * @param buf The buffer to truncate.\n    * @return The original buffer, for chaining..\n    */\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\n        assembly {\n            let bufptr := mload(buf)\n            mstore(bufptr, 0)\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to copy.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data, uint len) internal pure returns(buffer memory) {\n        require(len <= data.length);\n\n        uint off = buf.buf.length;\n        uint newCapacity = off + len;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint dest;\n        uint src;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Length of existing buffer data\n            let buflen := mload(bufptr)\n            // Start address = buffer address + offset + sizeof(buffer length)\n            dest := add(add(bufptr, 32), off)\n            // Update buffer length if we're extending it\n            if gt(newCapacity, buflen) {\n                mstore(bufptr, newCapacity)\n            }\n            src := add(data, 32)\n        }\n\n        // Copy word-length chunks while possible\n        for (; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        // Copy remaining bytes\n        unchecked {\n            uint mask = (256 ** (32 - len)) - 1;\n            assembly {\n                let srcpart := and(mload(src), not(mask))\n                let destpart := and(mload(dest), mask)\n                mstore(dest, or(destpart, srcpart))\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\n        return append(buf, data, data.length);\n    }\n\n    /**\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\n    *      capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint offPlusOne = off + 1;\n        if (off >= buf.capacity) {\n            resize(buf, offPlusOne * 2);\n        }\n\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + off\n            let dest := add(add(bufptr, off), 32)\n            mstore8(dest, data)\n            // Update buffer length if we extended it\n            if gt(offPlusOne, mload(bufptr)) {\n                mstore(bufptr, offPlusOne)\n            }\n        }\n\n        return buf;\n    }\n\n    /**\n    * @dev Appends len bytes of bytes32 to a buffer. Resizes if doing so would\n    *      exceed the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @param len The number of bytes to write (left-aligned).\n    * @return The original buffer, for chaining.\n    */\n    function append(buffer memory buf, bytes32 data, uint len) private pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        unchecked {\n            uint mask = (256 ** len) - 1;\n            // Right-align data\n            data = data >> (8 * (32 - len));\n            assembly {\n                // Memory address of the buffer data\n                let bufptr := mload(buf)\n                // Address = buffer address + sizeof(buffer length) + newCapacity\n                let dest := add(bufptr, newCapacity)\n                mstore(dest, or(and(mload(dest), not(mask)), data))\n                // Update buffer length if we extended it\n                if gt(newCapacity, mload(bufptr)) {\n                    mstore(bufptr, newCapacity)\n                }\n            }\n        }\n        return buf;\n    }\n\n    /**\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chhaining.\n    */\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\n        return append(buf, bytes32(data), 20);\n    }\n\n    /**\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\n    *      the capacity of the buffer.\n    * @param buf The buffer to append to.\n    * @param data The data to append.\n    * @return The original buffer, for chaining.\n    */\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\n        return append(buf, data, 32);\n    }\n\n    /**\n     * @dev Appends a byte to the end of the buffer. Resizes if doing so would\n     *      exceed the capacity of the buffer.\n     * @param buf The buffer to append to.\n     * @param data The data to append.\n     * @param len The number of bytes to write (right-aligned).\n     * @return The original buffer.\n     */\n    function appendInt(buffer memory buf, uint data, uint len) internal pure returns(buffer memory) {\n        uint off = buf.buf.length;\n        uint newCapacity = len + off;\n        if (newCapacity > buf.capacity) {\n            resize(buf, newCapacity * 2);\n        }\n\n        uint mask = (256 ** len) - 1;\n        assembly {\n            // Memory address of the buffer data\n            let bufptr := mload(buf)\n            // Address = buffer address + sizeof(buffer length) + newCapacity\n            let dest := add(bufptr, newCapacity)\n            mstore(dest, or(and(mload(dest), not(mask)), data))\n            // Update buffer length if we extended it\n            if gt(newCapacity, mload(bufptr)) {\n                mstore(bufptr, newCapacity)\n            }\n        }\n        return buf;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ContextUpgradeable} from \"../utils/ContextUpgradeable.sol\";\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    /// @custom:storage-location erc7201:openzeppelin.storage.Ownable\n    struct OwnableStorage {\n        address _owner;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Ownable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant OwnableStorageLocation = 0x9016d09d72d40fdae2fd8ceac6b6234c7706214fd39c1cd1e609a0528c199300;\n\n    function _getOwnableStorage() private pure returns (OwnableStorage storage $) {\n        assembly {\n            $.slot := OwnableStorageLocation\n        }\n    }\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    function __Ownable_init(address initialOwner) internal onlyInitializing {\n        __Ownable_init_unchained(initialOwner);\n    }\n\n    function __Ownable_init_unchained(address initialOwner) internal onlyInitializing {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        OwnableStorage storage $ = _getOwnableStorage();\n        return $._owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        OwnableStorage storage $ = _getOwnableStorage();\n        address oldOwner = $._owner;\n        $._owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reinitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Pointer to storage slot. Allows integrators to override it with a custom storage location.\n     *\n     * NOTE: Consider following the ERC-7201 formula to derive storage locations.\n     */\n    function _initializableStorageSlot() internal pure virtual returns (bytes32) {\n        return INITIALIZABLE_STORAGE;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        bytes32 slot = _initializableStorageSlot();\n        assembly {\n            $.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    /// @custom:storage-location erc7201:openzeppelin.storage.ReentrancyGuard\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ReentrancyGuard\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ReentrancyGuardStorageLocation = 0x9b779b17422d0df92223018b32b4d1fa46e071723d6817e2486d003becc55f00;\n\n    function _getReentrancyGuardStorage() private pure returns (ReentrancyGuardStorage storage $) {\n        assembly {\n            $.slot := ReentrancyGuardStorageLocation\n        }\n    }\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if ($._status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        $._status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        $._status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        ReentrancyGuardStorage storage $ = _getReentrancyGuardStorage();\n        return $._status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC-20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC-721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in ERC-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC-1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC-1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1363.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (interfaces/IERC1363.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @title IERC1363\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\n *\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\n */\ninterface IERC1363 is IERC20, IERC165 {\n    /*\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\n     * 0xb0202a11 ===\n     *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\n     *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\n     *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\n     */\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\n     * @param from The address which you want to send tokens from.\n     * @param to The address which you want to transfer to.\n     * @param value The amount of tokens to be transferred.\n     * @param data Additional data with no specified format, sent in call to `to`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     * @param data Additional data with no specified format, sent in call to `spender`.\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\n     */\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC-20\n * applications.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * Both values are immutable: they can only be set once during construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Skips emitting an {Approval} event indicating an allowance update. This is not\n     * required by the ERC. See {xref-ERC20-_approve-address-address-uint256-bool-}[_approve].\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner`'s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     *\n     * ```solidity\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner`'s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance < type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC1363} from \"../../../interfaces/IERC1363.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    /**\n     * @dev An operation with an ERC-20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\n     */\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\n        return _callOptionalReturnBool(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     *\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \"client\"\n     * smart contract uses ERC-7674 to set temporary allowances, then the \"client\" smart contract should avoid using\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     *\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\n     * only sets the \"standard\" allowance. Any temporary allowance will remain active, in addition to the value being\n     * set here.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            safeTransfer(token, to, value);\n        } else if (!token.transferAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function transferFromAndCallRelaxed(\n        IERC1363 token,\n        address from,\n        address to,\n        uint256 value,\n        bytes memory data\n    ) internal {\n        if (to.code.length == 0) {\n            safeTransferFrom(token, from, to, value);\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\n     * targeting contracts.\n     *\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\n     * Opposedly, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\n     * once without retrying, and relies on the returned value to be true.\n     *\n     * Reverts if the returned value is other than `true`.\n     */\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\n        if (to.code.length == 0) {\n            forceApprove(token, to, value);\n        } else if (!token.approveAndCall(to, value, data)) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturnBool} that reverts if call fails to meet the requirements.\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            let success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            // bubble errors\n            if iszero(success) {\n                let ptr := mload(0x40)\n                returndatacopy(ptr, 0, returndatasize())\n                revert(ptr, returndatasize())\n            }\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        if (returnSize == 0 ? address(token).code.length == 0 : returnValue != 1) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.2.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Arrays.sol)\n// This file was procedurally generated from scripts/generate/templates/Arrays.js.\n\npragma solidity ^0.8.20;\n\nimport {Comparators} from \"./Comparators.sol\";\nimport {SlotDerivation} from \"./SlotDerivation.sol\";\nimport {StorageSlot} from \"./StorageSlot.sol\";\nimport {Math} from \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    using SlotDerivation for bytes32;\n    using StorageSlot for bytes32;\n\n    /**\n     * @dev Sort an array of uint256 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        uint256[] memory array,\n        function(uint256, uint256) pure returns (bool) comp\n    ) internal pure returns (uint256[] memory) {\n        _quickSort(_begin(array), _end(array), comp);\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of uint256 in increasing order.\n     */\n    function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\n        sort(array, Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of address (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        address[] memory array,\n        function(address, address) pure returns (bool) comp\n    ) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of address in increasing order.\n     */\n    function sort(address[] memory array) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Sort an array of bytes32 (in memory) following the provided comparator function.\n     *\n     * This function does the sorting \"in place\", meaning that it overrides the input. The object is returned for\n     * convenience, but that returned value can be discarded safely if the caller has a memory pointer to the array.\n     *\n     * NOTE: this function's cost is `O(n · log(n))` in average and `O(n²)` in the worst case, with n the length of the\n     * array. Using it in view functions that are executed through `eth_call` is safe, but one should be very careful\n     * when executing this as part of a transaction. If the array being sorted is too large, the sort operation may\n     * consume more gas than is available in a block, leading to potential DoS.\n     *\n     * IMPORTANT: Consider memory side-effects when using custom comparator functions that access memory in an unsafe way.\n     */\n    function sort(\n        bytes32[] memory array,\n        function(bytes32, bytes32) pure returns (bool) comp\n    ) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }\n\n    /**\n     * @dev Variant of {sort} that sorts an array of bytes32 in increasing order.\n     */\n    function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }\n\n    /**\n     * @dev Performs a quick sort of a segment of memory. The segment sorted starts at `begin` (inclusive), and stops\n     * at end (exclusive). Sorting follows the `comp` comparator.\n     *\n     * Invariant: `begin <= end`. This is the case when initially called by {sort} and is preserved in subcalls.\n     *\n     * IMPORTANT: Memory locations between `begin` and `end` are not validated/zeroed. This function should\n     * be used only if the limits are within a memory array.\n     */\n    function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\n        unchecked {\n            if (end - begin < 0x40) return;\n\n            // Use first element as pivot\n            uint256 pivot = _mload(begin);\n            // Position where the pivot should be at the end of the loop\n            uint256 pos = begin;\n\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\n                if (comp(_mload(it), pivot)) {\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\n                    // position of the pivot and move the value there.\n                    pos += 0x20;\n                    _swap(pos, it);\n                }\n            }\n\n            _swap(begin, pos); // Swap pivot into place\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first element of `array`.\n     */\n    function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\n        assembly (\"memory-safe\") {\n            ptr := add(array, 0x20)\n        }\n    }\n\n    /**\n     * @dev Pointer to the memory location of the first memory word (32bytes) after `array`. This is the memory word\n     * that comes just after the last element of the array.\n     */\n    function _end(uint256[] memory array) private pure returns (uint256 ptr) {\n        unchecked {\n            return _begin(array) + array.length * 0x20;\n        }\n    }\n\n    /**\n     * @dev Load memory word (as a uint256) at location `ptr`.\n     */\n    function _mload(uint256 ptr) private pure returns (uint256 value) {\n        assembly {\n            value := mload(ptr)\n        }\n    }\n\n    /**\n     * @dev Swaps the elements memory location `ptr1` and `ptr2`.\n     */\n    function _swap(uint256 ptr1, uint256 ptr2) private pure {\n        assembly {\n            let value1 := mload(ptr1)\n            let value2 := mload(ptr2)\n            mstore(ptr1, value2)\n            mstore(ptr2, value1)\n        }\n    }\n\n    /// @dev Helper: low level cast address memory array to uint256 memory array\n    function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 memory array to uint256 memory array\n    function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast address comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(address, address) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /// @dev Helper: low level cast bytes32 comp function to uint256 comp function\n    function _castToUint256Comp(\n        function(bytes32, bytes32) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }\n\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * NOTE: The `array` is expected to be sorted in ascending order, and to\n     * contain no repeated elements.\n     *\n     * IMPORTANT: Deprecated. This implementation behaves as {lowerBound} but lacks\n     * support for repeated elements in the array. The {lowerBound} function should\n     * be used instead.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value greater or equal than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/lower_bound[lower_bound].\n     */\n    function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Searches an `array` sorted in ascending order and returns the first\n     * index that contains a value strictly greater than `element`. If no such index\n     * exists (i.e. all values in the array are strictly less than `element`), the array\n     * length is returned. Time complexity O(log n).\n     *\n     * See C++'s https://en.cppreference.com/w/cpp/algorithm/upper_bound[upper_bound].\n     */\n    function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {lowerBound}, but with an array in memory.\n     */\n    function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Same as {upperBound}, but with an array in memory.\n     */\n    function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getAddressSlot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytes32Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getUint256Slot();\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.\n     *\n     * WARNING: Only use if you are certain `pos` is lower than the array length.\n     */\n    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(address[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n\n    /**\n     * @dev Helper to set the length of a dynamic array. Directly writing to `.length` is forbidden.\n     *\n     * WARNING: this does not clear elements if length is reduced, of initialize elements if length is increased.\n     */\n    function unsafeSetLength(uint256[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Comparators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Comparators.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to compare values.\n *\n * _Available since v5.1._\n */\nlibrary Comparators {\n    function lt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a < b;\n    }\n\n    function gt(uint256 a, uint256 b) internal pure returns (bool) {\n        return a > b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes memory signature\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly (\"memory-safe\") {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[ERC-2098 short signatures]\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        unchecked {\n            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) >> 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address recovered, RecoverError err, bytes32 errArg) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/Hashes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/cryptography/Hashes.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library of standard hash functions.\n *\n * _Available since v5.1._\n */\nlibrary Hashes {\n    /**\n     * @dev Commutative Keccak256 hash of a sorted pair of bytes32. Frequently used when working with merkle proofs.\n     *\n     * NOTE: Equivalent to the `standardNodeHash` in our https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n     */\n    function commutativeKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32) {\n        return a < b ? efficientKeccak256(a, b) : efficientKeccak256(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function efficientKeccak256(bytes32 a, bytes32 b) internal pure returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/cryptography/MerkleProof.sol)\n// This file was procedurally generated from scripts/generate/templates/MerkleProof.js.\n\npragma solidity ^0.8.20;\n\nimport {Hashes} from \"./Hashes.sol\";\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n *\n * IMPORTANT: Consider memory side-effects when using custom hashing functions\n * that access memory in an unsafe way.\n *\n * NOTE: This library supports proof verification for merkle trees built using\n * custom _commutative_ hashing functions (i.e. `H(a, b) == H(b, a)`). Proving\n * leaf inclusion in trees built using non-commutative hashing functions requires\n * additional logic that is not supported by this library.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with the default hashing function.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with the default hashing function.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with a custom hashing function.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processProof(proof, leaf, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in memory with a custom hashing function.\n     */\n    function processProof(\n        bytes32[] memory proof,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = hasher(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with the default hashing function.\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with the default hashing function.\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = Hashes.commutativeKeccak256(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with a custom hashing function.\n     */\n    function verifyCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processProofCalldata(proof, leaf, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leaves & pre-images are assumed to be sorted.\n     *\n     * This version handles proofs in calldata with a custom hashing function.\n     */\n    function processProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 leaf,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = hasher(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in memory with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProof}.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in memory with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in memory with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProof}.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in memory with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = hasher(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in calldata with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in calldata with the default hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = Hashes.commutativeKeccak256(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * This version handles multiproofs in calldata with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     *\n     * NOTE: Consider the case where `root == proof[0] && leaves.length == 0` as it will return `true`.\n     * The `leaves` must be validated independently. See {processMultiProofCalldata}.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves, hasher) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * This version handles multiproofs in calldata with a custom hashing function.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     *\n     * NOTE: The _empty set_ (i.e. the case where `proof.length == 1 && leaves.length == 0`) is considered a no-op,\n     * and therefore a valid multiproof (i.e. it returns `proof[0]`). Consider disallowing this case if you're not\n     * validating the leaves elsewhere.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves,\n        function(bytes32, bytes32) view returns (bytes32) hasher\n    ) internal view returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofFlagsLen = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proof.length != proofFlagsLen + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](proofFlagsLen);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < proofFlagsLen; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = hasher(a, b);\n        }\n\n        if (proofFlagsLen > 0) {\n            if (proofPos != proof.length) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[proofFlagsLen - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\nimport {Panic} from \"../Panic.sol\";\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Return the 512-bit addition of two uint256.\n     *\n     * The result is stored in two 256 variables such that sum = high * 2²⁵⁶ + low.\n     */\n    function add512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        assembly (\"memory-safe\") {\n            low := add(a, b)\n            high := lt(low, a)\n        }\n    }\n\n    /**\n     * @dev Return the 512-bit multiplication of two uint256.\n     *\n     * The result is stored in two 256 variables such that product = high * 2²⁵⁶ + low.\n     */\n    function mul512(uint256 a, uint256 b) internal pure returns (uint256 high, uint256 low) {\n        // 512-bit multiply [high low] = x * y. Compute the product mod 2²⁵⁶ and mod 2²⁵⁶ - 1, then use\n        // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = high * 2²⁵⁶ + low.\n        assembly (\"memory-safe\") {\n            let mm := mulmod(a, b, not(0))\n            low := mul(a, b)\n            high := sub(sub(mm, low), lt(mm, low))\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            success = c >= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with a success flag (no overflow).\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a - b;\n            success = c <= a;\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with a success flag (no overflow).\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a * b;\n            assembly (\"memory-safe\") {\n                // Only true when the multiplication doesn't overflow\n                // (c / a == b) || (a == 0)\n                success := or(eq(div(c, a), b), iszero(a))\n            }\n            // equivalent to: success ? c : 0\n            result = c * SafeCast.toUint(success);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `DIV` opcode returns zero when the denominator is 0.\n                result := div(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a success flag (no division by zero).\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            success = b > 0;\n            assembly (\"memory-safe\") {\n                // The `MOD` opcode returns zero when the denominator is 0.\n                result := mod(a, b)\n            }\n        }\n    }\n\n    /**\n     * @dev Unsigned saturating addition, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingAdd(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryAdd(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Unsigned saturating subtraction, bounds to zero instead of overflowing.\n     */\n    function saturatingSub(uint256 a, uint256 b) internal pure returns (uint256) {\n        (, uint256 result) = trySub(a, b);\n        return result;\n    }\n\n    /**\n     * @dev Unsigned saturating multiplication, bounds to `2²⁵⁶ - 1` instead of overflowing.\n     */\n    function saturatingMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        (bool success, uint256 result) = tryMul(a, b);\n        return ternary(success, result, type(uint256).max);\n    }\n\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }\n\n    /**\n     * @dev Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     *\n     * Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (high == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return low / denominator;\n            }\n\n            // Make sure the result is less than 2²⁵⁶. Also prevents denominator == 0.\n            if (denominator <= high) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [high low].\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                high := sub(high, gt(remainder, low))\n                low := sub(low, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly (\"memory-safe\") {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [high low] by twos.\n                low := div(low, twos)\n\n                // Flip twos such that it is 2²⁵⁶ / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from high into low.\n            low |= high * twos;\n\n            // Invert denominator mod 2²⁵⁶. Now that denominator is an odd number, it has an inverse modulo 2²⁵⁶ such\n            // that denominator * inv ≡ 1 mod 2²⁵⁶. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv ≡ 1 mod 2⁴.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹⁶\n            inverse *= 2 - denominator * inverse; // inverse mod 2³²\n            inverse *= 2 - denominator * inverse; // inverse mod 2⁶⁴\n            inverse *= 2 - denominator * inverse; // inverse mod 2¹²⁸\n            inverse *= 2 - denominator * inverse; // inverse mod 2²⁵⁶\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2²⁵⁶. Since the preconditions guarantee that the outcome is\n            // less than 2²⁵⁶, this is the final result. We don't need to compute the high bits of the result and high\n            // is no longer required.\n            result = low * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @dev Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        return mulDiv(x, y, denominator) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0);\n    }\n\n    /**\n     * @dev Calculates floor(x * y >> n) with full precision. Throws if result overflows a uint256.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 result) {\n        unchecked {\n            (uint256 high, uint256 low) = mul512(x, y);\n            if (high >= 1 << n) {\n                Panic.panic(Panic.UNDER_OVERFLOW);\n            }\n            return (high << (256 - n)) | (low >> n);\n        }\n    }\n\n    /**\n     * @dev Calculates x * y >> n with full precision, following the selected rounding direction.\n     */\n    function mulShr(uint256 x, uint256 y, uint8 n, Rounding rounding) internal pure returns (uint256) {\n        return mulShr(x, y, n) + SafeCast.toUint(unsignedRoundsUp(rounding) && mulmod(x, y, 1 << n) > 0);\n    }\n\n    /**\n     * @dev Calculate the modular multiplicative inverse of a number in Z/nZ.\n     *\n     * If n is a prime, then Z/nZ is a field. In that case all elements are inversible, except 0.\n     * If n is not a prime, then Z/nZ is not a field, and some elements might not be inversible.\n     *\n     * If the input value is not inversible, 0 is returned.\n     *\n     * NOTE: If you know for sure that n is (big) a prime, it may be cheaper to use Fermat's little theorem and get the\n     * inverse using `Math.modExp(a, n - 2, n)`. See {invModPrime}.\n     */\n    function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax ≡ 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }\n\n    /**\n     * @dev Variant of {invMod}. More efficient, but only works if `p` is known to be a prime greater than `2`.\n     *\n     * From https://en.wikipedia.org/wiki/Fermat%27s_little_theorem[Fermat's little theorem], we know that if p is\n     * prime, then `a**(p-1) ≡ 1 mod p`. As a consequence, we have `a * a**(p-2) ≡ 1 mod p`, which means that\n     * `a**(p-2)` is the modular multiplicative inverse of a in Fp.\n     *\n     * NOTE: this function does NOT check that `p` is a prime greater than `2`.\n     */\n    function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m)\n     *\n     * Requirements:\n     * - modulus can't be zero\n     * - underlying staticcall to precompile must succeed\n     *\n     * IMPORTANT: The result is only valid if the underlying call succeeds. When using this function, make\n     * sure the chain you're using it on supports the precompiled contract for modular exponentiation\n     * at address 0x05 as specified in https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise,\n     * the underlying function will succeed given the lack of a revert, but the result may be incorrectly\n     * interpreted as 0.\n     */\n    function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the modular exponentiation of the specified base, exponent and modulus (b ** e % m).\n     * It includes a success flag indicating if the operation succeeded. Operation will be marked as failed if trying\n     * to operate modulo 0 or if the underlying precompile reverted.\n     *\n     * IMPORTANT: The result is only valid if the success flag is true. When using this function, make sure the chain\n     * you're using it on supports the precompiled contract for modular exponentiation at address 0x05 as specified in\n     * https://eips.ethereum.org/EIPS/eip-198[EIP-198]. Otherwise, the underlying function will succeed given the lack\n     * of a revert, but the result may be incorrectly interpreted as 0.\n     */\n    function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }\n\n    /**\n     * @dev Variant of {modExp} that supports inputs of arbitrary length.\n     */\n    function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }\n\n    /**\n     * @dev Variant of {tryModExp} that supports inputs of arbitrary length.\n     */\n    function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }\n\n    /**\n     * @dev Returns whether the provided byte array is zero.\n     */\n    function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * This method is based on Newton's method for computing square roots; the algorithm is restricted to only\n     * using integer operations.\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x² - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `ε_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) ≤ sqrt(a) < 2**e`). We know that `e ≤ 128` because `(2¹²⁸)² = 2²⁵⁶` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) ≤ sqrt(a) < 2**e → (2**(e-1))² ≤ a < (2**e)² → 2**(2*e-2) ≤ a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) ≤ sqrt(a) < 2**e = 2 * x_n`. This implies ε_n ≤ 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to ε_n ≤ 2**(e-2).\n            // This is going to be our x_0 (and ε_0)\n            xn = (3 * xn) >> 1; // ε_0 := | x_0 - sqrt(a) | ≤ 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}² - a = ((x_n + a / x_n) / 2)² - a\n            //              = ((x_n² + a) / (2 * x_n))² - a\n            //              = (x_n⁴ + 2 * a * x_n² + a²) / (4 * x_n²) - a\n            //              = (x_n⁴ + 2 * a * x_n² + a² - 4 * a * x_n²) / (4 * x_n²)\n            //              = (x_n⁴ - 2 * a * x_n² + a²) / (4 * x_n²)\n            //              = (x_n² - a)² / (2 * x_n)²\n            //              = ((x_n² - a) / (2 * x_n))²\n            //              ≥ 0\n            // Which proves that for all n ≥ 1, sqrt(a) ≤ x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // ε_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n² + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))² / (2 * x_n) |\n            //         = | ε_n² / (2 * x_n) |\n            //         = ε_n² / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // ε_1 = ε_0² / | (2 * x_0) |\n            //     ≤ (2**(e-2))² / (2 * (2**(e-1) + 2**(e-2)))\n            //     ≤ 2**(2*e-4) / (3 * 2**(e-1))\n            //     ≤ 2**(e-3) / 3\n            //     ≤ 2**(e-3-log2(3))\n            //     ≤ 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) ≤ sqrt(a) ≤ x_n:\n            // ε_{n+1} = ε_n² / | (2 * x_n) |\n            //         ≤ (2**(e-k))² / (2 * 2**(e-1))\n            //         ≤ 2**(2*e-2*k) / 2**e\n            //         ≤ 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // ε_1 := | x_1 - sqrt(a) | ≤ 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // ε_2 := | x_2 - sqrt(a) | ≤ 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // ε_3 := | x_3 - sqrt(a) | ≤ 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // ε_4 := | x_4 - sqrt(a) | ≤ 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // ε_5 := | x_5 - sqrt(a) | ≤ 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // ε_6 := | x_6 - sqrt(a) | ≤ 2**(e-144)  -- general case with k = 72\n\n            // Because e ≤ 128 (as discussed during the first estimation phase), we know have reached a precision\n            // ε_6 ≤ 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }\n\n    /**\n     * @dev Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX/bool casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeCast {\n    /**\n     * @dev Value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);\n\n    /**\n     * @dev An int value doesn't fit in an uint of `bits` size.\n     */\n    error SafeCastOverflowedIntToUint(int256 value);\n\n    /**\n     * @dev Value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);\n\n    /**\n     * @dev An uint value doesn't fit in an int of `bits` size.\n     */\n    error SafeCastOverflowedUintToInt(uint256 value);\n\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        if (value > type(uint248).max) {\n            revert SafeCastOverflowedUintDowncast(248, value);\n        }\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        if (value > type(uint240).max) {\n            revert SafeCastOverflowedUintDowncast(240, value);\n        }\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        if (value > type(uint232).max) {\n            revert SafeCastOverflowedUintDowncast(232, value);\n        }\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        if (value > type(uint224).max) {\n            revert SafeCastOverflowedUintDowncast(224, value);\n        }\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        if (value > type(uint216).max) {\n            revert SafeCastOverflowedUintDowncast(216, value);\n        }\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        if (value > type(uint208).max) {\n            revert SafeCastOverflowedUintDowncast(208, value);\n        }\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        if (value > type(uint200).max) {\n            revert SafeCastOverflowedUintDowncast(200, value);\n        }\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        if (value > type(uint192).max) {\n            revert SafeCastOverflowedUintDowncast(192, value);\n        }\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        if (value > type(uint184).max) {\n            revert SafeCastOverflowedUintDowncast(184, value);\n        }\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        if (value > type(uint176).max) {\n            revert SafeCastOverflowedUintDowncast(176, value);\n        }\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        if (value > type(uint168).max) {\n            revert SafeCastOverflowedUintDowncast(168, value);\n        }\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        if (value > type(uint160).max) {\n            revert SafeCastOverflowedUintDowncast(160, value);\n        }\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        if (value > type(uint152).max) {\n            revert SafeCastOverflowedUintDowncast(152, value);\n        }\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        if (value > type(uint144).max) {\n            revert SafeCastOverflowedUintDowncast(144, value);\n        }\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        if (value > type(uint136).max) {\n            revert SafeCastOverflowedUintDowncast(136, value);\n        }\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        if (value > type(uint128).max) {\n            revert SafeCastOverflowedUintDowncast(128, value);\n        }\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        if (value > type(uint120).max) {\n            revert SafeCastOverflowedUintDowncast(120, value);\n        }\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        if (value > type(uint112).max) {\n            revert SafeCastOverflowedUintDowncast(112, value);\n        }\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        if (value > type(uint104).max) {\n            revert SafeCastOverflowedUintDowncast(104, value);\n        }\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        if (value > type(uint96).max) {\n            revert SafeCastOverflowedUintDowncast(96, value);\n        }\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        if (value > type(uint88).max) {\n            revert SafeCastOverflowedUintDowncast(88, value);\n        }\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        if (value > type(uint80).max) {\n            revert SafeCastOverflowedUintDowncast(80, value);\n        }\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        if (value > type(uint72).max) {\n            revert SafeCastOverflowedUintDowncast(72, value);\n        }\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        if (value > type(uint64).max) {\n            revert SafeCastOverflowedUintDowncast(64, value);\n        }\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        if (value > type(uint56).max) {\n            revert SafeCastOverflowedUintDowncast(56, value);\n        }\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        if (value > type(uint48).max) {\n            revert SafeCastOverflowedUintDowncast(48, value);\n        }\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        if (value > type(uint40).max) {\n            revert SafeCastOverflowedUintDowncast(40, value);\n        }\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        if (value > type(uint32).max) {\n            revert SafeCastOverflowedUintDowncast(32, value);\n        }\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        if (value > type(uint24).max) {\n            revert SafeCastOverflowedUintDowncast(24, value);\n        }\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        if (value > type(uint16).max) {\n            revert SafeCastOverflowedUintDowncast(16, value);\n        }\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        if (value > type(uint8).max) {\n            revert SafeCastOverflowedUintDowncast(8, value);\n        }\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        if (value < 0) {\n            revert SafeCastOverflowedIntToUint(value);\n        }\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(248, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(240, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(232, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(224, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(216, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(208, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(200, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(192, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(184, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(176, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(168, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(160, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(152, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(144, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(136, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(128, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(120, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(112, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(104, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(96, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(88, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(80, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(72, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(64, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(56, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(48, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(40, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(32, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(24, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(16, value);\n        }\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        if (downcasted != value) {\n            revert SafeCastOverflowedIntDowncast(8, value);\n        }\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        if (value > uint256(type(int256).max)) {\n            revert SafeCastOverflowedUintToInt(value);\n        }\n        return int256(value);\n    }\n\n    /**\n     * @dev Cast a boolean (false or true) to a uint256 (0 or 1) with no jump.\n     */\n    function toUint(bool b) internal pure returns (uint256 u) {\n        assembly (\"memory-safe\") {\n            u := iszero(iszero(b))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\nimport {SafeCast} from \"./SafeCast.sol\";\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Branchless ternary evaluation for `a ? b : c`. Gas costs are constant.\n     *\n     * IMPORTANT: This function may reduce bytecode size and consume less gas when used standalone.\n     * However, the compiler may optimize Solidity ternary operations (i.e. `a ? b : c`) to only compute\n     * one branch when needed, making this function more expensive.\n     */\n    function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a > b, a, b);\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return ternary(a < b, a, b);\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Panic.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Panic.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Helper library for emitting standardized panic codes.\n *\n * ```solidity\n * contract Example {\n *      using Panic for uint256;\n *\n *      // Use any of the declared internal constants\n *      function foo() { Panic.GENERIC.panic(); }\n *\n *      // Alternatively\n *      function foo() { Panic.panic(Panic.GENERIC); }\n * }\n * ```\n *\n * Follows the list from https://github.com/ethereum/solidity/blob/v0.8.24/libsolutil/ErrorCodes.h[libsolutil].\n *\n * _Available since v5.1._\n */\n// slither-disable-next-line unused-state\nlibrary Panic {\n    /// @dev generic / unspecified error\n    uint256 internal constant GENERIC = 0x00;\n    /// @dev used by the assert() builtin\n    uint256 internal constant ASSERT = 0x01;\n    /// @dev arithmetic underflow or overflow\n    uint256 internal constant UNDER_OVERFLOW = 0x11;\n    /// @dev division or modulo by zero\n    uint256 internal constant DIVISION_BY_ZERO = 0x12;\n    /// @dev enum conversion error\n    uint256 internal constant ENUM_CONVERSION_ERROR = 0x21;\n    /// @dev invalid encoding in storage\n    uint256 internal constant STORAGE_ENCODING_ERROR = 0x22;\n    /// @dev empty array pop\n    uint256 internal constant EMPTY_ARRAY_POP = 0x31;\n    /// @dev array out of bounds access\n    uint256 internal constant ARRAY_OUT_OF_BOUNDS = 0x32;\n    /// @dev resource error (too large allocation or too large array)\n    uint256 internal constant RESOURCE_ERROR = 0x41;\n    /// @dev calling invalid internal function\n    uint256 internal constant INVALID_INTERNAL_FUNCTION = 0x51;\n\n    /// @dev Reverts with a panic code. Recommended to use with\n    /// the internal constants with predefined codes.\n    function panic(uint256 code) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0x00, 0x4e487b71)\n            mstore(0x20, code)\n            revert(0x1c, 0x24)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/SlotDerivation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/SlotDerivation.sol)\n// This file was procedurally generated from scripts/generate/templates/SlotDerivation.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for computing storage (and transient storage) locations from namespaces and deriving slots\n * corresponding to standard patterns. The derivation method for array and mapping matches the storage layout used by\n * the solidity language / compiler.\n *\n * See https://docs.soliditylang.org/en/v0.8.20/internals/layout_in_storage.html#mappings-and-dynamic-arrays[Solidity docs for mappings and dynamic arrays.].\n *\n * Example usage:\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using StorageSlot for bytes32;\n *     using SlotDerivation for bytes32;\n *\n *     // Declare a namespace\n *     string private constant _NAMESPACE = \"<namespace>\"; // eg. OpenZeppelin.Slot\n *\n *     function setValueInNamespace(uint256 key, address newValue) internal {\n *         _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value = newValue;\n *     }\n *\n *     function getValueInNamespace(uint256 key) internal view returns (address) {\n *         return _NAMESPACE.erc7201Slot().deriveMapping(key).getAddressSlot().value;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {StorageSlot}.\n *\n * NOTE: This library provides a way to manipulate storage locations in a non-standard way. Tooling for checking\n * upgrade safety will ignore the slots accessed through this library.\n *\n * _Available since v5.1._\n */\nlibrary SlotDerivation {\n    /**\n     * @dev Derive an ERC-7201 slot from a string (namespace).\n     */\n    function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }\n\n    /**\n     * @dev Add an offset to a slot to get the n-th element of a structure or an array.\n     */\n    function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }\n\n    /**\n     * @dev Derive the location of the first element in an array from the slot where the length is stored.\n     */\n    function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n\n    /**\n     * @dev Derive the location of a mapping element from the key.\n     */\n    function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC-1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     // Define the slot. Alternatively, use the SlotDerivation library to derive the slot.\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(newImplementation.code.length > 0);\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * TIP: Consider using this library along with {SlotDerivation}.\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct Int256Slot {\n        int256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `Int256Slot` with member `value` located at `slot`.\n     */\n    function getInt256Slot(bytes32 slot) internal pure returns (Int256Slot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns a `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns a `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        assembly (\"memory-safe\") {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    using SafeCast for *;\n\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n    uint256 private constant SPECIAL_CHARS_LOOKUP =\n        (1 << 0x08) | // backspace\n            (1 << 0x09) | // tab\n            (1 << 0x0a) | // newline\n            (1 << 0x0c) | // form feed\n            (1 << 0x0d) | // carriage return\n            (1 << 0x22) | // double quote\n            (1 << 0x5c); // backslash\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev The string being parsed contains characters that are not in scope of the given base.\n     */\n    error StringsInvalidChar();\n\n    /**\n     * @dev The string being parsed is not a properly formatted address.\n     */\n    error StringsInvalidAddressFormat();\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its checksummed ASCII `string` hexadecimal\n     * representation, according to EIP-55.\n     */\n    function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input) internal pure returns (uint256) {\n        return parseUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[0-9]*`\n     * - The result must fit into an `uint256` type\n     */\n    function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseUint-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a decimal string and returns the value as a `int256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input) internal pure returns (int256) {\n        return parseInt(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `[-+]?[0-9]*`\n     * - The result must fit in an `int256` type.\n     */\n    function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseInt-string} that returns false if the parsing fails because of an invalid character or if\n     * the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    uint256 private constant ABS_MIN_INT256 = 2 ** 255;\n\n    /**\n     * @dev Variant of {parseInt-string-uint256-uint256} that returns false if the parsing fails because of an invalid\n     * character or if the result does not fit in a `int256`.\n     *\n     * NOTE: This function will revert if the absolute value of the result does not fit in a `uint256`.\n     */\n    function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseInt-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as a `uint256`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input) internal pure returns (uint256) {\n        return parseHexUint(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]*`\n     * - The result must fit in an `uint256` type.\n     */\n    function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string} that returns false if the parsing fails because of an invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseHexUintUncheckedBounds(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseHexUint-string-uint256-uint256} that returns false if the parsing fails because of an\n     * invalid character.\n     *\n     * NOTE: This function will revert if the result does not fit in a `uint256`.\n     */\n    function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }\n\n    /**\n     * @dev Implementation of {tryParseHexUint-string-uint256-uint256} that does not check bounds. Caller should make sure that\n     * `begin <= end <= input.length`. Other inputs would result in undefined behavior.\n     */\n    function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guarantees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }\n\n    /**\n     * @dev Parse a hexadecimal string (with or without \"0x\" prefix), and returns the value as an `address`.\n     *\n     * Requirements:\n     * - The string must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input) internal pure returns (address) {\n        return parseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that parses a substring of `input` located between position `begin` (included) and\n     * `end` (excluded).\n     *\n     * Requirements:\n     * - The substring must be formatted as `(0x)?[0-9a-fA-F]{40}`\n     */\n    function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string} that returns false if the parsing fails because the input is not a properly\n     * formatted address. See {parseAddress-string} requirements.\n     */\n    function tryParseAddress(string memory input) internal pure returns (bool success, address value) {\n        return tryParseAddress(input, 0, bytes(input).length);\n    }\n\n    /**\n     * @dev Variant of {parseAddress-string-uint256-uint256} that returns false if the parsing fails because input is not a properly\n     * formatted address. See {parseAddress-string-uint256-uint256} requirements.\n     */\n    function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }\n\n    function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }\n\n    /**\n     * @dev Escape special characters in JSON strings. This can be useful to prevent JSON injection in NFT metadata.\n     *\n     * WARNING: This function should only be used in double quoted JSON strings. Single quotes are not escaped.\n     *\n     * NOTE: This function escapes all unicode characters, and not just the ones in ranges defined in section 2.5 of\n     * RFC-4627 (U+0000 to U+001F, U+0022 and U+005C). ECMAScript's `JSON.parse` does recover escaped unicode\n     * characters that are not in this range, but other tooling may provide different results.\n     */\n    function escapeJSON(string memory input) internal pure returns (string memory) {\n        bytes memory buffer = bytes(input);\n        bytes memory output = new bytes(2 * buffer.length); // worst case scenario\n        uint256 outputLength = 0;\n\n        for (uint256 i; i < buffer.length; ++i) {\n            bytes1 char = bytes1(_unsafeReadBytesOffset(buffer, i));\n            if (((SPECIAL_CHARS_LOOKUP & (1 << uint8(char))) != 0)) {\n                output[outputLength++] = \"\\\\\";\n                if (char == 0x08) output[outputLength++] = \"b\";\n                else if (char == 0x09) output[outputLength++] = \"t\";\n                else if (char == 0x0a) output[outputLength++] = \"n\";\n                else if (char == 0x0c) output[outputLength++] = \"f\";\n                else if (char == 0x0d) output[outputLength++] = \"r\";\n                else if (char == 0x5c) output[outputLength++] = \"\\\\\";\n                else if (char == 0x22) {\n                    // solhint-disable-next-line quotes\n                    output[outputLength++] = '\"';\n                }\n            } else {\n                output[outputLength++] = char;\n            }\n        }\n        // write the actual length and deallocate unused memory\n        assembly (\"memory-safe\") {\n            mstore(output, outputLength)\n            mstore(0x40, add(output, shl(5, shr(5, add(outputLength, 63)))))\n        }\n\n        return string(output);\n    }\n\n    /**\n     * @dev Reads a bytes32 from a bytes array without bounds checking.\n     *\n     * NOTE: making this function internal would mean it could be used with memory unsafe offset, and marking the\n     * assembly block as such would prevent some optimizations.\n     */\n    function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(buffer, add(0x20, offset)))\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\nimport {Arrays} from \"../Arrays.sol\";\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n * - Set can be cleared (all elements removed) in O(n).\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function _clear(Set storage set) private {\n        uint256 len = _length(set);\n        for (uint256 i = 0; i < len; ++i) {\n            delete set._positions[set._values[i]];\n        }\n        Arrays.unsafeSetLength(set._values, 0);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(Bytes32Set storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(AddressSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes all the values from a set. O(n).\n     *\n     * WARNING: Developers should keep in mind that this function has an unbounded cost and using it may render the\n     * function uncallable if the set grows to the point where clearing it consumes too much gas to fit in a block.\n     */\n    function clear(UintSet storage set) internal {\n        _clear(set._inner);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly (\"memory-safe\") {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/cbor/BigIntCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/CommonTypes.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR serialization and deserialization for BigInt type\n/// @author Zondax AG\nlibrary BigIntCBOR {\n    /// @notice serialize BigInt instance to bytes\n    /// @param num BigInt instance to serialize\n    /// @return serialized BigInt as bytes\n    function serializeBigInt(CommonTypes.BigInt memory num) internal pure returns (bytes memory) {\n        bytes memory raw = new bytes(num.val.length + 1);\n\n        raw[0] = num.neg == true ? bytes1(0x01) : bytes1(0x00);\n\n        uint index = 1;\n        for (uint i = 0; i < num.val.length; i++) {\n            raw[index] = num.val[i];\n            index++;\n        }\n\n        return raw;\n    }\n\n    /// @notice deserialize big int (encoded as bytes) to BigInt instance\n    /// @param raw as bytes to parse\n    /// @return parsed BigInt instance\n    function deserializeBigInt(bytes memory raw) internal pure returns (CommonTypes.BigInt memory) {\n        if (raw.length == 0) {\n            return CommonTypes.BigInt(hex\"00\", false);\n        }\n\n        bytes memory val = new bytes(raw.length - 1);\n        bool neg = false;\n\n        if (raw[0] == 0x01) {\n            neg = true;\n        }\n\n        for (uint i = 1; i < raw.length; i++) {\n            val[i - 1] = raw[i];\n        }\n\n        return CommonTypes.BigInt(val, neg);\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/cbor/BytesCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\nimport \"../types/CommonTypes.sol\";\n\nimport \"./BigIntCbor.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR serialization and deserialization for bytes\n/// @author Zondax AG\nlibrary BytesCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for bytes;\n\n    /// @notice serialize raw bytes as cbor bytes string encoded\n    /// @param data raw data in bytes\n    /// @return encoded cbor bytes\n    function serializeBytes(bytes memory data) internal pure returns (bytes memory) {\n        uint256 capacity = Misc.getBytesSize(data);\n\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.writeBytes(data);\n\n        return buf.data();\n    }\n\n    /// @notice serialize raw address (in bytes) as cbor bytes string encoded (how an address is passed to filecoin actors)\n    /// @param addr raw address in bytes\n    /// @return encoded address as cbor bytes\n    function serializeAddress(bytes memory addr) internal pure returns (bytes memory) {\n        return serializeBytes(addr);\n    }\n\n    /// @notice encoded null value as cbor\n    /// @return cbor encoded null\n    function serializeNull() internal pure returns (bytes memory) {\n        CBOR.CBORBuffer memory buf = CBOR.create(1);\n\n        buf.writeNull();\n\n        return buf.data();\n    }\n\n    /// @notice deserialize cbor encoded filecoin address to bytes\n    /// @param ret cbor encoded filecoin address\n    /// @return raw bytes representing a filecoin address\n    function deserializeAddress(bytes memory ret) internal pure returns (bytes memory) {\n        bytes memory addr;\n        uint byteIdx = 0;\n\n        (addr, byteIdx) = ret.readBytes(byteIdx);\n\n        return addr;\n    }\n\n    /// @notice deserialize cbor encoded string\n    /// @param ret cbor encoded string (in bytes)\n    /// @return decoded string\n    function deserializeString(bytes memory ret) internal pure returns (string memory) {\n        string memory response;\n        uint byteIdx = 0;\n\n        (response, byteIdx) = ret.readString(byteIdx);\n\n        return response;\n    }\n\n    /// @notice deserialize cbor encoded bool\n    /// @param ret cbor encoded bool (in bytes)\n    /// @return decoded bool\n    function deserializeBool(bytes memory ret) internal pure returns (bool) {\n        bool response;\n        uint byteIdx = 0;\n\n        (response, byteIdx) = ret.readBool(byteIdx);\n\n        return response;\n    }\n\n    /// @notice deserialize cbor encoded BigInt\n    /// @param ret cbor encoded BigInt (in bytes)\n    /// @return decoded BigInt\n    /// @dev BigInts are cbor encoded as bytes string first. That is why it unwraps the cbor encoded bytes first, and then parse the result into BigInt\n    function deserializeBytesBigInt(bytes memory ret) internal pure returns (CommonTypes.BigInt memory) {\n        bytes memory tmp;\n        uint byteIdx = 0;\n\n        if (ret.length > 0) {\n            (tmp, byteIdx) = ret.readBytes(byteIdx);\n            if (tmp.length > 0) {\n                return tmp.deserializeBigInt();\n            }\n        }\n\n        return CommonTypes.BigInt(new bytes(0), false);\n    }\n\n    /// @notice deserialize cbor encoded uint64\n    /// @param rawResp cbor encoded uint64 (in bytes)\n    /// @return decoded uint64\n    function deserializeUint64(bytes memory rawResp) internal pure returns (uint64) {\n        uint byteIdx = 0;\n        uint64 value;\n\n        (value, byteIdx) = rawResp.readUInt64(byteIdx);\n        return value;\n    }\n\n    /// @notice deserialize cbor encoded int64\n    /// @param rawResp cbor encoded int64 (in bytes)\n    /// @return decoded int64\n    function deserializeInt64(bytes memory rawResp) internal pure returns (int64) {\n        uint byteIdx = 0;\n        int64 value;\n\n        (value, byteIdx) = rawResp.readInt64(byteIdx);\n        return value;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/cbor/FilecoinCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\nimport \"../utils/CborDecode.sol\";\nimport \"../utils/Misc.sol\";\n\nimport \"../types/CommonTypes.sol\";\n\nimport \"../cbor/BigIntCbor.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR serialization and deserialization for general data types on the filecoin network.\n/// @author Zondax AG\nlibrary FilecoinCBOR {\n    using Buffer for Buffer.buffer;\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for *;\n    using BigIntCBOR for *;\n\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant TAG_TYPE_CID_CODE = 42;\n    uint8 private constant PAYLOAD_LEN_8_BITS = 24;\n\n    /// @notice Write a CID into a CBOR buffer.\n    /// @dev The CBOR major will be 6 (type 'tag') and the tag type value is 42, as per CBOR tag assignments.\n    /// @dev https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml\n    /// @param buf buffer containing the actual CBOR serialization process\n    /// @param value CID value to serialize as CBOR\n    function writeCid(CBOR.CBORBuffer memory buf, bytes memory value) internal pure {\n        buf.buf.appendUint8(uint8(((MAJOR_TYPE_TAG << 5) | PAYLOAD_LEN_8_BITS)));\n        buf.buf.appendUint8(TAG_TYPE_CID_CODE);\n        // See https://ipld.io/specs/codecs/dag-cbor/spec/#links for explanation on 0x00 prefix.\n        buf.writeBytes(bytes.concat(hex'00', value));\n    }\n\n    function readCid(bytes memory cborData, uint byteIdx) internal pure returns (CommonTypes.Cid memory, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = cborData.parseCborHeader(byteIdx);\n        require(maj == MAJOR_TYPE_TAG, \"expected major type tag when parsing cid\");\n        require(value == TAG_TYPE_CID_CODE, \"expected tag 42 when parsing cid\");\n\n        bytes memory raw;\n        (raw, byteIdx) = cborData.readBytes(byteIdx);\n        require(raw[0] == 0x00, \"expected first byte to be 0 when parsing cid\");\n\n        // Pop off the first byte, which corresponds to the historical multibase 0x00 byte.\n        // https://ipld.io/specs/codecs/dag-cbor/spec/#links\n        CommonTypes.Cid memory ret;\n        ret.data = new bytes(raw.length - 1);\n        for (uint256 i = 1; i < raw.length; i++) {\n            ret.data[i-1] = raw[i];\n        }\n\n        return (ret, byteIdx);\n    }\n\n    /// @notice serialize filecoin address to cbor encoded\n    /// @param addr filecoin address to serialize\n    /// @return cbor serialized data as bytes\n    function serializeAddress(CommonTypes.FilAddress memory addr) internal pure returns (bytes memory) {\n        uint256 capacity = Misc.getBytesSize(addr.data);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.writeBytes(addr.data);\n\n        return buf.data();\n    }\n\n    /// @notice serialize a BigInt value wrapped in a cbor fixed array.\n    /// @param value BigInt to serialize as cbor inside an\n    /// @return cbor serialized data as bytes\n    function serializeArrayBigInt(CommonTypes.BigInt memory value) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory valueBigInt = value.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(1);\n        capacity += Misc.getBytesSize(valueBigInt);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(1);\n        buf.writeBytes(value.serializeBigInt());\n\n        return buf.data();\n    }\n\n    /// @notice serialize a FilAddress value wrapped in a cbor fixed array.\n    /// @param addr FilAddress to serialize as cbor inside an\n    /// @return cbor serialized data as bytes\n    function serializeArrayFilAddress(CommonTypes.FilAddress memory addr) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n\n        capacity += Misc.getPrefixSize(1);\n        capacity += Misc.getBytesSize(addr.data);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(1);\n        buf.writeBytes(addr.data);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize a FilAddress wrapped on a cbor fixed array coming from a actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of FilAddress created based on parsed data\n    function deserializeArrayFilAddress(bytes memory rawResp) internal pure returns (CommonTypes.FilAddress memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        require(len == 1, \"Wrong numbers of parameters (should find 1)\");\n\n        (ret.data, byteIdx) = rawResp.readBytes(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice deserialize a BigInt wrapped on a cbor fixed array coming from a actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of BigInt created based on parsed data\n    function deserializeArrayBigInt(bytes memory rawResp) internal pure returns (CommonTypes.BigInt memory) {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 1);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        return tmp.deserializeBigInt();\n    }\n\n    /// @notice serialize UniversalReceiverParams struct to cbor in order to pass as arguments to an actor\n    /// @param params UniversalReceiverParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeUniversalReceiverParams(CommonTypes.UniversalReceiverParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getPrefixSize(params.type_);\n        capacity += Misc.getBytesSize(params.payload);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeUInt64(params.type_);\n        buf.writeBytes(params.payload);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize UniversalReceiverParams cbor to struct when receiving a message\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of UniversalReceiverParams created based on parsed data\n    function deserializeUniversalReceiverParams(bytes memory rawResp) internal pure returns (CommonTypes.UniversalReceiverParams memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        require(len == 2, \"Wrong numbers of parameters (should find 2)\");\n\n        (ret.type_, byteIdx) = rawResp.readUInt32(byteIdx);\n        (ret.payload, byteIdx) = rawResp.readBytes(byteIdx);\n    }\n\n    /// @notice attempt to read a FilActorId value\n    /// @param rawResp cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return a FilActorId decoded from input bytes and the byte index after moving past the value\n    function readFilActorId(bytes memory rawResp, uint byteIdx) internal pure returns (CommonTypes.FilActorId, uint) {\n        uint64 tmp = 0;\n\n        (tmp, byteIdx) = rawResp.readUInt64(byteIdx);\n        return (CommonTypes.FilActorId.wrap(tmp), byteIdx);\n    }\n\n    /// @notice write FilActorId into a cbor buffer\n    /// @dev FilActorId is just wrapping a uint64\n    /// @param buf buffer containing the actual cbor serialization process\n    /// @param id FilActorId to serialize as cbor\n    function writeFilActorId(CBOR.CBORBuffer memory buf, CommonTypes.FilActorId id) internal pure {\n        buf.writeUInt64(CommonTypes.FilActorId.unwrap(id));\n    }\n\n    /// @notice attempt to read a ChainEpoch value\n    /// @param rawResp cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return a ChainEpoch decoded from input bytes and the byte index after moving past the value\n    function readChainEpoch(bytes memory rawResp, uint byteIdx) internal pure returns (CommonTypes.ChainEpoch, uint) {\n        int64 tmp = 0;\n\n        (tmp, byteIdx) = rawResp.readInt64(byteIdx);\n        return (CommonTypes.ChainEpoch.wrap(tmp), byteIdx);\n    }\n\n    /// @notice write ChainEpoch into a cbor buffer\n    /// @dev ChainEpoch is just wrapping a int64\n    /// @param buf buffer containing the actual cbor serialization process\n    /// @param id ChainEpoch to serialize as cbor\n    function writeChainEpoch(CBOR.CBORBuffer memory buf, CommonTypes.ChainEpoch id) internal pure {\n        buf.writeInt64(CommonTypes.ChainEpoch.unwrap(id));\n    }\n\n    /// @notice write DealLabel into a cbor buffer\n    /// @param buf buffer containing the actual cbor serialization process\n    /// @param label DealLabel to serialize as cbor\n    function writeDealLabel(CBOR.CBORBuffer memory buf, CommonTypes.DealLabel memory label) internal pure {\n        label.isString ? buf.writeString(string(label.data)) : buf.writeBytes(label.data);\n    }\n\n    /// @notice deserialize DealLabel cbor to struct when receiving a message\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of DealLabel created based on parsed data\n    function deserializeDealLabel(bytes memory rawResp) internal pure returns (CommonTypes.DealLabel memory) {\n        uint byteIdx = 0;\n        CommonTypes.DealLabel memory label;\n\n        (label, byteIdx) = readDealLabel(rawResp, byteIdx);\n        return label;\n    }\n\n    /// @notice attempt to read a DealLabel value\n    /// @param rawResp cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return a DealLabel decoded from input bytes and the byte index after moving past the value\n    function readDealLabel(bytes memory rawResp, uint byteIdx) internal pure returns (CommonTypes.DealLabel memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = CBORDecoder.parseCborHeader(rawResp, byteIdx);\n        require(maj == MajByteString || maj == MajTextString, \"invalid maj (expected MajByteString or MajTextString)\");\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = rawResp[i];\n            slice_index++;\n        }\n\n        return (CommonTypes.DealLabel(slice, maj == MajTextString), byteIdx + len);\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/cbor/MarketCbor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"solidity-cborutils/contracts/CBOR.sol\";\n\nimport \"../types/MarketTypes.sol\";\nimport \"../types/CommonTypes.sol\";\n\nimport \"../utils/Misc.sol\";\nimport \"../utils/FilAddresses.sol\";\nimport \"../utils/CborDecode.sol\";\n\nimport \"./FilecoinCbor.sol\";\nimport \"./BigIntCbor.sol\";\nimport \"./FilecoinCbor.sol\";\n\n/// @title This library is a set of functions meant to handle CBOR parameters serialization and return values deserialization for Market actor exported methods.\n/// @author Zondax AG\nlibrary MarketCBOR {\n    using CBOR for CBOR.CBORBuffer;\n    using CBORDecoder for bytes;\n    using BigIntCBOR for *;\n    using FilecoinCBOR for *;\n\n    /// @notice serialize WithdrawBalanceParams struct to cbor in order to pass as arguments to the market actor\n    /// @param params WithdrawBalanceParams to serialize as cbor\n    /// @return response cbor serialized data as bytes\n    function serializeWithdrawBalanceParams(MarketTypes.WithdrawBalanceParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory tokenAmount = params.tokenAmount.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(2);\n        capacity += Misc.getBytesSize(params.provider_or_client.data);\n        capacity += Misc.getBytesSize(tokenAmount);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(2);\n        buf.writeBytes(params.provider_or_client.data);\n        buf.writeBytes(tokenAmount);\n\n        return buf.data();\n    }\n\n    /// @notice deserialize GetBalanceReturn struct from cbor encoded bytes coming from a market actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetBalanceReturn created based on parsed data\n    function deserializeGetBalanceReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetBalanceReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.balance = tmp.deserializeBigInt();\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.locked = tmp.deserializeBigInt();\n\n        return ret;\n    }\n\n    /// @notice deserialize GetDealDataCommitmentReturn struct from cbor encoded bytes coming from a market actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetDealDataCommitmentReturn created based on parsed data\n    function deserializeGetDealDataCommitmentReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetDealDataCommitmentReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n\n        if (len > 0) {\n            (ret.data, byteIdx) = rawResp.readBytes(byteIdx);\n            (ret.size, byteIdx) = rawResp.readUInt64(byteIdx);\n        } else {\n            ret.data = new bytes(0);\n            ret.size = 0;\n        }\n\n        return ret;\n    }\n\n    /// @notice deserialize GetDealTermReturn struct from cbor encoded bytes coming from a market actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetDealTermReturn created based on parsed data\n    function deserializeGetDealTermReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetDealTermReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.start, byteIdx) = rawResp.readChainEpoch(byteIdx);\n        (ret.end, byteIdx) = rawResp.readChainEpoch(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice deserialize GetDealActivationReturn struct from cbor encoded bytes coming from a market actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of GetDealActivationReturn created based on parsed data\n    function deserializeGetDealActivationReturn(bytes memory rawResp) internal pure returns (MarketTypes.GetDealActivationReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.activated, byteIdx) = rawResp.readChainEpoch(byteIdx);\n        (ret.terminated, byteIdx) = rawResp.readChainEpoch(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice serialize PublishStorageDealsParams struct to cbor in order to pass as arguments to the market actor\n    /// @param params PublishStorageDealsParams to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializePublishStorageDealsParams(MarketTypes.PublishStorageDealsParams memory params) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n\n        capacity += Misc.getPrefixSize(1);\n        capacity += Misc.getPrefixSize(params.deals.length);\n\n        for (uint64 i = 0; i < params.deals.length; i++) {\n            capacity += Misc.getPrefixSize(2);\n            capacity += Misc.getPrefixSize(11);\n\n            capacity += Misc.getCidSize(params.deals[i].proposal.piece_cid.data);\n            capacity += Misc.getPrefixSize(params.deals[i].proposal.piece_size);\n            capacity += Misc.getBoolSize();\n            capacity += Misc.getBytesSize(params.deals[i].proposal.client.data);\n            capacity += Misc.getBytesSize(params.deals[i].proposal.provider.data);\n            capacity += Misc.getBytesSize(params.deals[i].proposal.label.data);\n            capacity += Misc.getChainEpochSize(params.deals[i].proposal.start_epoch);\n            capacity += Misc.getChainEpochSize(params.deals[i].proposal.end_epoch);\n            capacity += Misc.getBytesSize(params.deals[i].proposal.storage_price_per_epoch.serializeBigInt());\n            capacity += Misc.getBytesSize(params.deals[i].proposal.provider_collateral.serializeBigInt());\n            capacity += Misc.getBytesSize(params.deals[i].proposal.client_collateral.serializeBigInt());\n\n            capacity += Misc.getBytesSize(params.deals[i].client_signature);\n        }\n\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(1);\n        buf.startFixedArray(uint64(params.deals.length));\n\n        for (uint64 i = 0; i < params.deals.length; i++) {\n            buf.startFixedArray(2);\n\n            buf.startFixedArray(11);\n\n            buf.writeCid(params.deals[i].proposal.piece_cid.data);\n            buf.writeUInt64(params.deals[i].proposal.piece_size);\n            buf.writeBool(params.deals[i].proposal.verified_deal);\n            buf.writeBytes(params.deals[i].proposal.client.data);\n            buf.writeBytes(params.deals[i].proposal.provider.data);\n            buf.writeDealLabel(params.deals[i].proposal.label);\n            buf.writeChainEpoch(params.deals[i].proposal.start_epoch);\n            buf.writeChainEpoch(params.deals[i].proposal.end_epoch);\n            buf.writeBytes(params.deals[i].proposal.storage_price_per_epoch.serializeBigInt());\n            buf.writeBytes(params.deals[i].proposal.provider_collateral.serializeBigInt());\n            buf.writeBytes(params.deals[i].proposal.client_collateral.serializeBigInt());\n\n            buf.writeBytes(params.deals[i].client_signature);\n        }\n\n        return buf.data();\n    }\n\n    /// @notice deserialize PublishStorageDealsReturn struct from cbor encoded bytes coming from a market actor call\n    /// @param rawResp cbor encoded response\n    /// @return ret new instance of PublishStorageDealsReturn created based on parsed data\n    function deserializePublishStorageDealsReturn(bytes memory rawResp) internal pure returns (MarketTypes.PublishStorageDealsReturn memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        ret.ids = new uint64[](len);\n\n        for (uint i = 0; i < len; i++) {\n            (ret.ids[i], byteIdx) = rawResp.readUInt64(byteIdx);\n        }\n\n        (ret.valid_deals, byteIdx) = rawResp.readBytes(byteIdx);\n\n        return ret;\n    }\n\n    /// @notice serialize deal id (uint64) to cbor in order to pass as arguments to the market actor\n    /// @param id deal id to serialize as cbor\n    /// @return cbor serialized data as bytes\n    function serializeDealID(uint64 id) internal pure returns (bytes memory) {\n        uint256 capacity = Misc.getPrefixSize(uint256(id));\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.writeUInt64(id);\n\n        return buf.data();\n    }\n\n    function deserializeMarketDealNotifyParams(bytes memory rawResp) internal pure returns (MarketTypes.MarketDealNotifyParams memory ret) {\n        uint byteIdx = 0;\n        uint len;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 2);\n\n        (ret.dealProposal, byteIdx) = rawResp.readBytes(byteIdx);\n        (ret.dealId, byteIdx) = rawResp.readUInt64(byteIdx);\n    }\n\n    function serializeDealProposal(MarketTypes.DealProposal memory dealProposal) internal pure returns (bytes memory) {\n        uint256 capacity = 0;\n        bytes memory storage_price_per_epoch = dealProposal.storage_price_per_epoch.serializeBigInt();\n        bytes memory provider_collateral = dealProposal.provider_collateral.serializeBigInt();\n        bytes memory client_collateral = dealProposal.client_collateral.serializeBigInt();\n\n        capacity += Misc.getPrefixSize(11);\n        capacity += Misc.getCidSize(dealProposal.piece_cid.data);\n        capacity += Misc.getPrefixSize(dealProposal.piece_size);\n        capacity += Misc.getBoolSize();\n        capacity += Misc.getBytesSize(dealProposal.client.data);\n        capacity += Misc.getBytesSize(dealProposal.provider.data);\n        capacity += Misc.getBytesSize(dealProposal.label.data);\n        capacity += Misc.getChainEpochSize(dealProposal.start_epoch);\n        capacity += Misc.getChainEpochSize(dealProposal.end_epoch);\n        capacity += Misc.getBytesSize(storage_price_per_epoch);\n        capacity += Misc.getBytesSize(provider_collateral);\n        capacity += Misc.getBytesSize(client_collateral);\n        CBOR.CBORBuffer memory buf = CBOR.create(capacity);\n\n        buf.startFixedArray(11);\n\n        buf.writeCid(dealProposal.piece_cid.data);\n        buf.writeUInt64(dealProposal.piece_size);\n        buf.writeBool(dealProposal.verified_deal);\n        buf.writeBytes(dealProposal.client.data);\n        buf.writeBytes(dealProposal.provider.data);\n        buf.writeDealLabel(dealProposal.label);\n        buf.writeChainEpoch(dealProposal.start_epoch);\n        buf.writeChainEpoch(dealProposal.end_epoch);\n        buf.writeBytes(storage_price_per_epoch);\n        buf.writeBytes(provider_collateral);\n        buf.writeBytes(client_collateral);\n\n        return buf.data();\n    }\n\n    function deserializeDealProposal(bytes memory rawResp) internal pure returns (MarketTypes.DealProposal memory ret) {\n        uint byteIdx = 0;\n        uint len;\n        bytes memory tmp;\n\n        (len, byteIdx) = rawResp.readFixedArray(byteIdx);\n        assert(len == 11);\n\n        (ret.piece_cid, byteIdx) = rawResp.readCid(byteIdx);\n        (ret.piece_size, byteIdx) = rawResp.readUInt64(byteIdx);\n        (ret.verified_deal, byteIdx) = rawResp.readBool(byteIdx);\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.client = FilAddresses.fromBytes(tmp);\n\n        (tmp, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.provider = FilAddresses.fromBytes(tmp);\n\n        (ret.label, byteIdx) = rawResp.readDealLabel(byteIdx);\n\n        (ret.start_epoch, byteIdx) = rawResp.readChainEpoch(byteIdx);\n        (ret.end_epoch, byteIdx) = rawResp.readChainEpoch(byteIdx);\n\n        bytes memory storage_price_per_epoch_bytes;\n        (storage_price_per_epoch_bytes, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.storage_price_per_epoch = storage_price_per_epoch_bytes.deserializeBigInt();\n\n        bytes memory provider_collateral_bytes;\n        (provider_collateral_bytes, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.provider_collateral = provider_collateral_bytes.deserializeBigInt();\n\n        bytes memory client_collateral_bytes;\n        (client_collateral_bytes, byteIdx) = rawResp.readBytes(byteIdx);\n        ret.client_collateral = client_collateral_bytes.deserializeBigInt();\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/MarketAPI.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./types/MarketTypes.sol\";\nimport \"./cbor/MarketCbor.sol\";\nimport \"./cbor/BytesCbor.sol\";\nimport \"./cbor/FilecoinCbor.sol\";\n\nimport \"./types/CommonTypes.sol\";\nimport \"./utils/Misc.sol\";\nimport \"./utils/Actor.sol\";\n\n/// @title This library is a proxy to the singleton Storage Market actor (address: f05). Calling one of its methods will result in a cross-actor call being performed.\n/// @author Zondax AG\nlibrary MarketAPI {\n    using BytesCBOR for bytes;\n    using MarketCBOR for *;\n    using FilecoinCBOR for *;\n\n    /// @notice Deposits the received value into the balance held in escrow.\n    function addBalance(CommonTypes.FilAddress memory providerOrClient, uint256 value) internal {\n        bytes memory raw_request = providerOrClient.serializeAddress();\n\n        bytes memory data = Actor.callByID(MarketTypes.ActorID, MarketTypes.AddBalanceMethodNum, Misc.CBOR_CODEC, raw_request, value, false);\n        if (data.length != 0) {\n            revert Actor.InvalidResponseLength();\n        }\n    }\n\n    /// @notice Attempt to withdraw the specified amount from the balance held in escrow.\n    /// @notice If less than the specified amount is available, yields the entire available balance.\n    function withdrawBalance(MarketTypes.WithdrawBalanceParams memory params) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = params.serializeWithdrawBalanceParams();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.WithdrawBalanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice Return the escrow balance and locked amount for an address.\n    /// @return the escrow balance and locked amount for an address.\n    function getBalance(CommonTypes.FilAddress memory addr) internal returns (MarketTypes.GetBalanceReturn memory) {\n        bytes memory raw_request = addr.serializeAddress();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetBalanceMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetBalanceReturn();\n    }\n\n    /// @notice This will be available after the deal is published (whether or not is is activated) and up until some undefined period after it is terminated.\n    /// @return the data commitment and size of a deal proposal.\n    function getDealDataCommitment(uint64 dealID) internal returns (MarketTypes.GetDealDataCommitmentReturn memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealDataCommitmentMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetDealDataCommitmentReturn();\n    }\n\n    /// @notice get the client of the deal proposal.\n    /// @return the client of a deal proposal.\n    function getDealClient(uint64 dealID) internal returns (uint64) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealClientMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeUint64();\n    }\n\n    /// @notice get the provider of a deal proposal.\n    /// @return the provider of a deal proposal.\n    function getDealProvider(uint64 dealID) internal returns (uint64) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealProviderMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeUint64();\n    }\n\n    /// @notice Get the label of a deal proposal.\n    /// @return the label of a deal proposal.\n    function getDealLabel(uint64 dealID) internal returns (CommonTypes.DealLabel memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealLabelMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeDealLabel();\n    }\n\n    /// @notice Get the start epoch and duration(in epochs) of a deal proposal.\n    /// @return the start epoch and duration (in epochs) of a deal proposal.\n    function getDealTerm(uint64 dealID) internal returns (MarketTypes.GetDealTermReturn memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealTermMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetDealTermReturn();\n    }\n\n    /// @notice get the total price that will be paid from the client to the provider for this deal.\n    /// @return the per-epoch price of a deal proposal.\n    function getDealTotalPrice(uint64 dealID) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealTotalPriceMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice get the client collateral requirement for a deal proposal.\n    /// @return the client collateral requirement for a deal proposal.\n    function getDealClientCollateral(uint64 dealID) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealClientCollateralMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice get the provide collateral requirement for a deal proposal.\n    /// @return the provider collateral requirement for a deal proposal.\n    function getDealProviderCollateral(uint64 dealID) internal returns (CommonTypes.BigInt memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealProviderCollateralMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBytesBigInt();\n    }\n\n    /// @notice get the verified flag for a deal proposal.\n    /// @notice Note that the source of truth for verified allocations and claims is the verified registry actor.\n    /// @return the verified flag for a deal proposal.\n    function getDealVerified(uint64 dealID) internal returns (bool) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealVerifiedMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeBool();\n    }\n\n    /// @notice Fetches activation state for a deal.\n    /// @notice This will be available from when the proposal is published until an undefined period after the deal finishes (either normally or by termination).\n    /// @return USR_NOT_FOUND if the deal doesn't exist (yet), or EX_DEAL_EXPIRED if the deal has been removed from state.\n    function getDealActivation(uint64 dealID) internal returns (MarketTypes.GetDealActivationReturn memory) {\n        bytes memory raw_request = dealID.serializeDealID();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.GetDealActivationMethodNum, Misc.CBOR_CODEC, raw_request, 0, true);\n\n        return result.deserializeGetDealActivationReturn();\n    }\n\n    /// @notice Publish a new set of storage deals (not yet included in a sector).\n    function publishStorageDeals(MarketTypes.PublishStorageDealsParams memory params) internal returns (MarketTypes.PublishStorageDealsReturn memory) {\n        bytes memory raw_request = params.serializePublishStorageDealsParams();\n\n        bytes memory result = Actor.callByID(MarketTypes.ActorID, MarketTypes.PublishStorageDealsMethodNum, Misc.CBOR_CODEC, raw_request, 0, false);\n\n        return result.deserializePublishStorageDealsReturn();\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\n\n/// @title Filecoin actors' common types for Solidity.\n/// @author Zondax AG\nlibrary CommonTypes {\n    uint constant UniversalReceiverHookMethodNum = 3726118371;\n\n    /// @param idx index for the failure in batch\n    /// @param code failure code\n    struct FailCode {\n        uint32 idx;\n        uint32 code;\n    }\n\n    /// @param success_count total successes in batch\n    /// @param fail_codes list of failures code and index for each failure in batch\n    struct BatchReturn {\n        uint32 success_count;\n        FailCode[] fail_codes;\n    }\n\n    /// @param type_ asset type\n    /// @param payload payload corresponding to asset type\n    struct UniversalReceiverParams {\n        uint32 type_;\n        bytes payload;\n    }\n\n    /// @param val contains the actual arbitrary number written as binary\n    /// @param neg indicates if val is negative or not\n    struct BigInt {\n        bytes val;\n        bool neg;\n    }\n\n    /// @param data filecoin address in bytes format\n    struct FilAddress {\n        bytes data;\n    }\n\n    /// @param data cid in bytes format\n    struct Cid {\n        bytes data;\n    }\n\n    /// @param data deal proposal label in bytes format (it can be utf8 string or arbitrary bytes string).\n    /// @param isString indicates if the data is string or raw bytes\n    struct DealLabel {\n        bytes data;\n        bool isString;\n    }\n\n    type FilActorId is uint64;\n\n    type ChainEpoch is int64;\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../cbor/BigIntCbor.sol\";\nimport \"./CommonTypes.sol\";\n\n/// @title Filecoin market actor types for Solidity.\n/// @author Zondax AG\nlibrary MarketTypes {\n    CommonTypes.FilActorId constant ActorID = CommonTypes.FilActorId.wrap(5);\n    uint constant AddBalanceMethodNum = 822473126;\n    uint constant WithdrawBalanceMethodNum = 2280458852;\n    uint constant GetBalanceMethodNum = 726108461;\n    uint constant GetDealDataCommitmentMethodNum = 1157985802;\n    uint constant GetDealClientMethodNum = 128053329;\n    uint constant GetDealProviderMethodNum = 935081690;\n    uint constant GetDealLabelMethodNum = 46363526;\n    uint constant GetDealTermMethodNum = 163777312;\n    uint constant GetDealTotalPriceMethodNum = 4287162428;\n    uint constant GetDealClientCollateralMethodNum = 200567895;\n    uint constant GetDealProviderCollateralMethodNum = 2986712137;\n    uint constant GetDealVerifiedMethodNum = 2627389465;\n    uint constant GetDealActivationMethodNum = 2567238399;\n    uint constant PublishStorageDealsMethodNum = 2236929350;\n\n    /// @param provider_or_client the address of provider or client.\n    /// @param tokenAmount the token amount to withdraw.\n    struct WithdrawBalanceParams {\n        CommonTypes.FilAddress provider_or_client;\n        CommonTypes.BigInt tokenAmount;\n    }\n\n    /// @param balance the escrow balance for this address.\n    /// @param locked the escrow locked amount for this address.\n    struct GetBalanceReturn {\n        CommonTypes.BigInt balance;\n        CommonTypes.BigInt locked;\n    }\n\n    /// @param data the data commitment of this deal.\n    /// @param size the size of this deal.\n    struct GetDealDataCommitmentReturn {\n        bytes data;\n        uint64 size;\n    }\n\n    /// @param start the chain epoch to start the deal.\n    /// @param endthe chain epoch to end the deal.\n    struct GetDealTermReturn {\n        CommonTypes.ChainEpoch start;\n        CommonTypes.ChainEpoch end;\n    }\n\n    /// @param activated Epoch at which the deal was activated, or -1.\n    /// @param terminated Epoch at which the deal was terminated abnormally, or -1.\n    struct GetDealActivationReturn {\n        CommonTypes.ChainEpoch activated;\n        CommonTypes.ChainEpoch terminated;\n    }\n\n    /// @param deals list of deal proposals signed by a client\n    struct PublishStorageDealsParams {\n        ClientDealProposal[] deals;\n    }\n\n    /// @param ids returned storage deal IDs.\n    /// @param valid_deals represent all the valid deals.\n    struct PublishStorageDealsReturn {\n        uint64[] ids;\n        bytes valid_deals;\n    }\n\n    /// @param piece_cid PieceCID.\n    /// @param piece_size the size of the piece.\n    /// @param verified_deal if the deal is verified or not.\n    /// @param client the address of the storage client.\n    /// @param provider the address of the storage provider.\n    /// @param label any label that client choose for the deal.\n    /// @param start_epoch the chain epoch to start the deal.\n    /// @param end_epoch the chain epoch to end the deal.\n    /// @param storage_price_per_epoch the token amount to pay to provider per epoch.\n    /// @param provider_collateral the token amount as collateral paid by the provider.\n    /// @param client_collateral the token amount as collateral paid by the client.\n    struct DealProposal {\n        CommonTypes.Cid piece_cid;\n        uint64 piece_size;\n        bool verified_deal;\n        CommonTypes.FilAddress client;\n        CommonTypes.FilAddress provider;\n        CommonTypes.DealLabel label;\n        CommonTypes.ChainEpoch start_epoch;\n        CommonTypes.ChainEpoch end_epoch;\n        CommonTypes.BigInt storage_price_per_epoch;\n        CommonTypes.BigInt provider_collateral;\n        CommonTypes.BigInt client_collateral;\n    }\n\n    /// @param proposal Proposal\n    /// @param client_signature the signature signed by the client.\n    struct ClientDealProposal {\n        DealProposal proposal;\n        bytes client_signature;\n    }\n\n    struct MarketDealNotifyParams {\n        bytes dealProposal;\n        uint64 dealId;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/Actor.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"./Misc.sol\";\nimport \"../types/CommonTypes.sol\";\n\n/// @title Call actors utilities library, meant to interact with Filecoin builtin actors\n/// @author Zondax AG\nlibrary Actor {\n    /// @notice precompile address for the call_actor precompile\n    address constant CALL_ACTOR_ADDRESS = 0xfe00000000000000000000000000000000000003;\n\n    /// @notice precompile address for the call_actor_id precompile\n    address constant CALL_ACTOR_ID = 0xfe00000000000000000000000000000000000005;\n\n    /// @notice flag used to indicate that the call_actor or call_actor_id should perform a static_call to the desired actor\n    uint64 constant READ_ONLY_FLAG = 0x00000001;\n\n    /// @notice flag used to indicate that the call_actor or call_actor_id should perform a call to the desired actor\n    uint64 constant DEFAULT_FLAG = 0x00000000;\n\n    /// @notice the provided address is not valid\n    error InvalidAddress(bytes addr);\n\n    /// @notice the smart contract has no enough balance to transfer\n    error NotEnoughBalance(uint256 balance, uint256 value);\n\n    /// @notice the provided actor id is not valid\n    error InvalidActorID(CommonTypes.FilActorId actorId);\n\n    /// @notice an error happened trying to call the actor\n    error FailToCallActor();\n\n    /// @notice the response received is not correct. In some case no response is expected and we received one, or a response was indeed expected and we received none.\n    error InvalidResponseLength();\n\n    /// @notice the codec received is not valid\n    error InvalidCodec(uint64);\n\n    /// @notice the called actor returned an error as part of its expected behaviour\n    error ActorError(int256 errorCode);\n\n    /// @notice the actor is not found\n    error ActorNotFound();\n\n    /// @notice allows to interact with an specific actor by its address (bytes format)\n    /// @param actor_address actor address (bytes format) to interact with\n    /// @param method_num id of the method from the actor to call\n    /// @param codec how the request data passed as argument is encoded\n    /// @param raw_request encoded arguments to be passed in the call\n    /// @param value tokens to be transferred to the called actor\n    /// @param static_call indicates if the call will be allowed to change the actor state or not (just read the state)\n    /// @return payload (in bytes) with the actual response data (without codec or response code)\n    function callByAddress(\n        bytes memory actor_address,\n        uint256 method_num,\n        uint64 codec,\n        bytes memory raw_request,\n        uint256 value,\n        bool static_call\n    ) internal returns (bytes memory) {\n        if (actor_address.length < 2) {\n            revert InvalidAddress(actor_address);\n        }\n\n        validatePrecompileCall(CALL_ACTOR_ADDRESS, value);\n\n        // We have to delegate-call the call-actor precompile because the call-actor precompile will\n        // call the target actor on our behalf. This will _not_ delegate to the target `actor_address`.\n        //\n        // Specifically:\n        //\n        // - `static_call == false`: `CALLER (you) --(DELEGATECALL)-> CALL_ACTOR_PRECOMPILE --(CALL)-> actor_address\n        // - `static_call == true`:  `CALLER (you) --(DELEGATECALL)-> CALL_ACTOR_PRECOMPILE --(STATICCALL)-> actor_address\n        (bool success, bytes memory data) = address(CALL_ACTOR_ADDRESS).delegatecall(\n            abi.encode(uint64(method_num), value, static_call ? READ_ONLY_FLAG : DEFAULT_FLAG, codec, raw_request, actor_address)\n        );\n        if (!success) {\n            revert FailToCallActor();\n        }\n\n        return readRespData(data);\n    }\n\n    /// @notice allows to interact with an specific actor by its id (uint64)\n    /// @param target actor id (uint64) to interact with\n    /// @param method_num id of the method from the actor to call\n    /// @param codec how the request data passed as argument is encoded\n    /// @param raw_request encoded arguments to be passed in the call\n    /// @param value tokens to be transferred to the called actor\n    /// @param static_call indicates if the call will be allowed to change the actor state or not (just read the state)\n    /// @return payload (in bytes) with the actual response data (without codec or response code)\n    function callByID(\n        CommonTypes.FilActorId target,\n        uint256 method_num,\n        uint64 codec,\n        bytes memory raw_request,\n        uint256 value,\n        bool static_call\n    ) internal returns (bytes memory) {\n        validatePrecompileCall(CALL_ACTOR_ID, value);\n\n        (bool success, bytes memory data) = address(CALL_ACTOR_ID).delegatecall(\n            abi.encode(uint64(method_num), value, static_call ? READ_ONLY_FLAG : DEFAULT_FLAG, codec, raw_request, target)\n        );\n        if (!success) {\n            revert FailToCallActor();\n        }\n\n        return readRespData(data);\n    }\n\n    /// @notice allows to run some generic validations before calling the precompile actor\n    /// @param addr precompile actor address to run check to\n    /// @param value tokens to be transferred to the called actor\n    function validatePrecompileCall(address addr, uint256 value) internal view {\n        uint balance = address(this).balance;\n        if (balance < value) {\n            revert NotEnoughBalance(balance, value);\n        }\n\n        bool actorExists = Misc.addressExists(addr);\n        if (!actorExists) {\n            revert ActorNotFound();\n        }\n    }\n\n    /// @notice allows to interact with an non-singleton actors by its id (uint64)\n    /// @param target actor id (uint64) to interact with\n    /// @param method_num id of the method from the actor to call\n    /// @param codec how the request data passed as argument is encoded\n    /// @param raw_request encoded arguments to be passed in the call\n    /// @param value tokens to be transfered to the called actor\n    /// @param static_call indicates if the call will be allowed to change the actor state or not (just read the state)\n    /// @dev it requires the id to be bigger than 99, as singleton actors are smaller than that\n    function callNonSingletonByID(\n        CommonTypes.FilActorId target,\n        uint256 method_num,\n        uint64 codec,\n        bytes memory raw_request,\n        uint256 value,\n        bool static_call\n    ) internal returns (bytes memory) {\n        if (CommonTypes.FilActorId.unwrap(target) < 100) {\n            revert InvalidActorID(target);\n        }\n\n        return callByID(target, method_num, codec, raw_request, value, static_call);\n    }\n\n    /// @notice parse the response an actor returned\n    /// @notice it will validate the return code (success) and the codec (valid one)\n    /// @param raw_response raw data (bytes) the actor returned\n    /// @return the actual raw data (payload, in bytes) to be parsed according to the actor and method called\n    function readRespData(bytes memory raw_response) internal pure returns (bytes memory) {\n        (int256 exit, uint64 return_codec, bytes memory return_value) = abi.decode(raw_response, (int256, uint64, bytes));\n\n        if (return_codec == Misc.NONE_CODEC) {\n            if (return_value.length != 0) {\n                revert InvalidResponseLength();\n            }\n        } else if (return_codec == Misc.CBOR_CODEC || return_codec == Misc.DAG_CBOR_CODEC) {\n            if (return_value.length == 0) {\n                revert InvalidResponseLength();\n            }\n        } else {\n            revert InvalidCodec(return_codec);\n        }\n\n        if (exit != 0) {\n            revert ActorError(exit);\n        }\n\n        return return_value;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/CborDecode.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\n// \tMajUnsignedInt = 0\n// \tMajSignedInt   = 1\n// \tMajByteString  = 2\n// \tMajTextString  = 3\n// \tMajArray       = 4\n// \tMajMap         = 5\n// \tMajTag         = 6\n// \tMajOther       = 7\n\nuint8 constant MajUnsignedInt = 0;\nuint8 constant MajSignedInt = 1;\nuint8 constant MajByteString = 2;\nuint8 constant MajTextString = 3;\nuint8 constant MajArray = 4;\nuint8 constant MajMap = 5;\nuint8 constant MajTag = 6;\nuint8 constant MajOther = 7;\n\nuint8 constant TagTypeBigNum = 2;\nuint8 constant TagTypeNegativeBigNum = 3;\n\nuint8 constant True_Type = 21;\nuint8 constant False_Type = 20;\n\n/// @notice This library is a set a functions that allows anyone to decode cbor encoded bytes\n/// @dev methods in this library try to read the data type indicated from cbor encoded data stored in bytes at a specific index\n/// @dev if it successes, methods will return the read value and the new index (intial index plus read bytes)\n/// @author Zondax AG\nlibrary CBORDecoder {\n    /// @notice check if next value on the cbor encoded data is null\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    function isNullNext(bytes memory cborData, uint byteIdx) internal pure returns (bool) {\n        return cborData[byteIdx] == hex\"f6\";\n    }\n\n    /// @notice attempt to read a bool value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return a bool decoded from input bytes and the byte index after moving past the value\n    function readBool(bytes memory cborData, uint byteIdx) internal pure returns (bool, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajOther, \"invalid maj (expected MajOther)\");\n        assert(value == True_Type || value == False_Type);\n\n        return (value != False_Type, byteIdx);\n    }\n\n    /// @notice attempt to read the length of a fixed array\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return length of the fixed array decoded from input bytes and the byte index after moving past the value\n    function readFixedArray(bytes memory cborData, uint byteIdx) internal pure returns (uint, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajArray, \"invalid maj (expected MajArray)\");\n\n        return (len, byteIdx);\n    }\n\n    /// @notice attempt to read an arbitrary length string value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return arbitrary length string decoded from input bytes and the byte index after moving past the value\n    function readString(bytes memory cborData, uint byteIdx) internal pure returns (string memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajTextString, \"invalid maj (expected MajTextString)\");\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborData[i];\n            slice_index++;\n        }\n\n        return (string(slice), byteIdx + len);\n    }\n\n    /// @notice attempt to read an arbitrary byte string value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return arbitrary byte string decoded from input bytes and the byte index after moving past the value\n    function readBytes(bytes memory cborData, uint byteIdx) internal pure returns (bytes memory, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajTag || maj == MajByteString, \"invalid maj (expected MajTag or MajByteString)\");\n\n        if (maj == MajTag) {\n            (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n            assert(maj == MajByteString);\n        }\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(len);\n        uint slice_index = 0;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborData[i];\n            slice_index++;\n        }\n\n        return (slice, byteIdx + len);\n    }\n\n    /// @notice attempt to read a bytes32 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return a bytes32 decoded from input bytes and the byte index after moving past the value\n    function readBytes32(bytes memory cborData, uint byteIdx) internal pure returns (bytes32, uint) {\n        uint8 maj;\n        uint len;\n\n        (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajByteString, \"invalid maj (expected MajByteString)\");\n\n        uint max_len = byteIdx + len;\n        bytes memory slice = new bytes(32);\n        uint slice_index = 32 - len;\n        for (uint256 i = byteIdx; i < max_len; i++) {\n            slice[slice_index] = cborData[i];\n            slice_index++;\n        }\n\n        return (bytes32(slice), byteIdx + len);\n    }\n\n    /// @notice attempt to read a uint256 value encoded per cbor specification\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an uint256 decoded from input bytes and the byte index after moving past the value\n    function readUInt256(bytes memory cborData, uint byteIdx) internal pure returns (uint256, uint) {\n        uint8 maj;\n        uint256 value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajTag || maj == MajUnsignedInt, \"invalid maj (expected MajTag or MajUnsignedInt)\");\n\n        if (maj == MajTag) {\n            require(value == TagTypeBigNum, \"invalid tag (expected TagTypeBigNum)\");\n\n            uint len;\n            (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n            require(maj == MajByteString, \"invalid maj (expected MajByteString)\");\n\n            require(cborData.length >= byteIdx + len, \"slicing out of range\");\n            assembly {\n                value := mload(add(cborData, add(len, byteIdx)))\n            }\n\n            return (value, byteIdx + len);\n        }\n\n        return (value, byteIdx);\n    }\n\n    /// @notice attempt to read a int256 value encoded per cbor specification\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an int256 decoded from input bytes and the byte index after moving past the value\n    function readInt256(bytes memory cborData, uint byteIdx) internal pure returns (int256, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajTag || maj == MajSignedInt, \"invalid maj (expected MajTag or MajSignedInt)\");\n\n        if (maj == MajTag) {\n            assert(value == TagTypeNegativeBigNum);\n\n            uint len;\n            (maj, len, byteIdx) = parseCborHeader(cborData, byteIdx);\n            require(maj == MajByteString, \"invalid maj (expected MajByteString)\");\n\n            require(cborData.length >= byteIdx + len, \"slicing out of range\");\n            assembly {\n                value := mload(add(cborData, add(len, byteIdx)))\n            }\n\n            return (int256(value), byteIdx + len);\n        }\n\n        return (int256(value), byteIdx);\n    }\n\n    /// @notice attempt to read a uint64 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an uint64 decoded from input bytes and the byte index after moving past the value\n    function readUInt64(bytes memory cborData, uint byteIdx) internal pure returns (uint64, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajUnsignedInt, \"invalid maj (expected MajUnsignedInt)\");\n\n        return (uint64(value), byteIdx);\n    }\n\n    /// @notice attempt to read a uint32 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an uint32 decoded from input bytes and the byte index after moving past the value\n    function readUInt32(bytes memory cborData, uint byteIdx) internal pure returns (uint32, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajUnsignedInt, \"invalid maj (expected MajUnsignedInt)\");\n\n        return (uint32(value), byteIdx);\n    }\n\n    /// @notice attempt to read a uint16 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an uint16 decoded from input bytes and the byte index after moving past the value\n    function readUInt16(bytes memory cborData, uint byteIdx) internal pure returns (uint16, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajUnsignedInt, \"invalid maj (expected MajUnsignedInt)\");\n\n        return (uint16(value), byteIdx);\n    }\n\n    /// @notice attempt to read a uint8 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an uint8 decoded from input bytes and the byte index after moving past the value\n    function readUInt8(bytes memory cborData, uint byteIdx) internal pure returns (uint8, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajUnsignedInt, \"invalid maj (expected MajUnsignedInt)\");\n\n        return (uint8(value), byteIdx);\n    }\n\n    /// @notice attempt to read a int64 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an int64 decoded from input bytes and the byte index after moving past the value\n    function readInt64(bytes memory cborData, uint byteIdx) internal pure returns (int64, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \"invalid maj (expected MajSignedInt or MajUnsignedInt)\");\n\n        return (int64(uint64(value)), byteIdx);\n    }\n\n    /// @notice attempt to read a int32 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an int32 decoded from input bytes and the byte index after moving past the value\n    function readInt32(bytes memory cborData, uint byteIdx) internal pure returns (int32, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \"invalid maj (expected MajSignedInt or MajUnsignedInt)\");\n\n        return (int32(uint32(value)), byteIdx);\n    }\n\n    /// @notice attempt to read a int16 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an int16 decoded from input bytes and the byte index after moving past the value\n    function readInt16(bytes memory cborData, uint byteIdx) internal pure returns (int16, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \"invalid maj (expected MajSignedInt or MajUnsignedInt)\");\n\n        return (int16(uint16(value)), byteIdx);\n    }\n\n    /// @notice attempt to read a int8 value\n    /// @param cborData cbor encoded bytes to parse from\n    /// @param byteIdx current position to read on the cbor encoded bytes\n    /// @return an int8 decoded from input bytes and the byte index after moving past the value\n    function readInt8(bytes memory cborData, uint byteIdx) internal pure returns (int8, uint) {\n        uint8 maj;\n        uint value;\n\n        (maj, value, byteIdx) = parseCborHeader(cborData, byteIdx);\n        require(maj == MajSignedInt || maj == MajUnsignedInt, \"invalid maj (expected MajSignedInt or MajUnsignedInt)\");\n\n        return (int8(uint8(value)), byteIdx);\n    }\n\n    /// @notice slice uint8 from bytes starting at a given index\n    /// @param bs bytes to slice from\n    /// @param start current position to slice from bytes\n    /// @return uint8 sliced from bytes\n    function sliceUInt8(bytes memory bs, uint start) internal pure returns (uint8) {\n        require(bs.length >= start + 1, \"slicing out of range\");\n        return uint8(bs[start]);\n    }\n\n    /// @notice slice uint16 from bytes starting at a given index\n    /// @param bs bytes to slice from\n    /// @param start current position to slice from bytes\n    /// @return uint16 sliced from bytes\n    function sliceUInt16(bytes memory bs, uint start) internal pure returns (uint16) {\n        require(bs.length >= start + 2, \"slicing out of range\");\n        bytes2 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n        return uint16(x);\n    }\n\n    /// @notice slice uint32 from bytes starting at a given index\n    /// @param bs bytes to slice from\n    /// @param start current position to slice from bytes\n    /// @return uint32 sliced from bytes\n    function sliceUInt32(bytes memory bs, uint start) internal pure returns (uint32) {\n        require(bs.length >= start + 4, \"slicing out of range\");\n        bytes4 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n        return uint32(x);\n    }\n\n    /// @notice slice uint64 from bytes starting at a given index\n    /// @param bs bytes to slice from\n    /// @param start current position to slice from bytes\n    /// @return uint64 sliced from bytes\n    function sliceUInt64(bytes memory bs, uint start) internal pure returns (uint64) {\n        require(bs.length >= start + 8, \"slicing out of range\");\n        bytes8 x;\n        assembly {\n            x := mload(add(bs, add(0x20, start)))\n        }\n        return uint64(x);\n    }\n\n    /// @notice Parse cbor header for major type and extra info.\n    /// @param cbor cbor encoded bytes to parse from\n    /// @param byteIndex current position to read on the cbor encoded bytes\n    /// @return major type, extra info and the byte index after moving past header bytes\n    function parseCborHeader(bytes memory cbor, uint byteIndex) internal pure returns (uint8, uint64, uint) {\n        uint8 first = sliceUInt8(cbor, byteIndex);\n        byteIndex += 1;\n        uint8 maj = (first & 0xe0) >> 5;\n        uint8 low = first & 0x1f;\n        // We don't handle CBOR headers with extra > 27, i.e. no indefinite lengths\n        require(low < 28, \"cannot handle headers with extra > 27\");\n\n        // extra is lower bits\n        if (low < 24) {\n            return (maj, low, byteIndex);\n        }\n\n        // extra in next byte\n        if (low == 24) {\n            uint8 next = sliceUInt8(cbor, byteIndex);\n            byteIndex += 1;\n            require(next >= 24, \"invalid cbor\"); // otherwise this is invalid cbor\n            return (maj, next, byteIndex);\n        }\n\n        // extra in next 2 bytes\n        if (low == 25) {\n            uint16 extra16 = sliceUInt16(cbor, byteIndex);\n            byteIndex += 2;\n            return (maj, extra16, byteIndex);\n        }\n\n        // extra in next 4 bytes\n        if (low == 26) {\n            uint32 extra32 = sliceUInt32(cbor, byteIndex);\n            byteIndex += 4;\n            return (maj, extra32, byteIndex);\n        }\n\n        // extra in next 8 bytes\n        assert(low == 27);\n        uint64 extra64 = sliceUInt64(cbor, byteIndex);\n        byteIndex += 8;\n        return (maj, extra64, byteIndex);\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/FilAddresses.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/CommonTypes.sol\";\nimport \"../utils/Leb128.sol\";\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This library is a set a functions that allows to handle filecoin addresses conversions and validations\n/// @author Zondax AG\nlibrary FilAddresses {\n    using Buffer for Buffer.buffer;\n\n    error InvalidAddress();\n\n    /// @notice allow to get a FilAddress from an eth address\n    /// @param addr eth address to convert\n    /// @return new filecoin address\n    function fromEthAddress(address addr) internal pure returns (CommonTypes.FilAddress memory) {\n        return CommonTypes.FilAddress(abi.encodePacked(hex\"040a\", addr));\n    }\n\n    /// @notice allow to create a Filecoin address from an actorID\n    /// @param actorID uint64 actorID\n    /// @return address filecoin address\n    function fromActorID(uint64 actorID) internal pure returns (CommonTypes.FilAddress memory) {\n        Buffer.buffer memory result = Leb128.encodeUnsignedLeb128FromUInt64(actorID);\n        return CommonTypes.FilAddress(abi.encodePacked(hex\"00\", result.buf));\n    }\n\n    /// @notice allow to create a Filecoin address from bytes\n    /// @param data address in bytes format\n    /// @return filecoin address\n    function fromBytes(bytes memory data) internal pure returns (CommonTypes.FilAddress memory) {\n        CommonTypes.FilAddress memory newAddr = CommonTypes.FilAddress(data);\n        if (!validate(newAddr)) {\n            revert InvalidAddress();\n        }\n\n        return newAddr;\n    }\n\n    /// @notice allow to validate if an address is valid or not\n    /// @dev we are only validating known address types. If the type is not known, the default value is true\n    /// @param addr the filecoin address to validate\n    /// @return whether the address is valid or not\n    function validate(CommonTypes.FilAddress memory addr) internal pure returns (bool) {\n        if (addr.data[0] == 0x00) {\n            return addr.data.length <= 10;\n        } else if (addr.data[0] == 0x01 || addr.data[0] == 0x02) {\n            return addr.data.length == 21;\n        } else if (addr.data[0] == 0x03) {\n            return addr.data.length == 49;\n        } else if (addr.data[0] == 0x04) {\n            return addr.data.length <= 64;\n        }\n\n        return addr.data.length <= 256;\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/Leb128.sol": {
      "content": "/*******************************************************************************\n *   (c) 2023 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/// @notice This library implement the leb128\n/// @author Zondax AG\nlibrary Leb128 {\n    using Buffer for Buffer.buffer;\n\n    /// @notice encode a unsigned integer 64bits into bytes\n    /// @param value the actor ID to encode\n    /// @return result return the value in bytes\n    function encodeUnsignedLeb128FromUInt64(uint64 value) internal pure returns (Buffer.buffer memory result) {\n        while (true) {\n            uint64 byte_ = value & 0x7f;\n            value >>= 7;\n            if (value == 0) {\n                result.appendUint8(uint8(byte_));\n                return result;\n            }\n            result.appendUint8(uint8(byte_ | 0x80));\n        }\n    }\n}\n"
    },
    "@zondax/filecoin-solidity/contracts/v0.8/utils/Misc.sol": {
      "content": "/*******************************************************************************\n *   (c) 2022 Zondax AG\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// THIS CODE WAS SECURITY REVIEWED BY KUDELSKI SECURITY, BUT NOT FORMALLY AUDITED\n\n// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.17;\n\nimport \"../types/CommonTypes.sol\";\n\n/// @title Library containing miscellaneous functions used on the project\n/// @author Zondax AG\nlibrary Misc {\n    uint64 constant DAG_CBOR_CODEC = 0x71;\n    uint64 constant CBOR_CODEC = 0x51;\n    uint64 constant NONE_CODEC = 0x00;\n\n    // Code taken from Openzeppelin repo\n    // Link: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/0320a718e8e07b1d932f5acb8ad9cec9d9eed99b/contracts/utils/math/SignedMath.sol#L37-L42\n    /// @notice get the abs from a signed number\n    /// @param n number to get abs from\n    /// @return unsigned number\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n\n    /// @notice validate if an address exists or not\n    /// @dev read this article for more information https://blog.finxter.com/how-to-find-out-if-an-ethereum-address-is-a-contract/\n    /// @param addr address to check\n    /// @return whether the address exists or not\n    function addressExists(address addr) internal view returns (bool) {\n        bytes32 codehash;\n        assembly {\n            codehash := extcodehash(addr)\n        }\n        return codehash != 0x0;\n    }\n\n    /// Returns the data size required by CBOR.writeFixedNumeric\n    function getPrefixSize(uint256 data_size) internal pure returns (uint256) {\n        if (data_size <= 23) {\n            return 1;\n        } else if (data_size <= 0xFF) {\n            return 2;\n        } else if (data_size <= 0xFFFF) {\n            return 3;\n        } else if (data_size <= 0xFFFFFFFF) {\n            return 5;\n        }\n        return 9;\n    }\n\n    function getBytesSize(bytes memory value) internal pure returns (uint256) {\n        return getPrefixSize(value.length) + value.length;\n    }\n\n    function getCidSize(bytes memory value) internal pure returns (uint256) {\n        return getPrefixSize(2) + value.length;\n    }\n\n    function getFilActorIdSize(CommonTypes.FilActorId value) internal pure returns (uint256) {\n        uint64 val = CommonTypes.FilActorId.unwrap(value);\n        return getPrefixSize(uint256(val));\n    }\n\n    function getChainEpochSize(CommonTypes.ChainEpoch value) internal pure returns (uint256) {\n        int64 val = CommonTypes.ChainEpoch.unwrap(value);\n        if (val >= 0) {\n            return getPrefixSize(uint256(uint64(val)));\n        } else {\n            return getPrefixSize(uint256(uint64(-1 - val)));\n        }\n    }\n\n    function getBoolSize() internal pure returns (uint256) {\n        return getPrefixSize(1);\n    }\n}\n"
    },
    "contracts/ipc/constants/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\naddress constant BURNT_FUNDS_ACTOR = address(99);\nbytes32 constant EMPTY_HASH = bytes32(\"\");\nbytes constant EMPTY_BYTES = bytes(\"\");\nbytes4 constant METHOD_SEND = bytes4(0);\n\n// The length of the public key that is associated with a validator.\nuint256 constant VALIDATOR_SECP256K1_PUBLIC_KEY_LENGTH = 65;\n"
    },
    "contracts/ipc/enums/ConsensusType.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\n/// @title Subnet Consensus Type enum\n/// @author LimeChain team\nenum ConsensusType {\n    Fendermint\n}\n"
    },
    "contracts/ipc/enums/IPCMsgType.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\n/// @title IPC Message type enum\n/// @author LimeChain team\nenum IPCMsgType {\n    TopDown,\n    BottomUp\n}\n"
    },
    "contracts/ipc/errors/IPCErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nerror AddressShouldBeValidator();\nerror AlreadyRegisteredSubnet();\nerror AlreadyInSet();\nerror CannotConfirmFutureChanges();\nerror CannotReleaseZero();\nerror CannotSendCrossMsgToItself();\nerror CheckpointAlreadyExists();\nerror BatchAlreadyExists();\nerror MaxMsgsPerBatchExceeded();\nerror QuorumAlreadyProcessed();\nerror CheckpointNotCreated();\nerror BottomUpCheckpointAlreadySubmitted();\nerror BatchNotCreated();\nerror CollateralIsZero();\nerror EmptyAddress();\nerror FailedAddIncompleteQuorum();\nerror FailedAddSignatory();\nerror FailedRemoveIncompleteQuorum();\nerror GatewayCannotBeZero();\nerror InvalidActorAddress();\nerror InvalidCheckpointEpoch();\nerror CannotSubmitFutureCheckpoint();\nerror InvalidBatchEpoch();\nerror InvalidCheckpointSource();\nerror InvalidBatchSource();\nerror InvalidSubnetActor();\nerror InvalidCollateral();\nerror InvalidConfigurationNumber();\nerror InvalidXnetMessage(InvalidXnetMessageReason reason);\nerror InvalidMajorityPercentage();\nerror InvalidPowerScale();\nerror InvalidRetentionHeight();\nerror InvalidSignature();\nerror InvalidSignatureErr(uint8);\nerror InvalidSignatureLength();\nerror InvalidPublicKeyLength();\nerror InvalidSubmissionPeriod();\nerror InvalidSubnet();\nerror NoCollateralToWithdraw();\nerror NoValidatorsInSubnet();\nerror NotAllValidatorsHaveLeft();\nerror NotAuthorized(address);\nerror NotEmptySubnetCircSupply();\nerror NotEnoughBalance();\nerror NotEnoughBalanceForRewards();\nerror NotEnoughCollateral();\nerror NotEnoughFunds();\nerror NotEnoughFundsToRelease();\nerror NotEnoughSubnetCircSupply();\nerror NotEnoughValidatorsInSubnet();\nerror NotGateway();\nerror NotInSet();\nerror NotOwnerOfPublicKey();\nerror NotRegisteredSubnet();\nerror NotStakedBefore();\nerror NotSystemActor();\nerror NotValidator(address);\nerror OldConfigurationNumber();\nerror PQDoesNotContainAddress();\nerror PQEmpty();\nerror ParentFinalityAlreadyCommitted();\nerror PostboxNotExist();\nerror SignatureReplay();\nerror SubnetAlreadyKilled();\nerror SubnetNotActive();\nerror SubnetNotFound();\nerror WithdrawExceedingCollateral();\nerror ZeroMembershipWeight();\nerror SubnetAlreadyBootstrapped();\nerror SubnetNotBootstrapped();\nerror FacetCannotBeZero();\nerror WrongGateway();\nerror CannotFindSubnet();\nerror UnknownSubnet();\nerror MethodNotAllowed(string reason);\nerror InvalidFederationPayload();\nerror DuplicatedGenesisValidator();\nerror NotEnoughGenesisValidators();\n\nenum InvalidXnetMessageReason {\n    Sender,\n    DstSubnet,\n    Nonce,\n    Value,\n    Kind\n}\n\nstring constant ERR_PERMISSIONED_AND_BOOTSTRAPPED = \"Method not allowed if permissioned is enabled and subnet bootstrapped\";\nstring constant ERR_VALIDATOR_JOINED = \"Method not allowed if validator has already joined\";\nstring constant ERR_VALIDATOR_NOT_JOINED = \"Method not allowed if validator has not joined\";\n"
    },
    "contracts/ipc/gateway/GatewayGetterFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {BottomUpCheckpoint, BottomUpMsgBatch, IpcEnvelope, ParentFinality} from \"../structs/CrossNet.sol\";\nimport {QuorumInfo} from \"../structs/Quorum.sol\";\nimport {SubnetID, Subnet} from \"../structs/Subnet.sol\";\nimport {Membership} from \"../structs/Subnet.sol\";\nimport {LibGateway} from \"../lib/LibGateway.sol\";\nimport {LibStaking} from \"../lib/LibStaking.sol\";\nimport {LibQuorum} from \"../lib/LibQuorum.sol\";\nimport {GatewayActorStorage} from \"../lib/LibGatewayActorStorage.sol\";\nimport {SubnetIDHelper} from \"../lib/SubnetIDHelper.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\ncontract GatewayGetterFacet {\n    // slither-disable-next-line uninitialized-state\n    GatewayActorStorage internal s;\n\n    using SubnetIDHelper for SubnetID;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// @notice Returns the next and start configuration numbers in the validator changes.\n    /// The configuration numbers are from changes made in the parent.\n    function getValidatorConfigurationNumbers()\n        external\n        view\n        returns (uint64, uint64)\n    {\n        return LibStaking.getConfigurationNumbers();\n    }\n\n    /// @notice Returns code commit SHA where this contract is from.\n    function getCommitSha() external view returns (bytes32) {\n        return s.commitSha;\n    }\n\n    /// @notice Returns the current nonce for bottom-up message processing.\n    function bottomUpNonce() external view returns (uint64) {\n        return s.bottomUpNonce;\n    }\n\n    /// @notice Returns the total number of the registered subnets.\n    function totalSubnets() external view returns (uint64) {\n        return s.totalSubnets;\n    }\n\n    /// @notice Returns the maximum number of messages per bottom-up batch.\n    function maxMsgsPerBottomUpBatch() external view returns (uint64) {\n        return s.maxMsgsPerBottomUpBatch;\n    }\n\n    /// @notice Returns the period for bottom-up checkpointing.\n    function bottomUpCheckPeriod() external view returns (uint256) {\n        return s.bottomUpCheckPeriod;\n    }\n\n    /// @notice Returns the subnet identifier of the network.\n    function getNetworkName() external view returns (SubnetID memory) {\n        return s.networkName;\n    }\n\n    /// @notice Returns a specific bottom-up checkpoint based on an epoch number.\n    /// @param e The epoch number of the checkpoint.\n    function bottomUpCheckpoint(\n        uint256 e\n    ) external view returns (BottomUpCheckpoint memory) {\n        return s.bottomUpCheckpoints[e];\n    }\n\n    /// @notice Returns a specific bottom-up message batch based on an index.\n    /// @param e The epoch number of the batch.\n    function bottomUpMsgBatch(\n        uint256 e\n    ) external view returns (BottomUpMsgBatch memory) {\n        return s.bottomUpMsgBatches[e];\n    }\n\n    /// @notice Returns the parent chain finality information for a given block number.\n    /// @param blockNumber The block number for which to retrieve parent-finality information.\n    function getParentFinality(\n        uint256 blockNumber\n    ) external view returns (ParentFinality memory) {\n        return LibGateway.getParentFinality(blockNumber);\n    }\n\n    /// @notice Gets the most recent parent-finality information from the parent.\n    function getLatestParentFinality()\n        external\n        view\n        returns (ParentFinality memory)\n    {\n        return LibGateway.getLatestParentFinality();\n    }\n\n    /// @notice Returns the subnet with the given id.\n    /// @param subnetId the id of the subnet.\n    /// @return found whether the subnet exists.\n    /// @return subnet -  the subnet struct.\n    function getSubnet(\n        SubnetID calldata subnetId\n    ) external view returns (bool, Subnet memory) {\n        // slither-disable-next-line unused-return\n        return LibGateway.getSubnet(subnetId);\n    }\n\n    /// @notice Returns information about a specific subnet using its hash identifier.\n    /// @param h The hash identifier of the subnet to be queried.\n    /// @return subnet The subnet information corresponding to the given hash.\n    function subnets(bytes32 h) external view returns (Subnet memory subnet) {\n        return s.subnets[h];\n    }\n\n    /// @notice Returns the length of the top-down message queue for a specified subnet.\n    /// @param subnetId The identifier of the subnet for which the message queue length is queried.\n    /// @return The current length of the top-down message queue, indicated by the subnet's top-down nonce.\n    function getSubnetTopDownMsgsLength(\n        SubnetID memory subnetId\n    ) external view returns (uint256) {\n        // slither-disable-next-line unused-return\n        (, Subnet storage subnet) = LibGateway.getSubnet(subnetId);\n        // With every new message, the nonce is added by one, the current nonce should be equal to the top down message length.\n        return subnet.topDownNonce;\n    }\n\n    /// @notice Returns the current applied top-down nonce for a specified subnet, indicating whether it's registered.\n    /// @param subnetId The identifier of the subnet for which the top-down nonce is queried.\n    /// @return A tuple containing a boolean indicating if the subnet is registered and the current top-down nonce.\n    function getTopDownNonce(\n        SubnetID calldata subnetId\n    ) external view returns (bool, uint64) {\n        (bool registered, Subnet storage subnet) = LibGateway.getSubnet(\n            subnetId\n        );\n        if (!registered) {\n            return (false, 0);\n        }\n        return (true, subnet.topDownNonce);\n    }\n\n    /// @notice Returns the current applied bottom-up nonce for a specified subnet, indicating whether it's registered.\n    /// @param subnetId The identifier of the subnet for which the bottom-up nonce is queried.\n    /// @return A tuple containing a boolean indicating if the subnet is registered and the current applied bottom-up nonce.\n    function getAppliedBottomUpNonce(\n        SubnetID calldata subnetId\n    ) external view returns (bool, uint64) {\n        (bool registered, Subnet storage subnet) = LibGateway.getSubnet(\n            subnetId\n        );\n        if (!registered) {\n            return (false, 0);\n        }\n        return (true, subnet.appliedBottomUpNonce);\n    }\n\n    /// @notice Returns the current applied top-down nonce of the gateway.\n    function appliedTopDownNonce() external view returns (uint64) {\n        return s.appliedTopDownNonce;\n    }\n\n    /// @notice Returns the storable message and its wrapped status from the postbox by a given identifier.\n    /// @param id The unique identifier of the message in the postbox.\n    function postbox(\n        bytes32 id\n    ) external view returns (IpcEnvelope memory storableMsg) {\n        return (s.postbox[id]);\n    }\n\n    /// @notice Returns the majority percentage required for certain consensus or decision-making processes.\n    function majorityPercentage() external view returns (uint64) {\n        return s.majorityPercentage;\n    }\n\n    /// @notice Returns the list of registered subnets.\n    /// @return The list of the registered subnets.\n    function listSubnets() external view returns (Subnet[] memory) {\n        uint256 size = s.subnetKeys.length();\n        Subnet[] memory out = new Subnet[](size);\n        for (uint256 i; i < size; ) {\n            bytes32 key = s.subnetKeys.at(i);\n            out[i] = s.subnets[key];\n            unchecked {\n                ++i;\n            }\n        }\n        return out;\n    }\n\n    /// @notice Returns the subnet keys.\n    function getSubnetKeys() external view returns (bytes32[] memory) {\n        return s.subnetKeys.values();\n    }\n\n    /// @notice Returns the last membership received from the parent.\n    function getLastMembership() external view returns (Membership memory) {\n        return s.lastMembership;\n    }\n\n    /// @notice Returns the last configuration number received from the parent.\n    function getLastConfigurationNumber() external view returns (uint64) {\n        return s.lastMembership.configurationNumber;\n    }\n\n    /// @notice Returns the current membership.\n    function getCurrentMembership() external view returns (Membership memory) {\n        return s.currentMembership;\n    }\n\n    /// @notice Returns the current configuration number.\n    function getCurrentConfigurationNumber() external view returns (uint64) {\n        return s.currentMembership.configurationNumber;\n    }\n\n    /// @notice Returns quorum information for a specific checkpoint based on its height.\n    /// @param h The block height of the checkpoint.\n    /// @return Quorum information associated with the given checkpoint height.\n    function getCheckpointInfo(\n        uint256 h\n    ) external view returns (QuorumInfo memory) {\n        return s.checkpointQuorumMap.quorumInfo[h];\n    }\n\n    /// @notice Returns the checkpoint current weight corresponding to the block height.\n    function getCheckpointCurrentWeight(\n        uint256 h\n    ) external view returns (uint256) {\n        return s.checkpointQuorumMap.quorumInfo[h].currentWeight;\n    }\n\n    /// @notice Returns the incomplete checkpoint heights.\n    function getIncompleteCheckpointHeights()\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return s.checkpointQuorumMap.incompleteQuorums.values();\n    }\n\n    /// @notice Returns the incomplete checkpoints.\n    function getIncompleteCheckpoints()\n        external\n        view\n        returns (BottomUpCheckpoint[] memory)\n    {\n        uint256[] memory heights = s\n            .checkpointQuorumMap\n            .incompleteQuorums\n            .values();\n        uint256 size = heights.length;\n\n        BottomUpCheckpoint[] memory checkpoints = new BottomUpCheckpoint[](\n            size\n        );\n        for (uint64 i; i < size; ) {\n            checkpoints[i] = s.bottomUpCheckpoints[heights[i]];\n            unchecked {\n                ++i;\n            }\n        }\n        return checkpoints;\n    }\n\n    /// @notice Returns the bottom-up checkpoint retention index.\n    function getCheckpointRetentionHeight() external view returns (uint256) {\n        return s.checkpointQuorumMap.retentionHeight;\n    }\n\n    /// @notice Returns the threshold required for quorum in this subnet,\n    ///         based on the configured majority percentage and the total weight of the validators.\n    /// @param totalWeight The total weight to consider for calculating the quorum threshold.\n    /// @return The quorum threshold derived from the total weight and majority percentage.\n    function getQuorumThreshold(\n        uint256 totalWeight\n    ) external view returns (uint256) {\n        return LibQuorum.weightNeeded(totalWeight, s.majorityPercentage);\n    }\n\n    /// @notice Retrieves a bundle of information and signatures for a specified bottom-up checkpoint.\n    /// @param h The height of the checkpoint for which information is requested.\n    /// @return ch The checkpoint information at the specified height.\n    /// @return info Quorum information related to the checkpoint.\n    /// @return signatories An array of addresses of signatories who have signed the checkpoint.\n    function getCheckpointSignatureBundle(\n        uint256 h\n    )\n        external\n        view\n        returns (\n            BottomUpCheckpoint memory ch,\n            QuorumInfo memory info,\n            address[] memory signatories,\n            bytes[] memory signatures\n        )\n    {\n        ch = s.bottomUpCheckpoints[h];\n        (info, signatories, signatures) = LibQuorum.getSignatureBundle(\n            s.checkpointQuorumMap,\n            h\n        );\n\n        return (ch, info, signatories, signatures);\n    }\n\n    /// @notice Returns the current bottom-up checkpoint.\n    /// @return exists - whether the checkpoint exists\n    /// @return epoch - the epoch of the checkpoint\n    /// @return checkpoint - the checkpoint struct\n    function getCurrentBottomUpCheckpoint()\n        external\n        view\n        returns (\n            bool exists,\n            uint256 epoch,\n            BottomUpCheckpoint memory checkpoint\n        )\n    {\n        (exists, epoch, checkpoint) = LibGateway.getCurrentBottomUpCheckpoint();\n        return (exists, epoch, checkpoint);\n    }\n}\n"
    },
    "contracts/ipc/gateway/GatewayManagerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {GatewayActorModifiers} from \"../lib/LibGatewayActorStorage.sol\";\nimport {SubnetActorGetterFacet} from \"../subnet/SubnetActorGetterFacet.sol\";\nimport {BURNT_FUNDS_ACTOR} from \"../constants/Constants.sol\";\nimport {IpcEnvelope} from \"../structs/CrossNet.sol\";\nimport {FvmAddress} from \"../structs/FvmAddress.sol\";\nimport {SubnetID, Subnet, SupplySource} from \"../structs/Subnet.sol\";\nimport {Membership, SupplyKind} from \"../structs/Subnet.sol\";\nimport {AlreadyRegisteredSubnet, CannotReleaseZero, MethodNotAllowed, NotEnoughFunds, NotEnoughFundsToRelease, NotEnoughCollateral, NotEmptySubnetCircSupply, NotRegisteredSubnet, InvalidXnetMessage, InvalidXnetMessageReason} from \"../errors/IPCErrors.sol\";\nimport {LibGateway} from \"../lib/LibGateway.sol\";\nimport {SubnetIDHelper} from \"../lib/SubnetIDHelper.sol\";\nimport {CrossMsgHelper} from \"../lib/CrossMsgHelper.sol\";\nimport {FilAddress} from \"fevmate/contracts/utils/FilAddress.sol\";\nimport {ReentrancyGuard} from \"../lib/LibReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SupplySourceHelper} from \"../lib/SupplySourceHelper.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstring constant ERR_CHILD_SUBNET_NOT_ALLOWED = \"Subnet does not allow child subnets\";\n\ncontract GatewayManagerFacet is GatewayActorModifiers, ReentrancyGuard {\n    using FilAddress for address payable;\n    using SubnetIDHelper for SubnetID;\n    using SupplySourceHelper for SupplySource;\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    /// @notice register a subnet in the gateway. It is called by a subnet when it reaches the threshold stake\n    /// @dev The subnet can optionally pass a genesis circulating supply that would be pre-allocated in the\n    /// subnet from genesis (without having to wait for the subnet to be spawned to propagate the funds).\n    function register(uint256 genesisCircSupply) external payable {\n        // If L2+ support is not enabled, only allow the registration of new\n        // subnets in the root\n        if (s.networkName.route.length + 1 >= s.maxTreeDepth) {\n            revert MethodNotAllowed(ERR_CHILD_SUBNET_NOT_ALLOWED);\n        }\n\n        if (msg.value < genesisCircSupply) {\n            revert NotEnoughFunds();\n        }\n        uint256 collateral = msg.value - genesisCircSupply;\n        SubnetID memory subnetId = s.networkName.createSubnetId(msg.sender);\n\n        (bool registered, Subnet storage subnet) = LibGateway.getSubnet(\n            subnetId\n        );\n        if (registered) {\n            revert AlreadyRegisteredSubnet();\n        }\n\n        subnet.id = subnetId;\n        subnet.stake = collateral;\n        subnet.genesisEpoch = block.number;\n        subnet.circSupply = genesisCircSupply;\n\n        s.subnetKeys.add(subnetId.toHash());\n        s.totalSubnets += 1;\n    }\n\n    /// @notice addStake - add collateral for an existing subnet\n    function addStake() external payable {\n        if (msg.value == 0) {\n            revert NotEnoughFunds();\n        }\n\n        (bool registered, Subnet storage subnet) = LibGateway.getSubnet(\n            msg.sender\n        );\n\n        if (!registered) {\n            revert NotRegisteredSubnet();\n        }\n\n        subnet.stake += msg.value;\n    }\n\n    /// @notice release collateral for an existing subnet.\n    /// @dev it can be used to release the stake or reward of the validator.\n    /// @param amount The amount of stake to be released.\n    function releaseStake(uint256 amount) external nonReentrant {\n        if (amount == 0) {\n            revert CannotReleaseZero();\n        }\n\n        (bool registered, Subnet storage subnet) = LibGateway.getSubnet(\n            msg.sender\n        );\n\n        if (!registered) {\n            revert NotRegisteredSubnet();\n        }\n        if (subnet.stake < amount) {\n            revert NotEnoughFundsToRelease();\n        }\n\n        subnet.stake -= amount;\n\n        payable(subnet.id.getActor()).sendValue(amount);\n    }\n\n    /// @notice kill an existing subnet.\n    /// @dev The subnet's balance must be empty.\n    function kill() external {\n        (bool registered, Subnet storage subnet) = LibGateway.getSubnet(\n            msg.sender\n        );\n\n        if (!registered) {\n            revert NotRegisteredSubnet();\n        }\n        // gas-opt: original check: subnet.circSupply > 0\n        if (subnet.circSupply != 0) {\n            revert NotEmptySubnetCircSupply();\n        }\n\n        uint256 stake = subnet.stake;\n        bytes32 id = subnet.id.toHash();\n\n        s.totalSubnets -= 1;\n        delete s.subnets[id];\n\n        s.subnetKeys.remove(id);\n\n        payable(msg.sender).sendValue(stake);\n    }\n\n    /// @notice credits the received value to the specified address in the specified child subnet.\n    ///\n    /// @dev There may be an associated fee that gets distributed to validators in the subnet. Currently this fee is zero,\n    ///     i.e. funding a subnet is free.\n    ///\n    /// @param subnetId: the destination subnet for the funds.\n    /// @param to: the address to which to credit funds in the destination subnet.\n    function fund(\n        SubnetID calldata subnetId,\n        FvmAddress calldata to\n    ) external payable {\n        if (msg.value == 0) {\n            // prevent spamming if there's no value to fund.\n            revert InvalidXnetMessage(InvalidXnetMessageReason.Value);\n        }\n        // slither-disable-next-line unused-return\n        (bool registered, ) = LibGateway.getSubnet(subnetId);\n        if (!registered) {\n            revert NotRegisteredSubnet();\n        }\n\n        // Validate that the supply strategy is native.\n        SupplySource memory supplySource = SubnetActorGetterFacet(\n            subnetId.getActor()\n        ).supplySource();\n        supplySource.expect(SupplyKind.Native);\n\n        IpcEnvelope memory crossMsg = CrossMsgHelper.createFundMsg({\n            subnet: subnetId,\n            signer: msg.sender,\n            to: to,\n            value: msg.value\n        });\n\n        // commit top-down message.\n        LibGateway.commitTopDownMsg(crossMsg);\n    }\n\n    /// @notice Sends funds to a specified subnet receiver using ERC20 tokens.\n    /// @dev This function locks the amount of ERC20 tokens into custody and then mints the supply in the specified subnet.\n    ///     It checks if the subnet's supply strategy is ERC20 and if not, the operation is reverted.\n    ///     It allows for free injection of funds into a subnet and is protected against reentrancy.\n    /// @param subnetId The ID of the subnet where the funds will be sent to.\n    /// @param to The funded address.\n    /// @param amount The amount of ERC20 tokens to be sent.\n    function fundWithToken(\n        SubnetID calldata subnetId,\n        FvmAddress calldata to,\n        uint256 amount\n    ) external nonReentrant {\n        if (amount == 0) {\n            // prevent spamming if there's no value to fund.\n            revert InvalidXnetMessage(InvalidXnetMessageReason.Value);\n        }\n        // slither-disable-next-line unused-return\n        (bool registered, ) = LibGateway.getSubnet(subnetId);\n        if (!registered) {\n            revert NotRegisteredSubnet();\n        }\n\n        // Check that the supply strategy is ERC20.\n        // There is no need to check whether the subnet exists. If it doesn't exist, the call to getter will revert.\n        // LibGateway.commitTopDownMsg will also revert if the subnet doesn't exist.\n        SupplySource memory supplySource = SubnetActorGetterFacet(\n            subnetId.getActor()\n        ).supplySource();\n        supplySource.expect(SupplyKind.ERC20);\n\n        // Locks a specified amount into custody, adjusting for tokens with transfer fees. This operation\n        // accommodates inflationary tokens, potentially reflecting a higher effective locked amount.\n        // Operation reverts if the effective transferred amount is zero.\n        uint256 transferAmount = supplySource.lock({value: amount});\n\n        // Create the top-down message to mint the supply in the subnet.\n        IpcEnvelope memory crossMsg = CrossMsgHelper.createFundMsg({\n            subnet: subnetId,\n            signer: msg.sender,\n            to: to,\n            value: transferAmount\n        });\n\n        // Commit top-down message.\n        LibGateway.commitTopDownMsg(crossMsg);\n    }\n\n    /// @notice release() burns the received value locally in subnet and commits a bottom-up message to release the assets in the parent.\n    ///         The local supply of a subnet is always the native coin, so this method doesn't have to deal with tokens.\n    ///\n    /// @param to: the address to which to credit funds in the parent subnet.\n    function release(FvmAddress calldata to) external payable {\n        if (msg.value == 0) {\n            // prevent spamming if there's no value to release.\n            revert InvalidXnetMessage(InvalidXnetMessageReason.Value);\n        }\n        IpcEnvelope memory crossMsg = CrossMsgHelper.createReleaseMsg({\n            subnet: s.networkName,\n            signer: msg.sender,\n            to: to,\n            value: msg.value\n        });\n\n        LibGateway.commitBottomUpMsg(crossMsg);\n        // burn funds that are being released\n        payable(BURNT_FUNDS_ACTOR).sendValue(msg.value);\n    }\n}\n"
    },
    "contracts/ipc/gateway/GatewayMessengerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {GatewayActorModifiers} from \"../lib/LibGatewayActorStorage.sol\";\nimport {IpcEnvelope, CallMsg, IpcMsgKind} from \"../structs/CrossNet.sol\";\nimport {IPCMsgType} from \"../enums/IPCMsgType.sol\";\nimport {SubnetID, SupplyKind, IPCAddress} from \"../structs/Subnet.sol\";\nimport {InvalidXnetMessage, InvalidXnetMessageReason, CannotSendCrossMsgToItself, MethodNotAllowed} from \"../errors/IPCErrors.sol\";\nimport {SubnetIDHelper} from \"../lib/SubnetIDHelper.sol\";\nimport {LibGateway} from \"../lib/LibGateway.sol\";\nimport {FilAddress} from \"fevmate/contracts/utils/FilAddress.sol\";\nimport {SupplySourceHelper} from \"../lib/SupplySourceHelper.sol\";\nimport {CrossMsgHelper} from \"../lib/CrossMsgHelper.sol\";\nimport {FvmAddressHelper} from \"../lib/FvmAddressHelper.sol\";\n\nstring constant ERR_GENERAL_CROSS_MSG_DISABLED = \"Support for general-purpose cross-net messages is disabled\";\nstring constant ERR_MULTILEVEL_CROSS_MSG_DISABLED = \"Support for multi-level cross-net messages is disabled\";\n\ncontract GatewayMessengerFacet is GatewayActorModifiers {\n    using FilAddress for address payable;\n    using SubnetIDHelper for SubnetID;\n\n    /**\n     * @dev Sends a general-purpose cross-message from the local subnet to the destination subnet.\n     * Any value in msg.value will be forwarded in the call.\n     *\n     * IMPORTANT: Only smart contracts are allowed to trigger these cross-net messages. User wallets can send funds\n     * from their address to the destination subnet and then run the transaction in the destination normally.\n     *\n     * @param envelope - the original envelope, which will be validated, stamped and committed during the send.\n     * @return committed envelope.\n     */\n    function sendContractXnetMessage(\n        IpcEnvelope calldata envelope\n    ) external payable returns (IpcEnvelope memory committed) {\n        if (!s.generalPurposeCrossMsg) {\n            revert MethodNotAllowed(ERR_GENERAL_CROSS_MSG_DISABLED);\n        }\n\n        // We prevent the sender from being an EoA.\n        if (!(msg.sender.code.length > 0)) {\n            revert InvalidXnetMessage(InvalidXnetMessageReason.Sender);\n        }\n\n        if (envelope.value != msg.value) {\n            revert InvalidXnetMessage(InvalidXnetMessageReason.Value);\n        }\n\n        if (envelope.kind != IpcMsgKind.Call) {\n            revert InvalidXnetMessage(InvalidXnetMessageReason.Kind);\n        }\n\n        // Will revert if the message won't deserialize into a CallMsg.\n        abi.decode(envelope.message, (CallMsg));\n\n        committed = IpcEnvelope({\n            kind: IpcMsgKind.Call,\n            from: IPCAddress({\n                subnetId: s.networkName,\n                rawAddress: FvmAddressHelper.from(msg.sender)\n            }),\n            to: envelope.to,\n            value: msg.value,\n            message: envelope.message,\n            nonce: 0 // nonce will be updated by LibGateway.commitCrossMessage\n        });\n\n        // Commit xnet message for dispatch.\n        bool shouldBurn = LibGateway.commitCrossMessage(committed);\n\n        // Apply side effects, such as burning funds.\n        LibGateway.crossMsgSideEffects({\n            v: committed.value,\n            shouldBurn: shouldBurn\n        });\n\n        // Return a copy of the envelope, which was updated when it was committed.\n        // Updates are visible to us because commitCrossMessage takes the envelope with memory scope,\n        // which passes the struct by reference.\n        return committed;\n    }\n\n    /**\n     * @dev propagates the populated cross net message for the given cid\n     * @param msgCid - the cid of the cross-net message\n     */\n    function propagate(bytes32 msgCid) external payable {\n        if (!s.multiLevelCrossMsg) {\n            revert MethodNotAllowed(ERR_MULTILEVEL_CROSS_MSG_DISABLED);\n        }\n\n        IpcEnvelope storage crossMsg = s.postbox[msgCid];\n\n        bool shouldBurn = LibGateway.commitCrossMessage(crossMsg);\n        // We must delete the message first to prevent potential re-entrancies,\n        // and as the message is deleted and we don't have a reference to the object\n        // anymore, we need to pull the data from the message to trigger the side-effects.\n        uint256 v = crossMsg.value;\n        delete s.postbox[msgCid];\n\n        LibGateway.crossMsgSideEffects({v: v, shouldBurn: shouldBurn});\n    }\n}\n"
    },
    "contracts/ipc/gateway/router/CheckpointingFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {GatewayActorModifiers} from \"../../lib/LibGatewayActorStorage.sol\";\nimport {BottomUpCheckpoint} from \"../../structs/CrossNet.sol\";\nimport {LibGateway} from \"../../lib/LibGateway.sol\";\nimport {LibQuorum} from \"../../lib/LibQuorum.sol\";\nimport {Subnet} from \"../../structs/Subnet.sol\";\nimport {QuorumObjKind} from \"../../structs/Quorum.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport {InvalidBatchSource, NotEnoughBalance, MaxMsgsPerBatchExceeded, InvalidCheckpointSource, CheckpointAlreadyExists} from \"../../errors/IPCErrors.sol\";\nimport {NotRegisteredSubnet, SubnetNotActive, SubnetNotFound, InvalidSubnet, CheckpointNotCreated} from \"../../errors/IPCErrors.sol\";\nimport {BatchNotCreated, InvalidBatchEpoch, BatchAlreadyExists, NotEnoughSubnetCircSupply, InvalidCheckpointEpoch} from \"../../errors/IPCErrors.sol\";\n\nimport {CrossMsgHelper} from \"../../lib/CrossMsgHelper.sol\";\nimport {IpcEnvelope, SubnetID} from \"../../structs/CrossNet.sol\";\nimport {SubnetIDHelper} from \"../../lib/SubnetIDHelper.sol\";\n\ncontract CheckpointingFacet is GatewayActorModifiers {\n    using SubnetIDHelper for SubnetID;\n    using CrossMsgHelper for IpcEnvelope;\n\n    /// @notice submit a verified checkpoint in the gateway to trigger side-effects.\n    /// @dev this method is called by the corresponding subnet actor.\n    ///     Called from a subnet actor if the checkpoint is cryptographically valid.\n    /// @param checkpoint The bottom-up checkpoint to be committed.\n    function commitCheckpoint(BottomUpCheckpoint calldata checkpoint) external {\n        // checkpoint is used to implement access control\n        if (checkpoint.subnetID.getActor() != msg.sender) {\n            revert InvalidCheckpointSource();\n        }\n        (bool subnetExists, Subnet storage subnet) = LibGateway.getSubnet(\n            msg.sender\n        );\n        if (!subnetExists) {\n            revert SubnetNotFound();\n        }\n        if (!checkpoint.subnetID.equals(subnet.id)) {\n            revert InvalidSubnet();\n        }\n\n        LibGateway.checkMsgLength(checkpoint.msgs);\n\n        execBottomUpMsgs(checkpoint.msgs, subnet);\n    }\n\n    /// @notice creates a new bottom-up checkpoint\n    /// @param checkpoint - a bottom-up checkpoint\n    /// @param membershipRootHash - a root hash of the Merkle tree built from the validator public keys and their weight\n    /// @param membershipWeight - the total weight of the membership\n    function createBottomUpCheckpoint(\n        BottomUpCheckpoint calldata checkpoint,\n        bytes32 membershipRootHash,\n        uint256 membershipWeight\n    ) external systemActorOnly {\n        if (LibGateway.bottomUpCheckpointExists(checkpoint.blockHeight)) {\n            revert CheckpointAlreadyExists();\n        }\n\n        LibQuorum.createQuorumInfo({\n            self: s.checkpointQuorumMap,\n            objHeight: checkpoint.blockHeight,\n            objHash: keccak256(abi.encode(checkpoint)),\n            membershipRootHash: membershipRootHash,\n            membershipWeight: membershipWeight,\n            majorityPercentage: s.majorityPercentage\n        });\n        LibGateway.storeBottomUpCheckpoint(checkpoint);\n    }\n\n    /// @notice Set a new checkpoint retention height and garbage collect all checkpoints in range [`retentionHeight`, `newRetentionHeight`)\n    /// @dev `retentionHeight` is the height of the first incomplete checkpointswe must keep to implement checkpointing.\n    /// All checkpoints with a height less than `retentionHeight` are removed from the history, assuming they are committed to the parent.\n    /// @param newRetentionHeight - the height of the oldest checkpoint to keep\n    function pruneBottomUpCheckpoints(\n        uint256 newRetentionHeight\n    ) external systemActorOnly {\n        // we need to clean manually the checkpoints because Solidity does not support passing\n        // a storage variable as an interface (so we can iterate and remove directly inside pruneQuorums)\n        for (\n            uint256 h = s.checkpointQuorumMap.retentionHeight;\n            h < newRetentionHeight;\n\n        ) {\n            delete s.bottomUpCheckpoints[h];\n            delete s.bottomUpMsgBatches[h];\n            unchecked {\n                ++h;\n            }\n        }\n\n        LibQuorum.pruneQuorums(s.checkpointQuorumMap, newRetentionHeight);\n    }\n\n    /// @notice checks whether the provided checkpoint signature for the block at height `height` is valid and accumulates that it\n    /// @dev If adding the signature leads to reaching the threshold, then the checkpoint is removed from `incompleteCheckpoints`\n    /// @param height - the height of the block in the checkpoint\n    /// @param membershipProof - a Merkle proof that the validator was in the membership at height `height` with weight `weight`\n    /// @param weight - the weight of the validator\n    /// @param signature - the signature of the checkpoint\n    function addCheckpointSignature(\n        uint256 height,\n        bytes32[] memory membershipProof,\n        uint256 weight,\n        bytes memory signature\n    ) external {\n        // check if the checkpoint was already pruned before getting checkpoint\n        // and triggering the signature\n        LibQuorum.isHeightAlreadyProcessed(s.checkpointQuorumMap, height);\n\n        // slither-disable-next-line unused-return\n        (bool exists, ) = LibGateway.getBottomUpCheckpoint(height);\n        if (!exists) {\n            revert CheckpointNotCreated();\n        }\n        LibQuorum.addQuorumSignature({\n            self: s.checkpointQuorumMap,\n            height: height,\n            membershipProof: membershipProof,\n            weight: weight,\n            signature: signature\n        });\n    }\n\n    /// @notice submit a batch of cross-net messages for execution.\n    /// @param msgs The batch of bottom-up cross-network messages to be executed.\n    function execBottomUpMsgs(\n        IpcEnvelope[] calldata msgs,\n        Subnet storage subnet\n    ) internal {\n        uint256 totalValue;\n        uint256 crossMsgLength = msgs.length;\n\n        for (uint256 i; i < crossMsgLength; ) {\n            totalValue += msgs[i].value;\n            unchecked {\n                ++i;\n            }\n        }\n\n        uint256 totalAmount = totalValue;\n\n        if (subnet.circSupply < totalAmount) {\n            revert NotEnoughSubnetCircSupply();\n        }\n\n        subnet.circSupply -= totalAmount;\n\n        // execute cross-messages\n        LibGateway.applyMessages(subnet.id, msgs);\n    }\n}\n"
    },
    "contracts/ipc/gateway/router/TopDownFinalityFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {GatewayActorModifiers} from \"../../lib/LibGatewayActorStorage.sol\";\nimport {ParentFinality} from \"../../structs/CrossNet.sol\";\nimport {PermissionMode, Validator, ValidatorInfo, StakingChangeRequest, Membership} from \"../../structs/Subnet.sol\";\nimport {LibGateway} from \"../../lib/LibGateway.sol\";\n\nimport {FilAddress} from \"fevmate/contracts/utils/FilAddress.sol\";\n\nimport {ParentValidatorsTracker, ValidatorSet} from \"../../structs/Subnet.sol\";\nimport {LibValidatorTracking, LibValidatorSet} from \"../../lib/LibStaking.sol\";\n\ncontract TopDownFinalityFacet is GatewayActorModifiers {\n    using FilAddress for address;\n    using LibValidatorTracking for ParentValidatorsTracker;\n    using LibValidatorSet for ValidatorSet;\n\n    /// @notice commit the ipc parent finality into storage and returns the previous committed finality\n    /// This is useful to understand if the finalities are consistent or if there have been reorgs.\n    /// If there are no previous committed fainality, it will be default to zero values, i.e. zero height and block hash.\n    /// @param finality - the parent finality\n    /// @return hasCommittedBefore A flag that indicates if a finality record has been committed before.\n    /// @return previousFinality The previous finality information.\n    function commitParentFinality(\n        ParentFinality calldata finality\n    )\n        external\n        systemActorOnly\n        returns (\n            bool hasCommittedBefore,\n            ParentFinality memory previousFinality\n        )\n    {\n        previousFinality = LibGateway.commitParentFinality(finality);\n        hasCommittedBefore = previousFinality.height != 0;\n    }\n\n    /// @notice Store the validator change requests from parent.\n    /// @param changeRequests - the validator changes\n    function storeValidatorChanges(\n        StakingChangeRequest[] calldata changeRequests\n    ) external systemActorOnly {\n        s.validatorsTracker.batchStoreChange(changeRequests);\n    }\n\n    /// @notice Returns the next and start configuration numbers in the tracker of changes\n    /// from the parent in the child gateway\n    function getTrackerConfigurationNumbers()\n        external\n        view\n        returns (uint64, uint64)\n    {\n        return (\n            s.validatorsTracker.changes.nextConfigurationNumber,\n            s.validatorsTracker.changes.startConfigurationNumber\n        );\n    }\n\n    /// @notice Apply all changes committed through the commitment of parent finality.\n    /// @return configurationNumber The configuration number of the changes set that has been confirmed.\n    function applyFinalityChanges() external systemActorOnly returns (uint64) {\n        // get the latest configuration number for the change set\n        uint64 configurationNumber = s\n            .validatorsTracker\n            .changes\n            .nextConfigurationNumber - 1;\n        // return immediately if there are no changes to confirm by looking at next configNumber\n        if (\n            // nextConfiguration == startConfiguration (i.e. no changes)\n            (configurationNumber + 1) ==\n            s.validatorsTracker.changes.startConfigurationNumber\n        ) {\n            // 0 flags that there are no changes\n            return 0;\n        }\n        // confirm the change\n        s.validatorsTracker.confirmChange(configurationNumber);\n\n        // Get active validators and populate the new power table.\n        address[] memory validators = s\n            .validatorsTracker\n            .validators\n            .listActiveValidators();\n        uint256 vLength = validators.length;\n        Validator[] memory vs = new Validator[](vLength);\n        for (uint256 i; i < vLength; ) {\n            address addr = validators[i];\n            ValidatorInfo storage info = s\n                .validatorsTracker\n                .validators\n                .validators[addr];\n\n            // Extract the consensus weight for validator.\n            uint256 weight = info.confirmedCollateral + info.federatedPower;\n\n            vs[i] = Validator({\n                weight: weight,\n                addr: addr,\n                metadata: info.metadata\n            });\n            unchecked {\n                ++i;\n            }\n        }\n\n        // update membership with the resulting power table.\n        LibGateway.updateMembership(\n            Membership({\n                configurationNumber: configurationNumber,\n                validators: vs\n            })\n        );\n        return configurationNumber;\n    }\n}\n"
    },
    "contracts/ipc/gateway/router/XnetMessagingFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {GatewayActorModifiers} from \"../../lib/LibGatewayActorStorage.sol\";\nimport {IpcEnvelope, SubnetID} from \"../../structs/CrossNet.sol\";\nimport {LibGateway} from \"../../lib/LibGateway.sol\";\nimport {IPCMsgType} from \"../../enums/IPCMsgType.sol\";\nimport {SubnetActorGetterFacet} from \"../../subnet/SubnetActorGetterFacet.sol\";\nimport {Subnet} from \"../../structs/Subnet.sol\";\n\nimport {FilAddress} from \"fevmate/contracts/utils/FilAddress.sol\";\nimport {SubnetIDHelper} from \"../../lib/SubnetIDHelper.sol\";\nimport {CrossMsgHelper} from \"../../lib/CrossMsgHelper.sol\";\nimport {SupplySourceHelper} from \"../../lib/SupplySourceHelper.sol\";\nimport {SupplySource} from \"../../structs/Subnet.sol\";\n\nimport {NotRegisteredSubnet} from \"../../errors/IPCErrors.sol\";\n\ncontract XnetMessagingFacet is GatewayActorModifiers {\n    using SubnetIDHelper for SubnetID;\n    using CrossMsgHelper for IpcEnvelope;\n    using SupplySourceHelper for SupplySource;\n\n    /// @notice Applies top-down cross-net messages locally. This is invoked by IPC nodes when drawing messages from\n    ///         their parent subnet for local execution. That's why the sender is restricted to the system sender,\n    ///         because this method is implicitly invoked by the node during block production.\n    /// @dev It requires the caller to be the system actor.\n    /// @param crossMsgs The array of cross-network messages to be applied.\n    function applyCrossMessages(\n        IpcEnvelope[] calldata crossMsgs\n    ) external systemActorOnly {\n        LibGateway.applyMessages(s.networkName.getParentSubnet(), crossMsgs);\n    }\n}\n"
    },
    "contracts/ipc/GatewayDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {GatewayActorStorage} from \"./lib/LibGatewayActorStorage.sol\";\nimport {IDiamond} from \"./interfaces/IDiamond.sol\";\nimport {IDiamondCut} from \"./interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"./interfaces/IDiamondLoupe.sol\";\nimport {IERC165} from \"./interfaces/IERC165.sol\";\nimport {Validator, Membership} from \"./structs/Subnet.sol\";\nimport {InvalidCollateral, InvalidSubmissionPeriod, InvalidMajorityPercentage} from \"./errors/IPCErrors.sol\";\nimport {LibDiamond} from \"./lib/LibDiamond.sol\";\nimport {LibGateway} from \"./lib/LibGateway.sol\";\nimport {SubnetID} from \"./structs/Subnet.sol\";\nimport {LibStaking} from \"./lib/LibStaking.sol\";\nimport {BATCH_PERIOD, MAX_MSGS_PER_BATCH} from \"./structs/CrossNet.sol\";\n\nerror FunctionNotFound(bytes4 _functionSelector);\n\nbool constant FEATURE_MULTILEVEL_CROSSMSG = false;\nbool constant FEATURE_GENERAL_PUPRPOSE_CROSSMSG = true;\nuint8 constant FEATURE_SUBNET_DEPTH = 2;\n\ncontract GatewayDiamond {\n    GatewayActorStorage internal s;\n\n    struct ConstructorParams {\n        uint256 bottomUpCheckPeriod;\n        uint16 activeValidatorsLimit;\n        uint8 majorityPercentage;\n        SubnetID networkName;\n        Validator[] genesisValidators;\n        bytes32 commitSha;\n    }\n\n    constructor(IDiamond.FacetCut[] memory _diamondCut, ConstructorParams memory params) {\n        // The bottomUpCheckPeriod should be non-zero for now.\n        if (params.bottomUpCheckPeriod == 0) {\n            revert InvalidSubmissionPeriod();\n        }\n\n        if (params.majorityPercentage < 51 || params.majorityPercentage > 100) {\n            revert InvalidMajorityPercentage();\n        }\n\n        LibDiamond.setContractOwner(msg.sender);\n        LibDiamond.diamondCut({_diamondCut: _diamondCut, _init: address(0), _calldata: new bytes(0)});\n\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        // adding ERC165 data\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n\n        // Feature flags\n        s.maxTreeDepth = FEATURE_SUBNET_DEPTH;\n        s.generalPurposeCrossMsg = FEATURE_GENERAL_PUPRPOSE_CROSSMSG;\n        s.multiLevelCrossMsg = FEATURE_MULTILEVEL_CROSSMSG;\n\n        s.networkName = params.networkName;\n        s.bottomUpCheckPeriod = params.bottomUpCheckPeriod;\n        s.majorityPercentage = params.majorityPercentage;\n        s.checkpointQuorumMap.retentionHeight = 1;\n        s.commitSha = params.commitSha;\n\n        // BottomUpMsgBatch config parameters.\n        // NOTE: Let's fix them for now, but we could make them configurable\n        // through the gateway constructor in the future.\n        s.maxMsgsPerBottomUpBatch = MAX_MSGS_PER_BATCH;\n\n        s.validatorsTracker.validators.activeLimit = params.activeValidatorsLimit;\n        // Start the next configuration number from 1, 0 is reserved for no change and the genesis membership\n        s.validatorsTracker.changes.nextConfigurationNumber = LibStaking.INITIAL_CONFIGURATION_NUMBER;\n        // The startConfiguration number is also 1 to match with nextConfigurationNumber, indicating we have\n        // empty validator change logs\n        s.validatorsTracker.changes.startConfigurationNumber = LibStaking.INITIAL_CONFIGURATION_NUMBER;\n        // set initial validators and update membership\n        Membership memory initial = Membership({configurationNumber: 0, validators: params.genesisValidators});\n        LibGateway.updateMembership(initial);\n    }\n\n    function _fallback() internal {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        // slither-disable-next-line assembly\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds.facetAddressAndSelectorPosition[msg.sig].facetAddress;\n        if (facet == address(0)) {\n            revert FunctionNotFound(msg.sig);\n        }\n        // Execute external function from facet using delegatecall and return any value.\n        // slither-disable-next-line assembly\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /// @notice Will run when no functions matches call data\n    fallback() external payable {\n        _fallback();\n    }\n\n    /// @notice Same as fallback but called when calldata is empty\n    receive() external payable {\n        _fallback();\n    }\n}\n"
    },
    "contracts/ipc/interfaces/IDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\ninterface IDiamond {\n    // Add=0, Replace=1, Remove=2\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n    // The DiamondCut event records all function changes to a diamond.\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/ipc/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {IDiamond} from \"./IDiamond.sol\";\n\ninterface IDiamondCut is IDiamond {\n    /**\n     * @notice Add/replace/remove any number of functions and optionally execute a function with delegatecall\n     * @param _diamondCut Contains the facet addresses and function selectors\n     * @param _init The address of the contract or facet to execute _calldata\n     * @param _calldata A function call, including function selector and arguments _calldata is executed with delegatecall on `_init`\n     */\n    function diamondCut(IDiamond.FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n}\n"
    },
    "contracts/ipc/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/ipc/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/ipc/interfaces/IGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {BottomUpCheckpoint, BottomUpMsgBatch, IpcEnvelope, ParentFinality} from \"../structs/CrossNet.sol\";\nimport {SubnetID} from \"../structs/Subnet.sol\";\nimport {FvmAddress} from \"../structs/FvmAddress.sol\";\n\n/// @title Gateway interface\n/// @author LimeChain team\ninterface IGateway {\n    /// @notice Register is called by subnet actors to put the required collateral\n    /// and register the subnet to the hierarchy.\n    function register(uint256 genesisCircSupply) external payable;\n\n    /// @notice AddStake adds stake to the collateral of a subnet.\n    function addStake() external payable;\n\n    /// @notice Release stake recovers some collateral of the subnet\n    function releaseStake(uint256 amount) external;\n\n    /// @notice Kill propagates the kill signal from a subnet actor to unregister it from th\n    /// hierarchy.\n    function kill() external;\n\n    /// @notice commitCheckpoint propagates the commitment of a checkpoint from a child\n    function commitCheckpoint(BottomUpCheckpoint calldata bottomUpCheckpoint) external;\n\n    /// @notice fund locks the received funds —denominated in the native coin— and moves the value down the hierarchy,\n    /// crediting the funds to the specified address in the destination network.\n    ///\n    /// This functions ends up minting supply in the subnet equal to the value of the transaction. It does so by\n    /// committing the relevant top-down message, updating the top-down nonce along the way.\n    ///\n    /// Calling this method on a subnet whose supply source is not 'native' will revert with UnexpectedSupplySource().\n    function fund(SubnetID calldata subnetId, FvmAddress calldata to) external payable;\n\n    /// @notice fundWithToken locks the specified amount of tokens in the ERC20 contract linked to the subnet, and\n    /// moves the value down the hierarchy, crediting the funds as native coins to the specified address\n    /// in the destination network.\n    ///\n    /// This method expects the caller to have approved the gateway to spend `amount` tokens on their behalf\n    /// (usually done through IERC20#approve). Tokens are locked by calling IERC20#transferFrom(caller, address(this), amount).\n    /// A failure in transferring tokens to the gateway will revert the call.\n    ///\n    /// It's possible to call this method from an EOA or a contract. Regardless, it's recommended to approve strictly\n    /// the amount that will subsequently be deposited into the subnet. Keeping outstanding approvals is not recommended.\n    ///\n    /// Calling this method on a subnet whose supply source is not 'ERC20' will revert with UnexpectedSupplySource().\n    function fundWithToken(SubnetID calldata subnetId, FvmAddress calldata to, uint256 amount) external;\n\n    /// @notice Release creates a new check message to release funds in parent chain\n    ///\n    /// This function burns the funds that will be released in the current subnet\n    /// and propagates a new checkpoint message to the parent chain to signal\n    /// the amount of funds that can be released for a specific address.\n    function release(FvmAddress calldata to) external payable;\n\n    /// @notice sendContractXnetMessage sends an arbitrary cross-message to other subnet in the hierarchy.\n    // TODO: add the right comment and function name here.\n    function sendContractXnetMessage(\n        IpcEnvelope calldata envelope\n    ) external payable returns (IpcEnvelope memory committed);\n\n    /// @notice Propagates the stored postbox item for the given cid\n    function propagate(bytes32 msgCid) external payable;\n\n    /// @notice commit the ipc parent finality into storage\n    function commitParentFinality(ParentFinality calldata finality) external;\n\n    /// @notice creates a new bottom-up checkpoint\n    function createBottomUpCheckpoint(\n        BottomUpCheckpoint calldata checkpoint,\n        bytes32 membershipRootHash,\n        uint256 membershipWeight\n    ) external;\n}\n"
    },
    "contracts/ipc/lib/AccountHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {FilAddress} from \"fevmate/contracts/utils/FilAddress.sol\";\n\n/// @title Helper library for checking account type\n/// @author LimeChain team\nlibrary AccountHelper {\n    function isSystemActor(address _address) external pure returns (bool) {\n        return _address == FilAddress.SYSTEM_ACTOR;\n    }\n}\n"
    },
    "contracts/ipc/lib/CrossMsgHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {METHOD_SEND, EMPTY_BYTES} from \"../constants/Constants.sol\";\nimport {IpcEnvelope, ResultMsg, CallMsg, IpcMsgKind, OutcomeType} from \"../structs/CrossNet.sol\";\nimport {IPCMsgType} from \"../enums/IPCMsgType.sol\";\nimport {SubnetID, IPCAddress} from \"../structs/Subnet.sol\";\nimport {SubnetIDHelper} from \"../lib/SubnetIDHelper.sol\";\nimport {FvmAddressHelper} from \"../lib/FvmAddressHelper.sol\";\nimport {FvmAddress} from \"../structs/FvmAddress.sol\";\nimport {FilAddress} from \"fevmate/contracts/utils/FilAddress.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {SupplySource} from \"../structs/Subnet.sol\";\nimport {SupplySourceHelper} from \"./SupplySourceHelper.sol\";\nimport {IIpcHandler} from \"../sdk/interfaces/IIpcHandler.sol\";\n\n/// @title Helper library for manipulating IpcEnvelope-related structs\nlibrary CrossMsgHelper {\n    using SubnetIDHelper for SubnetID;\n    using FilAddress for address;\n    using FvmAddressHelper for FvmAddress;\n    using SupplySourceHelper for SupplySource;\n\n    error CannotExecuteEmptyEnvelope();\n\n    function createTransferMsg(\n        IPCAddress memory from,\n        IPCAddress memory to,\n        uint256 value\n    ) public pure returns (IpcEnvelope memory) {\n        return\n            IpcEnvelope({\n                kind: IpcMsgKind.Transfer,\n                from: from,\n                to: to,\n                value: value,\n                message: EMPTY_BYTES,\n                nonce: 0\n            });\n    }\n\n    function createCallMsg(\n        IPCAddress memory from,\n        IPCAddress memory to,\n        uint256 value,\n        bytes4 method,\n        bytes memory params\n    ) public pure returns (IpcEnvelope memory) {\n        CallMsg memory message = CallMsg({\n            method: abi.encodePacked(method),\n            params: params\n        });\n        return\n            IpcEnvelope({\n                kind: IpcMsgKind.Call,\n                from: from,\n                to: to,\n                value: value,\n                message: abi.encode(message),\n                nonce: 0\n            });\n    }\n\n    /// @notice Creates a receipt message for the given envelope.\n    /// It reverts the from and to to return to the original sender\n    /// and identifies the receipt through the hash of the original message.\n    function createResultMsg(\n        IpcEnvelope calldata crossMsg,\n        OutcomeType outcome,\n        bytes memory ret\n    ) public pure returns (IpcEnvelope memory) {\n        ResultMsg memory message = ResultMsg({\n            id: toHash(crossMsg),\n            outcome: outcome,\n            ret: ret\n        });\n        uint256 value = crossMsg.value;\n        if (outcome == OutcomeType.Ok) {\n            // if the message was executed successfully, the value stayed\n            // in the subnet and there's no need to return it.\n            value = 0;\n        }\n        return\n            IpcEnvelope({\n                kind: IpcMsgKind.Result,\n                from: crossMsg.to,\n                to: crossMsg.from,\n                value: value,\n                message: abi.encode(message),\n                nonce: 0\n            });\n    }\n\n    function createReleaseMsg(\n        SubnetID calldata subnet,\n        address signer,\n        FvmAddress calldata to,\n        uint256 value\n    ) public pure returns (IpcEnvelope memory) {\n        return\n            createTransferMsg(\n                IPCAddress({\n                    subnetId: subnet,\n                    rawAddress: FvmAddressHelper.from(signer)\n                }),\n                IPCAddress({\n                    subnetId: subnet.getParentSubnet(),\n                    rawAddress: to\n                }),\n                value\n            );\n    }\n\n    function createFundMsg(\n        SubnetID calldata subnet,\n        address signer,\n        FvmAddress calldata to,\n        uint256 value\n    ) public pure returns (IpcEnvelope memory) {\n        return\n            createTransferMsg(\n                IPCAddress({\n                    subnetId: subnet.getParentSubnet(),\n                    rawAddress: FvmAddressHelper.from(signer)\n                }),\n                IPCAddress({subnetId: subnet, rawAddress: to}),\n                value\n            );\n    }\n\n    function applyType(\n        IpcEnvelope calldata message,\n        SubnetID calldata currentSubnet\n    ) public pure returns (IPCMsgType) {\n        SubnetID memory toSubnet = message.to.subnetId;\n        SubnetID memory fromSubnet = message.from.subnetId;\n        SubnetID memory currentParentSubnet = currentSubnet.commonParent(\n            toSubnet\n        );\n        SubnetID memory messageParentSubnet = fromSubnet.commonParent(toSubnet);\n\n        if (currentParentSubnet.equals(messageParentSubnet)) {\n            if (fromSubnet.route.length > messageParentSubnet.route.length) {\n                return IPCMsgType.BottomUp;\n            }\n        }\n\n        return IPCMsgType.TopDown;\n    }\n\n    function toHash(\n        IpcEnvelope memory crossMsg\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encode(crossMsg));\n    }\n\n    function toHash(\n        IpcEnvelope[] memory crossMsgs\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encode(crossMsgs));\n    }\n\n    function isEmpty(IpcEnvelope memory crossMsg) internal pure returns (bool) {\n        // envelopes need to necessarily include a message inside except\n        // if it is a plain `Transfer`.\n        if (crossMsg.kind == IpcMsgKind.Transfer) {\n            return crossMsg.value == 0;\n        }\n        return crossMsg.message.length == 0;\n    }\n\n    /// @notice Executes a cross message envelope.\n    ///\n    /// This function doesn't revert except if the envelope is empty.\n    /// It returns a success flag and the return data for the success or\n    /// the error so it can be returned to the sender through a cross-message receipt.\n    /// NOTE: Execute assumes that the fund it is handling have already been\n    /// released for their use so they can be conveniently included in the\n    /// forwarded message, or the receipt in the case of failure.\n    function execute(\n        IpcEnvelope calldata crossMsg,\n        SupplySource memory supplySource\n    ) public returns (bool success, bytes memory ret) {\n        if (isEmpty(crossMsg)) {\n            revert CannotExecuteEmptyEnvelope();\n        }\n\n        address recipient = crossMsg\n            .to\n            .rawAddress\n            .extractEvmAddress()\n            .normalize();\n        if (crossMsg.kind == IpcMsgKind.Transfer) {\n            return\n                supplySource.transferFunds({\n                    recipient: payable(recipient),\n                    value: crossMsg.value\n                });\n        } else if (\n            crossMsg.kind == IpcMsgKind.Call ||\n            crossMsg.kind == IpcMsgKind.Result\n        ) {\n            // send the envelope directly to the entrypoint\n            // use supplySource so the tokens in the message are handled successfully\n            // and by the right supply source\n            return\n                supplySource.performCall(\n                    payable(recipient),\n                    abi.encodeCall(IIpcHandler.handleIpcMessage, (crossMsg)),\n                    crossMsg.value\n                );\n        }\n        return (false, EMPTY_BYTES);\n    }\n\n    // checks whether the cross messages are sorted in ascending order or not\n    function isSorted(\n        IpcEnvelope[] calldata crossMsgs\n    ) external pure returns (bool) {\n        uint256 prevNonce;\n        uint256 length = crossMsgs.length;\n        for (uint256 i; i < length; ) {\n            uint256 nonce = crossMsgs[i].nonce;\n\n            if (prevNonce >= nonce) {\n                // gas-opt: original check: i > 0\n                if (i != 0) {\n                    return false;\n                }\n            }\n\n            prevNonce = nonce;\n            unchecked {\n                ++i;\n            }\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/ipc/lib/FvmAddressHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {FvmAddress, DelegatedAddress} from \"../structs/FvmAddress.sol\";\n\n/// @title Helper library for Fil Address\nlibrary FvmAddressHelper {\n    /// f1: SECP256K1 key address, 20 byte hash of PublicKey.\n    uint8 public constant SECP256K1 = 1;\n    uint8 public constant PAYLOAD_HASH_LEN = 20;\n\n    /// For delegated FIL address\n    uint8 public constant DELEGATED = 4;\n    uint64 public constant EAM_ACTOR = 10;\n\n    error NotDelegatedEvmAddress();\n\n    /// @notice Creates a FvmAddress from address type\n    function from(address addr) internal pure returns (FvmAddress memory fvmAddress) {\n        bytes memory payload = abi.encode(\n            DelegatedAddress({namespace: EAM_ACTOR, length: 20, buffer: abi.encodePacked(addr)})\n        );\n\n        fvmAddress = FvmAddress({addrType: DELEGATED, payload: payload});\n    }\n\n    /// @notice Obtains the hash of the fvm address\n    function toHash(FvmAddress memory fvmAddress) internal pure returns (bytes32) {\n        return keccak256(abi.encode(fvmAddress));\n    }\n\n    /// @notice Checks if two fvm addresses are equal\n    function equal(FvmAddress memory a, FvmAddress memory b) internal pure returns (bool) {\n        return\n            a.addrType == b.addrType &&\n            a.payload.length == b.payload.length &&\n            keccak256(a.payload) == keccak256(b.payload);\n    }\n\n    function extractEvmAddress(FvmAddress memory fvmAddress) internal pure returns (address addr) {\n        if (fvmAddress.addrType != DELEGATED) {\n            revert NotDelegatedEvmAddress();\n        }\n\n        DelegatedAddress memory delegated = abi.decode(fvmAddress.payload, (DelegatedAddress));\n\n        if (delegated.namespace != EAM_ACTOR) {\n            revert NotDelegatedEvmAddress();\n        }\n        if (delegated.length != 20) {\n            revert NotDelegatedEvmAddress();\n        }\n        if (delegated.buffer.length != 20) {\n            revert NotDelegatedEvmAddress();\n        }\n\n        addr = _bytesToAddress(delegated.buffer);\n    }\n\n    function _bytesToAddress(bytes memory bys) private pure returns (address addr) {\n        // solhint-disable-next-line\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n}\n"
    },
    "contracts/ipc/lib/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport {IDiamond} from \"../interfaces/IDiamond.sol\";\n\nlibrary LibDiamond {\n    bytes32 public constant DIAMOND_STORAGE_POSITION = keccak256(\"libdiamond.lib.diamond.storage\");\n\n    error InvalidAddress();\n    error NotOwner();\n    error NoBytecodeAtAddress(address _contractAddress, string _message);\n    error IncorrectFacetCutAction(IDiamondCut.FacetCutAction _action);\n    error NoSelectorsProvidedForFacetForCut(address _facetAddress);\n    error CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\n    error CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\n    error InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n    error NoSelectorsGivenToAdd();\n    error NotContractOwner(address _user, address _contractOwner);\n    error CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\n    error CannotReplaceImmutableFunction(bytes4 _selector);\n    error CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\n    error CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\n    error RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\n    error CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\n    error CannotRemoveImmutableFunction(bytes4 _selector);\n\n    event OwnershipTransferred(address oldOwner, address newOwner);\n\n    struct FacetAddressAndSelectorPosition {\n        address facetAddress;\n        uint16 selectorPosition;\n    }\n\n    struct DiamondStorage {\n        // function selector => facet address and selector position in selectors array\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\n        bytes4[] selectors;\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) internal onlyOwner {\n        if (newOwner == address(0)) {\n            revert InvalidAddress();\n        }\n        setContractOwner(newOwner);\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n\n        address oldOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(oldOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != diamondStorage().contractOwner) {\n            revert NotOwner();\n        }\n        _;\n    }\n\n    function enforceIsContractOwner() internal view {\n        if (msg.sender != diamondStorage().contractOwner) {\n            revert NotOwner();\n        }\n    }\n\n    function diamondCut(IDiamond.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        uint256 length = _diamondCut.length;\n        for (uint256 facetIndex; facetIndex < length; ) {\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\n            if (functionSelectors.length == 0) {\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\n            }\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamond.FacetCutAction.Add) {\n                addFunctions(facetAddress, functionSelectors);\n            } else if (action == IDiamond.FacetCutAction.Replace) {\n                replaceFunctions(facetAddress, functionSelectors);\n            } else if (action == IDiamond.FacetCutAction.Remove) {\n                removeFunctions(facetAddress, functionSelectors);\n            } else {\n                revert IncorrectFacetCutAction(action);\n            }\n            unchecked {\n                ++facetIndex;\n            }\n        }\n        emit IDiamond.DiamondCut({_diamondCut: _diamondCut, _init: _init, _calldata: _calldata});\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        if (_facetAddress == address(0)) {\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\n        }\n        DiamondStorage storage ds = diamondStorage();\n        uint16 selectorCount = uint16(ds.selectors.length);\n        enforceHasContractCode(_facetAddress, \"diamondCut: Add facet has no code\");\n        uint256 length = _functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < length; ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n            if (oldFacetAddress != address(0)) {\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\n            }\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(\n                _facetAddress,\n                selectorCount\n            );\n            ds.selectors.push(selector);\n            ++selectorCount;\n            unchecked {\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        DiamondStorage storage ds = diamondStorage();\n        if (_facetAddress == address(0)) {\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\n        }\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: Replace facet has no code\");\n        uint256 fl = _functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < fl; ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\n            // can't replace immutable functions -- functions defined directly in the diamond in this case\n            if (oldFacetAddress == address(this)) {\n                revert CannotReplaceImmutableFunction(selector);\n            }\n            if (oldFacetAddress == _facetAddress) {\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\n            }\n            if (oldFacetAddress == address(0)) {\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\n            }\n            // replace old facet address\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\n            unchecked {\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 selectorCount = ds.selectors.length;\n        if (_facetAddress != address(0)) {\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\n        }\n        uint256 fl = _functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < fl; ) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds\n                .facetAddressAndSelectorPosition[selector];\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\n            }\n\n            // can't remove immutable functions -- functions defined directly in the diamond\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\n                revert CannotRemoveImmutableFunction(selector);\n            }\n            // replace selector with last selector\n            --selectorCount;\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\n                bytes4 lastSelector = ds.selectors[selectorCount];\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\n                ds.facetAddressAndSelectorPosition[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition\n                    .selectorPosition;\n            }\n            // delete last selector\n            ds.selectors.pop();\n            delete ds.facetAddressAndSelectorPosition[selector];\n            unchecked {\n                ++selectorIndex;\n            }\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"diamondCut: _init address has no code\");\n        // slither-disable-next-line low-level-calls\n        (bool success, bytes memory error) = _init.delegatecall(_calldata); // solhint-disable-line avoid-low-level-calls\n        if (!success) {\n            // gas-opt: original check: error.length > 0\n            if (error.length != 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        if (contractSize == 0) {\n            revert NoBytecodeAtAddress(_contract, _errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/ipc/lib/LibGateway.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {IPCMsgType} from \"../enums/IPCMsgType.sol\";\nimport {GatewayActorStorage, LibGatewayActorStorage} from \"../lib/LibGatewayActorStorage.sol\";\nimport {BURNT_FUNDS_ACTOR} from \"../constants/Constants.sol\";\nimport {SubnetID, Subnet, SupplyKind, SupplySource} from \"../structs/Subnet.sol\";\nimport {SubnetActorGetterFacet} from \"../subnet/SubnetActorGetterFacet.sol\";\nimport {CallMsg, IpcMsgKind, IpcEnvelope, OutcomeType, BottomUpMsgBatch, BottomUpMsgBatch, BottomUpCheckpoint, ParentFinality} from \"../structs/CrossNet.sol\";\nimport {Membership} from \"../structs/Subnet.sol\";\nimport {CannotSendCrossMsgToItself, MethodNotAllowed, MaxMsgsPerBatchExceeded, InvalidXnetMessage, OldConfigurationNumber, NotRegisteredSubnet, InvalidActorAddress, ParentFinalityAlreadyCommitted, InvalidXnetMessageReason} from \"../errors/IPCErrors.sol\";\nimport {CrossMsgHelper} from \"../lib/CrossMsgHelper.sol\";\nimport {FilAddress} from \"fevmate/contracts/utils/FilAddress.sol\";\nimport {SubnetIDHelper} from \"../lib/SubnetIDHelper.sol\";\nimport {SupplySourceHelper} from \"../lib/SupplySourceHelper.sol\";\n\nlibrary LibGateway {\n    using SubnetIDHelper for SubnetID;\n    using CrossMsgHelper for IpcEnvelope;\n    using SupplySourceHelper for address;\n    using SubnetIDHelper for SubnetID;\n    using FilAddress for address payable;\n    using SupplySourceHelper for SupplySource;\n\n    event MembershipUpdated(Membership);\n    /// @dev subnet refers to the next \"down\" subnet that the `envelope.message.to` should be forwarded to.\n    event NewTopDownMessage(address indexed subnet, IpcEnvelope message);\n    /// @dev event emitted when there is a new bottom-up message batch to be signed.\n    event NewBottomUpMsgBatch(uint256 indexed epoch);\n\n    /// @notice returns the current bottom-up checkpoint\n    /// @return exists - whether the checkpoint exists\n    /// @return epoch - the epoch of the checkpoint\n    /// @return checkpoint - the checkpoint struct\n    function getCurrentBottomUpCheckpoint()\n        internal\n        view\n        returns (\n            bool exists,\n            uint256 epoch,\n            BottomUpCheckpoint memory checkpoint\n        )\n    {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        epoch = LibGateway.getNextEpoch(block.number, s.bottomUpCheckPeriod);\n        checkpoint = s.bottomUpCheckpoints[epoch];\n        exists = !checkpoint.subnetID.isEmpty();\n    }\n\n    /// @notice returns the bottom-up checkpoint\n    function getBottomUpCheckpoint(\n        uint256 epoch\n    )\n        internal\n        view\n        returns (bool exists, BottomUpCheckpoint storage checkpoint)\n    {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n\n        checkpoint = s.bottomUpCheckpoints[epoch];\n        exists = checkpoint.blockHeight != 0;\n    }\n\n    /// @notice returns the bottom-up batch\n    function getBottomUpMsgBatch(\n        uint256 epoch\n    ) internal view returns (bool exists, BottomUpMsgBatch storage batch) {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n\n        batch = s.bottomUpMsgBatches[epoch];\n        exists = batch.blockHeight != 0;\n    }\n\n    /// @notice checks if the bottom-up checkpoint already exists at the target epoch\n    function bottomUpCheckpointExists(\n        uint256 epoch\n    ) internal view returns (bool) {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        return s.bottomUpCheckpoints[epoch].blockHeight != 0;\n    }\n\n    /// @notice checks if the bottom-up checkpoint already exists at the target epoch\n    function bottomUpBatchMsgsExists(\n        uint256 epoch\n    ) internal view returns (bool) {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        return s.bottomUpMsgBatches[epoch].blockHeight != 0;\n    }\n\n    /// @notice stores checkpoint\n    function storeBottomUpCheckpoint(\n        BottomUpCheckpoint memory checkpoint\n    ) internal {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n\n        BottomUpCheckpoint storage b = s.bottomUpCheckpoints[\n            checkpoint.blockHeight\n        ];\n        b.blockHash = checkpoint.blockHash;\n        b.subnetID = checkpoint.subnetID;\n        b.nextConfigurationNumber = checkpoint.nextConfigurationNumber;\n        b.blockHeight = checkpoint.blockHeight;\n\n        uint256 msgLength = checkpoint.msgs.length;\n        for (uint256 i; i < msgLength; ) {\n            // We need to push because initializing an array with a static\n            // length will cause a copy from memory to storage, making\n            // the compiler unhappy.\n            b.msgs.push(checkpoint.msgs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice stores bottom-up batch\n    function storeBottomUpMsgBatch(BottomUpMsgBatch memory batch) internal {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        BottomUpMsgBatch storage b = s.bottomUpMsgBatches[batch.blockHeight];\n        b.subnetID = batch.subnetID;\n        b.blockHeight = batch.blockHeight;\n\n        uint256 msgLength = batch.msgs.length;\n        for (uint256 i; i < msgLength; ) {\n            // We need to push because initializing an array with a static\n            // length will cause a copy from memory to storage, making\n            // the compiler unhappy.\n            b.msgs.push(batch.msgs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice obtain the ipc parent finality at certain block number\n    /// @param blockNumber - the block number to obtain the finality\n    function getParentFinality(\n        uint256 blockNumber\n    ) internal view returns (ParentFinality memory) {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        return s.finalitiesMap[blockNumber];\n    }\n\n    /// @notice obtain the latest committed ipc parent finality\n    function getLatestParentFinality()\n        internal\n        view\n        returns (ParentFinality memory)\n    {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        return getParentFinality(s.latestParentHeight);\n    }\n\n    /// @notice commit the ipc parent finality into storage\n    /// @param finality - the finality to be committed\n    function commitParentFinality(\n        ParentFinality calldata finality\n    ) internal returns (ParentFinality memory lastFinality) {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n\n        uint256 lastHeight = s.latestParentHeight;\n        if (lastHeight >= finality.height) {\n            revert ParentFinalityAlreadyCommitted();\n        }\n        lastFinality = s.finalitiesMap[lastHeight];\n\n        s.finalitiesMap[finality.height] = finality;\n        s.latestParentHeight = finality.height;\n    }\n\n    /// @notice set the next membership\n    /// @param membership - new membership\n    function updateMembership(Membership memory membership) internal {\n        emit MembershipUpdated(membership);\n\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n\n        // perform checks after the genesis membership\n        if (s.currentMembership.configurationNumber != 0) {\n            if (\n                membership.configurationNumber ==\n                s.lastMembership.configurationNumber\n            ) {\n                return;\n            }\n            // We reject messages with configuration numbers from the past and revert the call.\n            if (\n                membership.configurationNumber <\n                s.lastMembership.configurationNumber\n            ) {\n                revert OldConfigurationNumber();\n            }\n\n            // Check if the membership is equal and return if it is the case\n            if (membershipEqual(membership, s.currentMembership)) {\n                return;\n            }\n        }\n\n        s.lastMembership = s.currentMembership;\n\n        uint256 inputLength = membership.validators.length;\n        uint256 storeLength = s.currentMembership.validators.length;\n        // memory arrays can't be copied directly from memory into storage,\n        // we need to explicitly increase the size of the array in storage.\n        for (uint256 i; i < inputLength; ) {\n            if (i < storeLength) {\n                s.currentMembership.validators[i] = membership.validators[i];\n            } else {\n                s.currentMembership.validators.push(membership.validators[i]);\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        s.currentMembership.configurationNumber = membership\n            .configurationNumber;\n        // finally we need to remove any outstanding membership from\n        // storage.\n        if (storeLength > inputLength) {\n            for (uint256 i = inputLength; i < storeLength; ) {\n                s.currentMembership.validators.pop();\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /// @dev - Computes total weight for a specific membership\n    function membershipTotalWeight(\n        Membership memory self\n    ) internal pure returns (uint256) {\n        uint256 len = self.validators.length;\n        uint256 totalValidatorsWeight;\n        for (uint256 i; i < len; ) {\n            totalValidatorsWeight += self.validators[i].weight;\n            unchecked {\n                ++i;\n            }\n        }\n        return totalValidatorsWeight;\n    }\n\n    /// @dev compares two memberships and returns true if they are equal\n    function membershipEqual(\n        Membership memory mb1,\n        Membership memory mb2\n    ) internal pure returns (bool) {\n        if (mb1.configurationNumber != mb2.configurationNumber) {\n            return false;\n        }\n        if (membershipTotalWeight(mb1) != membershipTotalWeight(mb2)) {\n            return false;\n        }\n        if (mb1.validators.length != mb2.validators.length) {\n            return false;\n        }\n        bytes32 h1 = keccak256(abi.encode(mb1.validators));\n        bytes32 h2 = keccak256(abi.encode(mb2.validators));\n\n        return h1 == h2;\n    }\n\n    /// @notice commit topdown messages for their execution in the subnet. Adds the message to the subnet struct for future execution\n    /// @param crossMessage - the cross message to be committed\n    function commitTopDownMsg(IpcEnvelope memory crossMessage) internal {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        SubnetID memory subnetId = crossMessage.to.subnetId.down(s.networkName);\n\n        (bool registered, Subnet storage subnet) = getSubnet(subnetId);\n\n        if (!registered) {\n            revert NotRegisteredSubnet();\n        }\n\n        uint64 topDownNonce = subnet.topDownNonce;\n\n        crossMessage.nonce = topDownNonce;\n        subnet.topDownNonce = topDownNonce + 1;\n        subnet.circSupply += crossMessage.value;\n\n        emit NewTopDownMessage({\n            subnet: subnetId.getAddress(),\n            message: crossMessage\n        });\n    }\n\n    /// @notice Commits a new cross-net message to a message batch for execution\n    /// @param crossMessage - the cross message to be committed\n    function commitBottomUpMsg(IpcEnvelope memory crossMessage) internal {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        uint256 epoch = getNextEpoch(block.number, s.bottomUpCheckPeriod);\n\n        // assign nonce to the message.\n        crossMessage.nonce = s.bottomUpNonce;\n        s.bottomUpNonce += 1;\n\n        // populate the batch for that epoch\n        (bool exists, BottomUpMsgBatch storage batch) = LibGateway\n            .getBottomUpMsgBatch(epoch);\n        if (!exists) {\n            batch.subnetID = s.networkName;\n            batch.blockHeight = epoch;\n            // we need to use push here to initialize the array.\n            batch.msgs.push(crossMessage);\n            return;\n        }\n\n        // if the maximum size was already achieved emit already the event\n        // and re-assign the batch to the current epoch.\n        if (batch.msgs.length == s.maxMsgsPerBottomUpBatch) {\n            // copy the batch with max messages into the new cut.\n            uint256 epochCut = block.number;\n            BottomUpMsgBatch memory newBatch = BottomUpMsgBatch({\n                subnetID: s.networkName,\n                blockHeight: epochCut,\n                msgs: new IpcEnvelope[](batch.msgs.length)\n            });\n\n            uint256 msgLength = batch.msgs.length;\n            for (uint256 i; i < msgLength; ) {\n                newBatch.msgs[i] = batch.msgs[i];\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // emit event with the next batch ready to sign quorum over.\n            emit NewBottomUpMsgBatch(epochCut);\n\n            // Empty the messages of existing batch with epoch and start populating with the new message.\n            delete batch.msgs;\n            // need to push here to avoid a copy from memory to storage\n            batch.msgs.push(crossMessage);\n\n            LibGateway.storeBottomUpMsgBatch(newBatch);\n        } else {\n            // we append the new message normally, and wait for the batch period\n            // to trigger the cutting of the batch.\n            batch.msgs.push(crossMessage);\n        }\n    }\n\n    /// @notice returns the subnet created by a validator\n    /// @param actor the validator that created the subnet\n    /// @return found whether the subnet exists\n    /// @return subnet -  the subnet struct\n    function getSubnet(\n        address actor\n    ) internal view returns (bool found, Subnet storage subnet) {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        if (actor == address(0)) {\n            revert InvalidActorAddress();\n        }\n        SubnetID memory subnetId = s.networkName.createSubnetId(actor);\n\n        return getSubnet(subnetId);\n    }\n\n    /// @notice returns the subnet with the given id\n    /// @param subnetId the id of the subnet\n    /// @return found whether the subnet exists\n    /// @return subnet -  the subnet struct\n    function getSubnet(\n        SubnetID memory subnetId\n    ) internal view returns (bool found, Subnet storage subnet) {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        subnet = s.subnets[subnetId.toHash()];\n        found = !subnet.id.isEmpty();\n    }\n\n    /// @notice method that gives the epoch for a given block number and checkpoint period\n    /// @return epoch - the epoch for the given block number and checkpoint period\n    function getNextEpoch(\n        uint256 blockNumber,\n        uint256 checkPeriod\n    ) internal pure returns (uint256) {\n        return ((uint64(blockNumber) / checkPeriod) + 1) * checkPeriod;\n    }\n\n    /// @notice applies a cross-net messages coming from some other subnet.\n    /// The forwarder argument determines the previous subnet that submitted the checkpoint triggering the cross-net message execution.\n    /// @param arrivingFrom - the immediate subnet from which this message is arriving\n    /// @param crossMsgs - the cross-net messages to apply\n    function applyMessages(\n        SubnetID memory arrivingFrom,\n        IpcEnvelope[] memory crossMsgs\n    ) internal {\n        uint256 crossMsgsLength = crossMsgs.length;\n        for (uint256 i; i < crossMsgsLength; ) {\n            applyMsg(arrivingFrom, crossMsgs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice executes a cross message if its destination is the current network, otherwise adds it to the postbox to be propagated further\n    /// This function assumes that the relevant funds have been already minted or burnt\n    /// when the top-down or bottom-up messages have been queued for execution.\n    /// This function is not expected to revert. If a controlled failure happens, a new\n    /// cross-message receipt is propagated for execution to inform the sending contract.\n    /// `Call` cross-messages also trigger receipts if they are successful.\n    /// @param arrivingFrom - the immediate subnet from which this message is arriving\n    /// @param crossMsg - the cross message to be executed\n    function applyMsg(\n        SubnetID memory arrivingFrom,\n        IpcEnvelope memory crossMsg\n    ) internal {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n\n        if (crossMsg.to.subnetId.isEmpty()) {\n            sendReceipt(\n                crossMsg,\n                OutcomeType.SystemErr,\n                abi.encodeWithSelector(\n                    InvalidXnetMessage.selector,\n                    InvalidXnetMessageReason.DstSubnet\n                )\n            );\n            return;\n        }\n\n        // The first thing we do is to find out the directionality of this message and act accordingly,\n        // incrasing the applied nonces conveniently.\n        // slither-disable-next-line uninitialized-local\n        SupplySource memory supplySource;\n        IPCMsgType applyType = crossMsg.applyType(s.networkName);\n        if (applyType == IPCMsgType.BottomUp) {\n            // Load the subnet this message is coming from. Ensure that it exists and that the nonce expectation is met.\n            (bool registered, Subnet storage subnet) = LibGateway.getSubnet(\n                arrivingFrom\n            );\n            if (!registered) {\n                // this means the subnet that sent the bottom up message is not registered,\n                // we cannot send the receipt back as top down because the subnet is not registered\n                // we ignore this message for as it's not valid, and it may be someone trying to forge it.\n                return;\n            }\n            if (subnet.appliedBottomUpNonce != crossMsg.nonce) {\n                sendReceipt(\n                    crossMsg,\n                    OutcomeType.SystemErr,\n                    abi.encodeWithSelector(\n                        InvalidXnetMessage.selector,\n                        InvalidXnetMessageReason.Nonce\n                    )\n                );\n                return;\n            }\n            subnet.appliedBottomUpNonce += 1;\n\n            // The value carried in bottom-up messages needs to be treated according to the supply source\n            // configuration of the subnet.\n            supplySource = SubnetActorGetterFacet(subnet.id.getActor())\n                .supplySource();\n        } else if (applyType == IPCMsgType.TopDown) {\n            // Note: there is no need to load the subnet, as a top-down application means that _we_ are the subnet.\n            if (s.appliedTopDownNonce != crossMsg.nonce) {\n                sendReceipt(\n                    crossMsg,\n                    OutcomeType.SystemErr,\n                    abi.encodeWithSelector(\n                        InvalidXnetMessage.selector,\n                        InvalidXnetMessageReason.Nonce\n                    )\n                );\n                return;\n            }\n            s.appliedTopDownNonce += 1;\n\n            // The value carried in top-down messages locally maps to the native coin, so we pass over the\n            // native supply source.\n            supplySource = SupplySourceHelper.native();\n        }\n\n        // If the crossnet destination is NOT the current network (network where the gateway is running),\n        // we add it to the postbox for further propagation.\n        // Even if we send for propagation, the execution of every message\n        // should increase the appliedNonce to allow the execution of the next message\n        // of the batch (this is way we have this after the nonce logic).\n        if (!crossMsg.to.subnetId.equals(s.networkName)) {\n            bytes32 cid = crossMsg.toHash();\n            s.postbox[cid] = crossMsg;\n            return;\n        }\n\n        // execute the message and get the receipt.\n        (bool success, bytes memory ret) = executeCrossMsg(\n            crossMsg,\n            supplySource\n        );\n        if (success) {\n            sendReceipt(crossMsg, OutcomeType.Ok, ret);\n        } else {\n            sendReceipt(crossMsg, OutcomeType.ActorErr, ret);\n        }\n    }\n\n    /// @dev Execute the cross message using low level `call` method. This way ipc will\n    ///      catch contract revert messages as well. We need this because in `CrossMsgHelper.execute`\n    ///      there are `require` and `revert` calls, without reflexive call, the execution will\n    ///      revert and block the checkpoint submission process.\n    function executeCrossMsg(\n        IpcEnvelope memory crossMsg,\n        SupplySource memory supplySource\n    ) internal returns (bool success, bytes memory result) {\n        (success, result) = address(CrossMsgHelper).delegatecall( // solhint-disable-line avoid-low-level-calls\n            abi.encodeWithSelector(\n                CrossMsgHelper.execute.selector,\n                crossMsg,\n                supplySource\n            )\n        );\n\n        if (success) {\n            return abi.decode(result, (bool, bytes));\n        }\n\n        return (success, result);\n    }\n\n    /// @notice Sends a receipt from the execution of a cross-message.\n    /// Only `Call` messages trigger a receipt. Transfer messages should be directly\n    /// handled by the peer client to return the funds to the from address in the\n    /// failing network.\n    /// (we could optionally trigger a receipt from `Transfer`s to, but without\n    /// multi-level execution it would be adding unnecessary overhead).\n    function sendReceipt(\n        IpcEnvelope memory original,\n        OutcomeType outcomeType,\n        bytes memory ret\n    ) internal {\n        if (original.isEmpty()) {\n            // This should not happen as previous validation should prevent empty messages arriving here.\n            // If it does, we simply ignore.\n            return;\n        }\n\n        // if we get a `Receipt` do nothing, no need to send receipts.\n        // - And sending a `Receipt` to a `Receipt` could lead to amplification loops.\n        if (original.kind == IpcMsgKind.Result) {\n            return;\n        }\n\n        // commmit the receipt for propagation\n        // slither-disable-next-line unused-return\n        commitCrossMessage(original.createResultMsg(outcomeType, ret));\n    }\n\n    /**\n     * @notice Commit the cross message to storage.\n     *\n     * @dev It also validates that destination subnet ID is not empty\n     *      and not equal to the current network.\n     *      This function assumes that the funds inside `value` have been\n     *      conveniently minted or burnt already and the message is free to\n     *      use them (see execBottomUpMsgBatch for reference).\n     *  @param crossMessage The cross-network message to commit.\n     *  @return shouldBurn A Boolean that indicates if the input amount should be burned.\n     */\n    function commitCrossMessage(\n        IpcEnvelope memory crossMessage\n    ) internal returns (bool shouldBurn) {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n        SubnetID memory to = crossMessage.to.subnetId;\n        if (to.isEmpty()) {\n            revert InvalidXnetMessage(InvalidXnetMessageReason.DstSubnet);\n        }\n        // destination is the current network, you are better off with a good old message, no cross needed\n        if (to.equals(s.networkName)) {\n            revert CannotSendCrossMsgToItself();\n        }\n\n        SubnetID memory from = crossMessage.from.subnetId;\n        IPCMsgType applyType = crossMessage.applyType(s.networkName);\n\n        // Are we the LCA? (Lowest Common Ancestor)\n        bool isLCA = to.commonParent(from).equals(s.networkName);\n\n        // Even if multi-level messaging is enabled, we reject the xnet message\n        // as soon as we learn that one of the networks involved use an ERC20 supply source.\n        // This will block propagation on the first step, or the last step.\n        //\n        // TODO IPC does not implement fault handling yet, so if the message fails\n        //  to propagate, the user won't be able to reclaim funds. That's one of the\n        //  reasons xnet messages are disabled by default.\n\n        bool reject = false;\n        if (applyType == IPCMsgType.BottomUp) {\n            // We're traversing up, so if we're the first hop, we reject if the subnet was ERC20.\n            // If we're not the first hop, a child propagated this to us, they made a mistake and\n            // and we don't have enough info to evaluate.\n            reject =\n                from.getParentSubnet().equals(s.networkName) &&\n                from.getActor().hasSupplyOfKind(SupplyKind.ERC20);\n        } else if (applyType == IPCMsgType.TopDown) {\n            // We're traversing down.\n            // Check the next subnet (which can may be the destination subnet).\n            reject = to.down(s.networkName).getActor().hasSupplyOfKind(\n                SupplyKind.ERC20\n            );\n        }\n        if (reject) {\n            if (crossMessage.kind == IpcMsgKind.Transfer) {\n                revert MethodNotAllowed(\n                    \"propagation of `Transfer` messages not suppported for subnets with ERC20 supply\"\n                );\n            }\n        }\n\n        // If the directionality is top-down, or if we're inverting the direction\n        // because we're the LCA, commit a top-down message.\n        if (applyType == IPCMsgType.TopDown || isLCA) {\n            ++s.appliedTopDownNonce;\n            LibGateway.commitTopDownMsg(crossMessage);\n            return (shouldBurn = false);\n        }\n\n        // Else, commit a bottom up message.\n        LibGateway.commitBottomUpMsg(crossMessage);\n        // gas-opt: original check: value > 0\n        return (shouldBurn = crossMessage.value != 0);\n    }\n\n    /**\n     * @dev Performs transaction side-effects from the commitment of a cross-net message. Like\n     * burning funds when bottom-up messages are propagated.\n     *\n     * @param v - the value of the committed cross-net message\n     * @param shouldBurn - flag if the message should burn funds\n     */\n    function crossMsgSideEffects(uint256 v, bool shouldBurn) internal {\n        if (shouldBurn) {\n            payable(BURNT_FUNDS_ACTOR).sendValue(v);\n        }\n    }\n\n    /// @notice Checks the length of a message batch, ensuring it is in (0, maxMsgsPerBottomUpBatch).\n    /// @param msgs The batch of messages to check.\n    function checkMsgLength(IpcEnvelope[] calldata msgs) internal view {\n        GatewayActorStorage storage s = LibGatewayActorStorage.appStorage();\n\n        if (msgs.length > s.maxMsgsPerBottomUpBatch) {\n            revert MaxMsgsPerBatchExceeded();\n        }\n    }\n}\n"
    },
    "contracts/ipc/lib/LibGatewayActorStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {NotSystemActor, NotEnoughFunds} from \"../errors/IPCErrors.sol\";\nimport {QuorumMap} from \"../structs/Quorum.sol\";\nimport {BottomUpCheckpoint, BottomUpMsgBatch, IpcEnvelope, ParentFinality} from \"../structs/CrossNet.sol\";\nimport {SubnetID, Subnet, ParentValidatorsTracker} from \"../structs/Subnet.sol\";\nimport {Membership} from \"../structs/Subnet.sol\";\nimport {AccountHelper} from \"../lib/AccountHelper.sol\";\nimport {FilAddress} from \"fevmate/contracts/utils/FilAddress.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct GatewayActorStorage {\n    /// @notice The latest parent height committed.\n    uint256 latestParentHeight;\n    /// @notice bottom-up period in number of epochs for the subnet\n    uint256 bottomUpCheckPeriod;\n    /// @notice bottom-up message batch period in number of epochs for the subnet\n    uint256 bottomUpMsgBatchPeriod;\n    /// @notice nonce for bottom-up messages\n    uint64 bottomUpNonce;\n    /// @notice AppliedNonces keep track of the next nonce of the message to be applied.\n    /// This prevents potential replay attacks.\n    uint64 appliedTopDownNonce;\n    /// @notice Number of active subnets spawned from this one\n    uint64 totalSubnets;\n    /// @notice Maximum number of messages per batch\n    uint64 maxMsgsPerBottomUpBatch;\n    /// @notice majority percentage value (must be greater than or equal to 51)\n    uint8 majorityPercentage;\n    /// @notice Code commit SHA where this contract is from\n    bytes32 commitSha;\n    //\n    // == Feature flags ==\n    //\n    /// @notice Determines the maximum depth that this instance of the gateway\n    /// will enforce. Bear in mind that the deployment is decentralized,\n    /// and a subnet could choose not to change this code and not enforce\n    /// this as a maximum depth in its own subnet.\n    uint8 maxTreeDepth;\n    /// @notice Determines if general purpose cros-net messages are supported\n    bool generalPurposeCrossMsg;\n    /// @notice Determines if multi-level cross-net messages are enbaled.\n    bool multiLevelCrossMsg;\n    // == Structs ==\n    /// @notice The current membership of the child subnet\n    Membership currentMembership;\n    /// @notice The last membership received from the parent and adopted\n    Membership lastMembership;\n    /// @notice Quorum information for checkpoints\n    QuorumMap checkpointQuorumMap;\n    /// @notice path to the current network\n    SubnetID networkName;\n    /// Tracking validator changes from parent in child subnet\n    ParentValidatorsTracker validatorsTracker;\n    //\n    // == Dynamic types ==\n    //\n    /// @notice List of subnets\n    /// SubnetID => Subnet\n    mapping(bytes32 => Subnet) subnets;\n    /// @notice The parent finalities. Key is the block number, value is the finality struct.\n    mapping(uint256 => ParentFinality) finalitiesMap;\n    /// @notice Postbox keeps track of all the cross-net messages triggered by\n    /// an actor that need to be propagated further through the hierarchy.\n    /// cross-net message id => CrossMsg\n    mapping(bytes32 => IpcEnvelope) postbox;\n    /// @notice A mapping of block numbers to bottom-up checkpoints\n    // slither-disable-next-line uninitialized-state\n    mapping(uint256 => BottomUpCheckpoint) bottomUpCheckpoints;\n    /// @notice A mapping of block numbers to bottom-up cross-messages\n    // slither-disable-next-line uninitialized-state\n    mapping(uint256 => BottomUpMsgBatch) bottomUpMsgBatches;\n    /// @notice Keys of the registered subnets. Useful to iterate through them\n    EnumerableSet.Bytes32Set subnetKeys;\n}\n\nlibrary LibGatewayActorStorage {\n    function appStorage()\n        internal\n        pure\n        returns (GatewayActorStorage storage ds)\n    {\n        assembly {\n            ds.slot := 0\n        }\n        return ds;\n    }\n}\n\ncontract GatewayActorModifiers {\n    GatewayActorStorage internal s;\n\n    using FilAddress for address;\n    using FilAddress for address payable;\n    using AccountHelper for address;\n\n    function _systemActorOnly() private view {\n        if (!msg.sender.isSystemActor()) {\n            revert NotSystemActor();\n        }\n    }\n\n    modifier systemActorOnly() {\n        _systemActorOnly();\n        _;\n    }\n}\n"
    },
    "contracts/ipc/lib/LibMultisignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @title Multi-signature ECDSA verification helper.\nlibrary MultisignatureChecker {\n    uint8 private constant SIGNATURE_LENGTH = 65;\n\n    enum Error {\n        Nil,\n        InvalidArrayLength,\n        EmptySignatures,\n        InvalidSignatory,\n        InvalidSignature,\n        WeightsSumLessThanThreshold\n    }\n\n    /**\n     * @notice Checks if a weighted multi-signature is valid for a given message hash, set of signatories, set of weights, and set of signatures.\n     * @dev Signatures are validated using `ECDSA.recover`.\n     *      The multi-signature fails if the sum of the signatory weights is less than the threshold.\n     *      Signatories in `signatories` and  signatures in `signatures` must have the same order.\n     * @param signatories The addresses of the signatories.\n     * @param weights The weights of the signatories.\n     * @param threshold The number that must be reach to consider `signatures` valid.\n     * @param hash of the verified data.\n     * @param signatures Packed signatures. Each signature is in `({bytes32 r}{bytes32 s}{uint8 v})` format.\n     */\n    function isValidWeightedMultiSignature(\n        address[] memory signatories,\n        uint256[] memory weights,\n        uint256 threshold,\n        bytes32 hash,\n        bytes[] memory signatures\n    ) internal pure returns (bool, Error) {\n        bool valid = true;\n        uint256 weight;\n\n        uint256 signaturesNumber = signatures.length;\n        if (signaturesNumber == 0) {\n            return (!valid, Error.EmptySignatures);\n        }\n\n        if (\n            signaturesNumber != signatories.length ||\n            signaturesNumber != weights.length\n        ) {\n            return (!valid, Error.InvalidArrayLength);\n        }\n\n        for (uint256 i; i < signaturesNumber; ) {\n            (address recovered, ECDSA.RecoverError ecdsaErr, ) = ECDSA\n                .tryRecover({hash: hash, signature: signatures[i]});\n            if (ecdsaErr != ECDSA.RecoverError.NoError) {\n                return (!valid, Error.InvalidSignature);\n            }\n            if (recovered != signatories[i]) {\n                return (!valid, Error.InvalidSignatory);\n            }\n            weight = weight + weights[i];\n            unchecked {\n                ++i;\n            }\n        }\n        if (weight >= threshold) {\n            return (valid, Error.Nil);\n        }\n        return (!valid, Error.WeightsSumLessThanThreshold);\n    }\n}\n"
    },
    "contracts/ipc/lib/LibPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\n/// @title Pausable Library\n/// @notice Abstract contract that enables contract to pause marked operations\nabstract contract Pausable {\n    bytes32 private constant NAMESPACE = keccak256(\"pausable.lib.diamond.storage\");\n\n    struct PausableStorage {\n        bool paused;\n    }\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the unpause is triggered by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view {\n        if (_paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view {\n        if (!_paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /// @notice returns true if the contract is paused\n    function _paused() internal view returns(bool) {\n        PausableStorage storage s = pausableStorage();\n        return s.paused;\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal {\n        _requireNotPaused();\n        PausableStorage storage s = pausableStorage();\n        s.paused = true;\n        emit Paused(msg.sender);\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal  {\n        _requirePaused();\n        PausableStorage storage s = pausableStorage();\n        s.paused = false;\n        emit Unpaused(msg.sender);\n    }\n\n    /// @notice get the storage slot\n    function pausableStorage() private pure returns (PausableStorage storage ds) {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n        return ds;\n    }\n}\n"
    },
    "contracts/ipc/lib/LibQuorum.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {QuorumMap, QuorumInfo, QuorumObjKind} from \"../structs/Quorum.sol\";\nimport {InvalidRetentionHeight, QuorumAlreadyProcessed, FailedAddSignatory, InvalidSignature, SignatureReplay, NotAuthorized, FailedRemoveIncompleteQuorum, ZeroMembershipWeight, FailedAddIncompleteQuorum} from \"../errors/IPCErrors.sol\";\nimport {MerkleProof} from \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nlibrary LibQuorum {\n    using EnumerableSet for EnumerableSet.UintSet;\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    event QuorumReached(\n        QuorumObjKind objKind,\n        uint256 height,\n        bytes32 objHash,\n        uint256 quorumWeight\n    );\n    event QuorumWeightUpdated(\n        QuorumObjKind objKind,\n        uint256 height,\n        bytes32 objHash,\n        uint256 newWeight\n    );\n\n    /// @notice checks whether the provided quorum signature for the block at height `height` is valid and accumulates that it\n    /// @dev If adding the signature leads to reaching the threshold, then the info is removed from `incompleteQuorums`\n    /// @param height - the height of the block in the checkpoint\n    /// @param membershipProof - a Merkle proof that the validator was in the membership at height `height` with weight `weight`\n    /// @param weight - the weight of the validator\n    /// @param signature - the signature of the object we are agreen on\n    function addQuorumSignature(\n        QuorumMap storage self,\n        uint256 height,\n        bytes32[] memory membershipProof,\n        uint256 weight,\n        bytes memory signature\n    ) internal {\n        // get quorum info for height\n        QuorumInfo storage info = self.quorumInfo[height];\n\n        // slither-disable-next-line unused-return\n        (address recoveredSignatory, ECDSA.RecoverError err, ) = ECDSA\n            .tryRecover(info.hash, signature);\n        if (err != ECDSA.RecoverError.NoError) {\n            revert InvalidSignature();\n        }\n\n        // Check whether the validator has already sent a valid signature\n        if (self.quorumSignatureSenders[height].contains(recoveredSignatory)) {\n            revert SignatureReplay();\n        }\n\n        // The validator is allowed to send a signature if it was in the membership at the target height\n        // Constructing leaf: https://github.com/OpenZeppelin/merkle-tree#leaf-hash\n        bytes32 validatorLeaf = keccak256(\n            bytes.concat(keccak256(abi.encode(recoveredSignatory, weight)))\n        );\n        bool valid = MerkleProof.verify({\n            proof: membershipProof,\n            root: info.rootHash,\n            leaf: validatorLeaf\n        });\n        if (!valid) {\n            revert NotAuthorized(recoveredSignatory);\n        }\n\n        // All checks passed.\n        // Adding signature and emitting events.\n\n        bool ok = self.quorumSignatureSenders[height].add(recoveredSignatory);\n        if (!ok) {\n            revert FailedAddSignatory();\n        }\n        self.quorumSignatures[height][recoveredSignatory] = signature;\n        info.currentWeight += weight;\n\n        if (info.currentWeight >= info.threshold) {\n            if (!info.reached) {\n                info.reached = true;\n                // quorum is completed since the threshold has been reached\n                ok = self.incompleteQuorums.remove(height);\n                if (!ok) {\n                    revert FailedRemoveIncompleteQuorum();\n                }\n                emit QuorumReached({\n                    objKind: self.quorumObjKind,\n                    height: height,\n                    objHash: info.hash,\n                    quorumWeight: info.currentWeight\n                });\n            } else {\n                emit QuorumWeightUpdated({\n                    objKind: self.quorumObjKind,\n                    height: height,\n                    objHash: info.hash,\n                    newWeight: info.currentWeight\n                });\n            }\n        }\n    }\n\n    /// @notice creates the quorum info from a quorum object.\n    /// @param  objHeight - height of the quorum object\n    /// @param  objHash - hash of the object\n    /// @param membershipRootHash - a root hash of the Merkle tree built from the validator public keys and their weight\n    /// @param membershipWeight - the total weight of the membership\n    /// @param majorityPercentage - the majorityPercentage required to reach quorum\n    function createQuorumInfo(\n        QuorumMap storage self,\n        uint256 objHeight,\n        bytes32 objHash,\n        bytes32 membershipRootHash,\n        uint256 membershipWeight,\n        uint256 majorityPercentage\n    ) internal {\n        if (objHeight < self.retentionHeight) {\n            revert QuorumAlreadyProcessed();\n        }\n\n        if (membershipWeight == 0) {\n            revert ZeroMembershipWeight();\n        }\n\n        uint256 threshold = weightNeeded(membershipWeight, majorityPercentage);\n\n        // process the checkpoint\n        bool ok = self.incompleteQuorums.add(objHeight);\n        if (!ok) {\n            revert FailedAddIncompleteQuorum();\n        }\n\n        QuorumInfo memory info = QuorumInfo({\n            hash: objHash,\n            rootHash: membershipRootHash,\n            threshold: threshold,\n            currentWeight: 0,\n            reached: false\n        });\n\n        // persist quorum info\n        self.quorumInfo[objHeight] = info;\n    }\n\n    /// @notice Sets a new  retention height and garbage collects all checkpoints in range [`retentionHeight`, `newRetentionHeight`)\n    /// @dev `retentionHeight` is the height of the first incomplete checkpointswe must keep to implement checkpointing.\n    /// All checkpoints with a height less than `retentionHeight` are removed from the history, assuming they are committed to the parent.\n    /// @param newRetentionHeight - the height of the oldest checkpoint to keep\n    function pruneQuorums(\n        QuorumMap storage self,\n        uint256 newRetentionHeight\n    ) internal {\n        uint256 oldRetentionHeight = self.retentionHeight;\n\n        if (newRetentionHeight <= oldRetentionHeight) {\n            revert InvalidRetentionHeight();\n        }\n\n        for (uint256 h = oldRetentionHeight; h < newRetentionHeight; ) {\n            address[] memory oldValidators = self\n                .quorumSignatureSenders[h]\n                .values();\n            uint256 n = oldValidators.length;\n\n            for (uint256 i; i < n; ) {\n                delete self.quorumSignatures[h][oldValidators[i]];\n                self.quorumSignatureSenders[h].remove(oldValidators[i]);\n                unchecked {\n                    ++i;\n                }\n            }\n\n            delete self.quorumInfo[h];\n            delete self.quorumSignatureSenders[h];\n\n            unchecked {\n                ++h;\n            }\n        }\n\n        self.retentionHeight = newRetentionHeight;\n    }\n\n    function isHeightAlreadyProcessed(\n        QuorumMap storage self,\n        uint256 height\n    ) internal view {\n        if (height < self.retentionHeight) {\n            revert QuorumAlreadyProcessed();\n        }\n    }\n\n    /// @notice returns the needed weight value corresponding to the majority percentage\n    /// @dev `majorityPercentage` must be a valid number\n    function weightNeeded(\n        uint256 weight,\n        uint256 majorityPercentage\n    ) internal pure returns (uint256) {\n        return (weight * majorityPercentage) / 100;\n    }\n\n    /// @notice get quorum signature bundle consisting of the info, signatories and the corresponding signatures.\n    function getSignatureBundle(\n        QuorumMap storage self,\n        uint256 h\n    )\n        external\n        view\n        returns (\n            QuorumInfo memory info,\n            address[] memory signatories,\n            bytes[] memory signatures\n        )\n    {\n        info = self.quorumInfo[h];\n        signatories = self.quorumSignatureSenders[h].values();\n        uint256 n = signatories.length;\n\n        signatures = new bytes[](n);\n\n        for (uint256 i; i < n; ) {\n            signatures[i] = self.quorumSignatures[h][signatories[i]];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return (info, signatories, signatures);\n    }\n}\n"
    },
    "contracts/ipc/lib/LibReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\n/// @title Reentrancy Guard\n/// @notice Abstract contract to provide protection against reentrancy\nabstract contract ReentrancyGuard {\n    bytes32 private constant NAMESPACE = keccak256(\"reentrancyguard.lib.diamond.storage\");\n\n    struct ReentrancyStorage {\n        uint256 status;\n    }\n\n    error ReentrancyError();\n\n    uint256 private constant _NOT_ENTERED = 0;\n    uint256 private constant _ENTERED = 1;\n\n    modifier nonReentrant() {\n        ReentrancyStorage storage s = reentrancyStorage();\n        if (s.status == _ENTERED) revert ReentrancyError();\n        s.status = _ENTERED;\n        _;\n        s.status = _NOT_ENTERED;\n    }\n\n    /// @dev fetch local storage\n    function reentrancyStorage() private pure returns (ReentrancyStorage storage ds) {\n        bytes32 position = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            ds.slot := position\n        }\n        return ds;\n    }\n}\n"
    },
    "contracts/ipc/lib/LibStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {IGateway} from \"../interfaces/IGateway.sol\";\nimport {LibSubnetActorStorage, SubnetActorStorage} from \"./LibSubnetActorStorage.sol\";\nimport {LibMaxPQ, MaxPQ} from \"./priority/LibMaxPQ.sol\";\nimport {LibMinPQ, MinPQ} from \"./priority/LibMinPQ.sol\";\nimport {LibStakingChangeLog} from \"./LibStakingChangeLog.sol\";\nimport {PermissionMode, StakingReleaseQueue, StakingChangeLog, StakingChange, StakingChangeRequest, StakingOperation, StakingRelease, ValidatorSet, AddressStakingReleases, ParentValidatorsTracker, Validator} from \"../structs/Subnet.sol\";\nimport {WithdrawExceedingCollateral, NotValidator, CannotConfirmFutureChanges, NoCollateralToWithdraw, AddressShouldBeValidator, InvalidConfigurationNumber} from \"../errors/IPCErrors.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\nlibrary LibAddressStakingReleases {\n    /// @notice Add new release to the storage. Caller makes sure the release.releasedAt is ordered\n    /// @notice in ascending order. This method does not do checks on this.\n    function push(\n        AddressStakingReleases storage self,\n        StakingRelease memory release\n    ) internal {\n        uint16 length = self.length;\n        uint16 nextIdx = self.startIdx + length;\n\n        self.releases[nextIdx] = release;\n        self.length = length + 1;\n    }\n\n    /// @notice Perform compaction on releases, i.e. aggregates the amount that can be released\n    /// @notice and removes them from storage. Returns the total amount to release and the new\n    /// @notice number of pending releases after compaction.\n    function compact(\n        AddressStakingReleases storage self\n    ) internal returns (uint256, uint16) {\n        uint16 length = self.length;\n        if (self.length == 0) {\n            revert NoCollateralToWithdraw();\n        }\n\n        uint16 i = self.startIdx;\n        uint16 newLength = length;\n        uint256 amount;\n        while (i < length) {\n            StakingRelease memory release = self.releases[i];\n\n            // releases are ordered ascending by releaseAt, no need to check\n            // further as they will still be locked.\n            if (release.releaseAt > block.number) {\n                break;\n            }\n\n            amount += release.amount;\n            delete self.releases[i];\n\n            unchecked {\n                ++i;\n                --newLength;\n            }\n        }\n\n        self.startIdx = i;\n        self.length = newLength;\n\n        return (amount, newLength);\n    }\n}\n\n/// The util library for `StakingReleaseQueue`\nlibrary LibStakingReleaseQueue {\n    using Address for address payable;\n    using LibAddressStakingReleases for AddressStakingReleases;\n\n    event NewCollateralRelease(\n        address validator,\n        uint256 amount,\n        uint256 releaseBlock\n    );\n\n    function setLockDuration(\n        StakingReleaseQueue storage self,\n        uint256 blocks\n    ) internal {\n        self.lockingDuration = blocks;\n    }\n\n    /// @notice Set the amount and time for release collateral\n    function addNewRelease(\n        StakingReleaseQueue storage self,\n        address validator,\n        uint256 amount\n    ) internal {\n        uint256 releaseAt = block.number + self.lockingDuration;\n        StakingRelease memory release = StakingRelease({\n            releaseAt: releaseAt,\n            amount: amount\n        });\n\n        self.releases[validator].push(release);\n\n        emit NewCollateralRelease({\n            validator: validator,\n            amount: amount,\n            releaseBlock: releaseAt\n        });\n    }\n\n    /// @notice Validator claim the available collateral that are released\n    function claim(\n        StakingReleaseQueue storage self,\n        address validator\n    ) internal returns (uint256) {\n        (uint256 amount, uint16 newLength) = self.releases[validator].compact();\n\n        if (newLength == 0) {\n            delete self.releases[validator];\n        }\n\n        payable(validator).sendValue(amount);\n\n        return amount;\n    }\n}\n\n/// The util library for `ValidatorSet`\nlibrary LibValidatorSet {\n    using LibMinPQ for MinPQ;\n    using LibMaxPQ for MaxPQ;\n\n    event ActiveValidatorCollateralUpdated(address validator, uint256 newPower);\n    event WaitingValidatorCollateralUpdated(\n        address validator,\n        uint256 newPower\n    );\n    event NewActiveValidator(address validator, uint256 power);\n    event NewWaitingValidator(address validator, uint256 power);\n    event ActiveValidatorReplaced(address oldValidator, address newValidator);\n    event ActiveValidatorLeft(address validator);\n    event WaitingValidatorLeft(address validator);\n\n    /// @notice Get the total voting power for the validator\n    function getPower(\n        ValidatorSet storage validators,\n        address validator\n    ) internal view returns (uint256 power) {\n        if (validators.permissionMode == PermissionMode.Federated) {\n            power = validators.validators[validator].federatedPower;\n        } else {\n            power = validators.validators[validator].confirmedCollateral;\n        }\n    }\n\n    /// @notice Get the total confirmed collateral of the validators.\n    function getTotalConfirmedCollateral(\n        ValidatorSet storage validators\n    ) internal view returns (uint256 collateral) {\n        collateral = validators.totalConfirmedCollateral;\n    }\n\n    /// @notice Get the total active validators.\n    function totalActiveValidators(\n        ValidatorSet storage validators\n    ) internal view returns (uint16 total) {\n        total = validators.activeValidators.getSize();\n    }\n\n    /// @notice Get the confirmed collateral of the validator.\n    function getConfirmedCollateral(\n        ValidatorSet storage validators,\n        address validator\n    ) internal view returns (uint256 collateral) {\n        collateral = validators.validators[validator].confirmedCollateral;\n    }\n\n    function listActiveValidators(\n        ValidatorSet storage validators\n    ) internal view returns (address[] memory addresses) {\n        uint16 size = validators.activeValidators.getSize();\n        addresses = new address[](size);\n        for (uint16 i = 1; i <= size; ) {\n            addresses[i - 1] = validators.activeValidators.getAddress(i);\n            unchecked {\n                ++i;\n            }\n        }\n        return addresses;\n    }\n\n    /// @notice Get the total collateral of *active* validators.\n    function getTotalActivePower(\n        ValidatorSet storage validators\n    ) internal view returns (uint256 collateral) {\n        uint16 size = validators.activeValidators.getSize();\n        for (uint16 i = 1; i <= size; ) {\n            address validator = validators.activeValidators.getAddress(i);\n            collateral += getPower(validators, validator);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Get the total collateral of the *waiting* and *active* validators.\n    function getTotalCollateral(\n        ValidatorSet storage validators\n    ) internal view returns (uint256 collateral) {\n        uint16 size = validators.waitingValidators.getSize();\n        for (uint16 i = 1; i <= size; ) {\n            address validator = validators.waitingValidators.getAddress(i);\n            collateral += getConfirmedCollateral(validators, validator);\n            unchecked {\n                ++i;\n            }\n        }\n        collateral += getTotalConfirmedCollateral(validators);\n    }\n\n    /// @notice Get the total power of the validators.\n    /// The function reverts if at least one validator is not in the active validator set.\n    function getTotalPowerOfValidators(\n        ValidatorSet storage validators,\n        address[] memory addresses\n    ) internal view returns (uint256[] memory) {\n        uint256 size = addresses.length;\n        uint256[] memory activePowerTable = new uint256[](size);\n\n        for (uint256 i; i < size; ) {\n            if (!isActiveValidator(validators, addresses[i])) {\n                revert NotValidator(addresses[i]);\n            }\n            activePowerTable[i] = getPower(validators, addresses[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return activePowerTable;\n    }\n\n    function isActiveValidator(\n        ValidatorSet storage self,\n        address validator\n    ) internal view returns (bool) {\n        return self.activeValidators.contains(validator);\n    }\n\n    /// @notice Set validator data\n    function setMetadata(\n        ValidatorSet storage validators,\n        address validator,\n        bytes calldata metadata\n    ) internal {\n        validators.validators[validator].metadata = metadata;\n    }\n\n    /***********************************************************************\n     * Internal helper functions, should not be called by external functions\n     ***********************************************************************/\n\n    /// @notice Validator increases its total collateral by amount.\n    function recordDeposit(\n        ValidatorSet storage validators,\n        address validator,\n        uint256 amount\n    ) internal {\n        validators.validators[validator].totalCollateral += amount;\n    }\n\n    /// @notice Validator reduces its total collateral by amount.\n    function recordWithdraw(\n        ValidatorSet storage validators,\n        address validator,\n        uint256 amount\n    ) internal {\n        uint256 total = validators.validators[validator].totalCollateral;\n        if (total < amount) {\n            revert WithdrawExceedingCollateral();\n        }\n\n        total -= amount;\n        validators.validators[validator].totalCollateral = total;\n    }\n\n    /// @notice Validator's federated power was updated by admin\n    function confirmFederatedPower(\n        ValidatorSet storage self,\n        address validator,\n        uint256 power\n    ) internal {\n        uint256 existingPower = self.validators[validator].federatedPower;\n        self.validators[validator].federatedPower = power;\n\n        if (existingPower == power) {\n            return;\n        } else if (existingPower < power) {\n            increaseReshuffle({\n                self: self,\n                maybeActive: validator,\n                newPower: power\n            });\n        } else {\n            reduceReshuffle({\n                self: self,\n                validator: validator,\n                newPower: power\n            });\n        }\n    }\n\n    function confirmDeposit(\n        ValidatorSet storage self,\n        address validator,\n        uint256 amount\n    ) internal {\n        uint256 newCollateral = self.validators[validator].confirmedCollateral +\n            amount;\n        self.validators[validator].confirmedCollateral = newCollateral;\n\n        self.totalConfirmedCollateral += amount;\n\n        increaseReshuffle({\n            self: self,\n            maybeActive: validator,\n            newPower: newCollateral\n        });\n    }\n\n    function confirmWithdraw(\n        ValidatorSet storage self,\n        address validator,\n        uint256 amount\n    ) internal {\n        uint256 newCollateral = self.validators[validator].confirmedCollateral -\n            amount;\n        uint256 totalCollateral = self.validators[validator].totalCollateral;\n\n        if (newCollateral == 0 && totalCollateral == 0) {\n            delete self.validators[validator];\n        } else {\n            self.validators[validator].confirmedCollateral = newCollateral;\n        }\n\n        reduceReshuffle({\n            self: self,\n            validator: validator,\n            newPower: newCollateral\n        });\n\n        self.totalConfirmedCollateral -= amount;\n    }\n\n    /// @notice Reshuffles the active and waiting validators when an increase in power is confirmed\n    function increaseReshuffle(\n        ValidatorSet storage self,\n        address maybeActive,\n        uint256 newPower\n    ) internal {\n        if (self.activeValidators.contains(maybeActive)) {\n            self.activeValidators.increaseReheapify(self, maybeActive);\n            emit ActiveValidatorCollateralUpdated(maybeActive, newPower);\n            return;\n        }\n\n        // incoming address is not active validator\n        uint16 activeLimit = self.activeLimit;\n        uint16 activeSize = self.activeValidators.getSize();\n        if (activeLimit > activeSize) {\n            // we can still take more active validators, just insert to the pq.\n            self.activeValidators.insert(self, maybeActive);\n            emit NewActiveValidator(maybeActive, newPower);\n            return;\n        }\n\n        // now we have enough active validators, we need to check:\n        // - if the incoming new collateral is more than the min active collateral,\n        //     - yes:\n        //        - pop the min active validator\n        //        - remove the incoming validator from waiting validators\n        //        - insert incoming validator into active validators\n        //        - insert popped validator into waiting validators\n        //     - no:\n        //        - insert the incoming validator into waiting validators\n        (address minAddress, uint256 minActivePower) = self\n            .activeValidators\n            .min(self);\n        if (minActivePower < newPower) {\n            self.activeValidators.pop(self);\n\n            if (self.waitingValidators.contains(maybeActive)) {\n                self.waitingValidators.deleteReheapify(self, maybeActive);\n            }\n\n            self.activeValidators.insert(self, maybeActive);\n            self.waitingValidators.insert(self, minAddress);\n\n            emit ActiveValidatorReplaced(minAddress, maybeActive);\n            return;\n        }\n\n        if (self.waitingValidators.contains(maybeActive)) {\n            self.waitingValidators.increaseReheapify(self, maybeActive);\n            emit WaitingValidatorCollateralUpdated(maybeActive, newPower);\n            return;\n        }\n\n        self.waitingValidators.insert(self, maybeActive);\n        emit NewWaitingValidator(maybeActive, newPower);\n    }\n\n    /// @notice Reshuffles the active and waiting validators when a power reduction is confirmed\n    function reduceReshuffle(\n        ValidatorSet storage self,\n        address validator,\n        uint256 newPower\n    ) internal {\n        if (self.waitingValidators.contains(validator)) {\n            if (newPower == 0) {\n                self.waitingValidators.deleteReheapify(self, validator);\n                emit WaitingValidatorLeft(validator);\n                return;\n            }\n            self.waitingValidators.decreaseReheapify(self, validator);\n            emit WaitingValidatorCollateralUpdated(validator, newPower);\n            return;\n        }\n\n        // sanity check\n        if (!self.activeValidators.contains(validator)) {\n            revert AddressShouldBeValidator();\n        }\n\n        // the validator is an active validator!\n\n        if (newPower == 0) {\n            self.activeValidators.deleteReheapify(self, validator);\n            emit ActiveValidatorLeft(validator);\n\n            if (self.waitingValidators.getSize() != 0) {\n                (address toBePromoted, uint256 power) = self\n                    .waitingValidators\n                    .max(self);\n                self.waitingValidators.pop(self);\n                self.activeValidators.insert(self, toBePromoted);\n                emit NewActiveValidator(toBePromoted, power);\n            }\n\n            return;\n        }\n\n        self.activeValidators.decreaseReheapify(self, validator);\n\n        if (self.waitingValidators.getSize() == 0) {\n            return;\n        }\n\n        (address mayBeDemoted, uint256 minActivePower) = self\n            .activeValidators\n            .min(self);\n        (address mayBePromoted, uint256 maxWaitingPower) = self\n            .waitingValidators\n            .max(self);\n        if (minActivePower < maxWaitingPower) {\n            self.activeValidators.pop(self);\n            self.waitingValidators.pop(self);\n            self.activeValidators.insert(self, mayBePromoted);\n            self.waitingValidators.insert(self, mayBeDemoted);\n\n            emit ActiveValidatorReplaced(mayBeDemoted, mayBePromoted);\n            return;\n        }\n\n        emit ActiveValidatorCollateralUpdated(validator, newPower);\n    }\n}\n\nlibrary LibStaking {\n    using LibStakingReleaseQueue for StakingReleaseQueue;\n    using LibStakingChangeLog for StakingChangeLog;\n    using LibValidatorSet for ValidatorSet;\n    using LibMaxPQ for MaxPQ;\n    using LibMinPQ for MinPQ;\n    using Address for address payable;\n\n    uint64 internal constant INITIAL_CONFIGURATION_NUMBER = 1;\n\n    event ConfigurationNumberConfirmed(uint64 number);\n    event CollateralClaimed(address validator, uint256 amount);\n\n    // =============== Getters =============\n    function getPower(address validator) internal view returns (uint256 power) {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        return s.validatorSet.getPower(validator);\n    }\n\n    /// @notice Checks if the validator is an active validator\n    function isActiveValidator(address validator) internal view returns (bool) {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        return s.validatorSet.activeValidators.contains(validator);\n    }\n\n    /// @notice Checks if the validator is a waiting validator\n    function isWaitingValidator(\n        address validator\n    ) internal view returns (bool) {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        return s.validatorSet.waitingValidators.contains(validator);\n    }\n\n    /// @notice Checks if the provided address is a validator (active or waiting) based on its total collateral.\n    /// @param addr The address to check for validator status.\n    /// @return A boolean indicating whether the address is a validator.\n    function isValidator(address addr) internal view returns (bool) {\n        return hasStaked(addr);\n    }\n\n    /// @notice Checks if the validator has staked before.\n    /// @param validator The address to check for staking status.\n    /// @return A boolean indicating whether the validator has staked.\n    function hasStaked(address validator) internal view returns (bool) {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n\n        // gas-opt: original check: totalCollateral > 0\n        return s.validatorSet.validators[validator].totalCollateral != 0;\n    }\n\n    function totalActiveValidators() internal view returns (uint16) {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        return s.validatorSet.totalActiveValidators();\n    }\n\n    /// @notice Gets the total number of validators, including active and waiting\n    function totalValidators() internal view returns (uint16) {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        return\n            s.validatorSet.waitingValidators.getSize() +\n            s.validatorSet.activeValidators.getSize();\n    }\n\n    function getTotalConfirmedCollateral() internal view returns (uint256) {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        return s.validatorSet.getTotalConfirmedCollateral();\n    }\n\n    function getTotalCollateral() internal view returns (uint256) {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        return s.validatorSet.getTotalConfirmedCollateral();\n    }\n\n    /// @notice Gets the total collateral the validators has staked.\n    function totalValidatorCollateral(\n        address validator\n    ) internal view returns (uint256) {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        return s.validatorSet.validators[validator].totalCollateral;\n    }\n\n    // =============== Operations directly confirm =============\n\n    /// @notice Set the validator federated power directly without queueing the request\n    function setFederatedPowerWithConfirm(\n        address validator,\n        uint256 power\n    ) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        s.validatorSet.confirmFederatedPower(validator, power);\n    }\n\n    /// @notice Set the validator metadata directly without queueing the request\n    function setMetadataWithConfirm(\n        address validator,\n        bytes calldata metadata\n    ) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        s.validatorSet.setMetadata(validator, metadata);\n    }\n\n    /// @notice Confirm the deposit directly without going through the confirmation process\n    function depositWithConfirm(address validator, uint256 amount) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n\n        // record deposit that updates the total collateral\n        s.validatorSet.recordDeposit(validator, amount);\n        // confirm deposit that updates the confirmed collateral\n        s.validatorSet.confirmDeposit(validator, amount);\n\n        if (!s.bootstrapped) {\n            // add to initial validators avoiding duplicates if it\n            // is a genesis validator.\n            bool alreadyValidator;\n            uint256 length = s.genesisValidators.length;\n            for (uint256 i; i < length; ) {\n                if (s.genesisValidators[i].addr == validator) {\n                    alreadyValidator = true;\n                    break;\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n            if (!alreadyValidator) {\n                uint256 collateral = s\n                    .validatorSet\n                    .validators[validator]\n                    .confirmedCollateral;\n                Validator memory val = Validator({\n                    addr: validator,\n                    weight: collateral,\n                    metadata: s.validatorSet.validators[validator].metadata\n                });\n                s.genesisValidators.push(val);\n            }\n        }\n    }\n\n    /// @notice Confirm the withdraw directly without going through the confirmation process\n    /// and releasing from the gateway.\n    /// @dev only use for non-bootstrapped subnets\n    function withdrawWithConfirm(address validator, uint256 amount) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n\n        // record deposit that updates the total collateral\n        s.validatorSet.recordWithdraw(validator, amount);\n        // confirm deposit that updates the confirmed collateral\n        s.validatorSet.confirmWithdraw(validator, amount);\n\n        // release stake from gateway and transfer to user\n        payable(validator).sendValue(amount);\n    }\n\n    // ================= Operations that are queued ==============\n    /// @notice Set the federated power of the validator\n    function setFederatedPower(\n        address validator,\n        bytes calldata metadata,\n        uint256 amount\n    ) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        s.changeSet.federatedPowerRequest({\n            validator: validator,\n            metadata: metadata,\n            power: amount\n        });\n    }\n\n    /// @notice Set the validator metadata\n    function setValidatorMetadata(\n        address validator,\n        bytes calldata metadata\n    ) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        s.changeSet.metadataRequest(validator, metadata);\n    }\n\n    /// @notice Deposit the collateral\n    function deposit(address validator, uint256 amount) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n\n        s.changeSet.depositRequest(validator, amount);\n        s.validatorSet.recordDeposit(validator, amount);\n    }\n\n    /// @notice Withdraw the collateral\n    function withdraw(address validator, uint256 amount) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n\n        s.changeSet.withdrawRequest(validator, amount);\n        s.validatorSet.recordWithdraw(validator, amount);\n    }\n\n    // =============== Other functions ================\n\n    /// @notice Claim the released collateral\n    function claimCollateral(address validator) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        uint256 amount = s.releaseQueue.claim(validator);\n        emit CollateralClaimed(validator, amount);\n    }\n\n    function getConfigurationNumbers() internal view returns (uint64, uint64) {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        return (\n            s.changeSet.nextConfigurationNumber,\n            s.changeSet.startConfigurationNumber\n        );\n    }\n\n    /// @notice Confirm the changes in bottom up checkpoint submission, only call this in bottom up checkpoint execution.\n    function confirmChange(uint64 configurationNumber) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n        StakingChangeLog storage changeSet = s.changeSet;\n\n        if (configurationNumber >= changeSet.nextConfigurationNumber) {\n            revert CannotConfirmFutureChanges();\n        } else if (configurationNumber < changeSet.startConfigurationNumber) {\n            return;\n        }\n\n        uint64 start = changeSet.startConfigurationNumber;\n        for (uint64 i = start; i <= configurationNumber; ) {\n            StakingChange storage change = changeSet.getChange(i);\n            address validator = change.validator;\n\n            if (change.op == StakingOperation.SetMetadata) {\n                s.validatorSet.validators[validator].metadata = change.payload;\n            } else if (change.op == StakingOperation.SetFederatedPower) {\n                (bytes memory metadata, uint256 power) = abi.decode(\n                    change.payload,\n                    (bytes, uint256)\n                );\n                s.validatorSet.validators[validator].metadata = metadata;\n                s.validatorSet.confirmFederatedPower(validator, power);\n            } else {\n                uint256 amount = abi.decode(change.payload, (uint256));\n\n                if (change.op == StakingOperation.Withdraw) {\n                    s.validatorSet.confirmWithdraw(validator, amount);\n                    s.releaseQueue.addNewRelease(validator, amount);\n                    IGateway(s.ipcGatewayAddr).releaseStake(amount);\n                } else {\n                    s.validatorSet.confirmDeposit(validator, amount);\n                    IGateway(s.ipcGatewayAddr).addStake{value: amount}();\n                }\n            }\n\n            changeSet.purgeChange(i);\n            unchecked {\n                ++i;\n            }\n        }\n\n        changeSet.startConfigurationNumber = configurationNumber + 1;\n\n        emit ConfigurationNumberConfirmed(configurationNumber);\n    }\n}\n\n/// The library for tracking validator changes coming from the parent.\n/// Should be used in the child gateway to store changes until they can be applied.\nlibrary LibValidatorTracking {\n    using LibValidatorSet for ValidatorSet;\n    using LibStakingChangeLog for StakingChangeLog;\n\n    function storeChange(\n        ParentValidatorsTracker storage self,\n        StakingChangeRequest calldata changeRequest\n    ) internal {\n        uint64 configurationNumber = self.changes.recordChange({\n            validator: changeRequest.change.validator,\n            op: changeRequest.change.op,\n            payload: changeRequest.change.payload\n        });\n\n        if (configurationNumber != changeRequest.configurationNumber) {\n            revert InvalidConfigurationNumber();\n        }\n    }\n\n    function batchStoreChange(\n        ParentValidatorsTracker storage self,\n        StakingChangeRequest[] calldata changeRequests\n    ) internal {\n        uint256 length = changeRequests.length;\n        if (length == 0) {\n            return;\n        }\n\n        for (uint256 i; i < length; ) {\n            storeChange(self, changeRequests[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Confirm the changes in for a finality commitment\n    function confirmChange(\n        ParentValidatorsTracker storage self,\n        uint64 configurationNumber\n    ) internal {\n        if (configurationNumber >= self.changes.nextConfigurationNumber) {\n            revert CannotConfirmFutureChanges();\n        } else if (\n            configurationNumber < self.changes.startConfigurationNumber\n        ) {\n            return;\n        }\n\n        uint64 start = self.changes.startConfigurationNumber;\n\n        for (uint64 i = start; i <= configurationNumber; ) {\n            StakingChange storage change = self.changes.getChange(i);\n            address validator = change.validator;\n\n            if (change.op == StakingOperation.SetMetadata) {\n                self.validators.validators[validator].metadata = change.payload;\n            } else if (change.op == StakingOperation.SetFederatedPower) {\n                (bytes memory metadata, uint256 power) = abi.decode(\n                    change.payload,\n                    (bytes, uint256)\n                );\n                self.validators.validators[validator].metadata = metadata;\n                self.validators.confirmFederatedPower(validator, power);\n            } else {\n                uint256 amount = abi.decode(change.payload, (uint256));\n\n                if (change.op == StakingOperation.Withdraw) {\n                    self.validators.confirmWithdraw(validator, amount);\n                } else {\n                    self.validators.confirmDeposit(validator, amount);\n                }\n            }\n\n            self.changes.purgeChange(i);\n            unchecked {\n                ++i;\n            }\n        }\n        self.changes.startConfigurationNumber = configurationNumber + 1;\n    }\n}\n"
    },
    "contracts/ipc/lib/LibStakingChangeLog.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {StakingChangeLog, StakingChange, StakingOperation} from \"../structs/Subnet.sol\";\n\n/// The util library for `StakingChangeLog`\nlibrary LibStakingChangeLog {\n    event NewStakingChangeRequest(StakingOperation op, address validator, bytes payload, uint64 configurationNumber);\n\n    /// @notice Validator request to update its metadata\n    function metadataRequest(StakingChangeLog storage changes, address validator, bytes calldata metadata) internal {\n        uint64 configurationNumber = recordChange({\n            changes: changes,\n            validator: validator,\n            op: StakingOperation.SetMetadata,\n            payload: metadata\n        });\n\n        emit NewStakingChangeRequest({\n            op: StakingOperation.SetMetadata,\n            validator: validator,\n            payload: metadata,\n            configurationNumber: configurationNumber\n        });\n    }\n\n    /// @notice Records a request to update the federated power of a validator\n    function federatedPowerRequest(\n        StakingChangeLog storage changes,\n        address validator,\n        bytes calldata metadata,\n        uint256 power\n    ) internal {\n        bytes memory payload = abi.encode(metadata, power);\n\n        uint64 configurationNumber = recordChange({\n            changes: changes,\n            validator: validator,\n            op: StakingOperation.SetFederatedPower,\n            payload: payload\n        });\n\n        emit NewStakingChangeRequest({\n            op: StakingOperation.SetFederatedPower,\n            validator: validator,\n            payload: payload,\n            configurationNumber: configurationNumber\n        });\n    }\n\n    /// @notice Perform upsert operation to the withdraw changes, return total value to withdraw\n    /// @notice of the validator.\n    /// Each insert will increment the configuration number by 1, update will not.\n    function withdrawRequest(StakingChangeLog storage changes, address validator, uint256 amount) internal {\n        bytes memory payload = abi.encode(amount);\n\n        uint64 configurationNumber = recordChange({\n            changes: changes,\n            validator: validator,\n            op: StakingOperation.Withdraw,\n            payload: payload\n        });\n\n        emit NewStakingChangeRequest({\n            op: StakingOperation.Withdraw,\n            validator: validator,\n            payload: payload,\n            configurationNumber: configurationNumber\n        });\n    }\n\n    /// @notice Perform upsert operation to the deposit changes\n    function depositRequest(StakingChangeLog storage changes, address validator, uint256 amount) internal {\n        bytes memory payload = abi.encode(amount);\n\n        uint64 configurationNumber = recordChange({\n            changes: changes,\n            validator: validator,\n            op: StakingOperation.Deposit,\n            payload: payload\n        });\n\n        emit NewStakingChangeRequest({\n            op: StakingOperation.Deposit,\n            validator: validator,\n            payload: payload,\n            configurationNumber: configurationNumber\n        });\n    }\n\n    /// @notice Perform upsert operation to the deposit changes\n    function recordChange(\n        StakingChangeLog storage changes,\n        address validator,\n        StakingOperation op,\n        bytes memory payload\n    ) internal returns (uint64 configurationNumber) {\n        configurationNumber = changes.nextConfigurationNumber;\n\n        changes.changes[configurationNumber] = StakingChange({op: op, validator: validator, payload: payload});\n\n        changes.nextConfigurationNumber = configurationNumber + 1;\n    }\n\n    /// @notice Get the change at configuration number\n    function getChange(\n        StakingChangeLog storage changes,\n        uint64 configurationNumber\n    ) internal view returns (StakingChange storage) {\n        return changes.changes[configurationNumber];\n    }\n\n    function purgeChange(StakingChangeLog storage changes, uint64 configurationNumber) internal {\n        delete changes.changes[configurationNumber];\n    }\n}\n"
    },
    "contracts/ipc/lib/LibSubnetActor.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {VALIDATOR_SECP256K1_PUBLIC_KEY_LENGTH} from \"../constants/Constants.sol\";\nimport {ERR_PERMISSIONED_AND_BOOTSTRAPPED} from \"../errors/IPCErrors.sol\";\nimport {NotEnoughGenesisValidators, DuplicatedGenesisValidator, NotOwnerOfPublicKey, MethodNotAllowed} from \"../errors/IPCErrors.sol\";\nimport {IGateway} from \"../interfaces/IGateway.sol\";\nimport {Validator, ValidatorSet, PermissionMode} from \"../structs/Subnet.sol\";\nimport {SubnetActorModifiers} from \"../lib/LibSubnetActorStorage.sol\";\nimport {LibValidatorSet, LibStaking} from \"../lib/LibStaking.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {LibSubnetActorStorage, SubnetActorStorage} from \"./LibSubnetActorStorage.sol\";\n\nlibrary LibSubnetActor {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    event SubnetBootstrapped(Validator[]);\n\n    /// @notice Ensures that the subnet is operating under Collateral-based permission mode.\n    /// @dev Reverts if the subnet is not in Collateral mode.\n    function enforceCollateralValidation() internal view {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n\n        if (s.validatorSet.permissionMode != PermissionMode.Collateral) {\n            revert MethodNotAllowed(ERR_PERMISSIONED_AND_BOOTSTRAPPED);\n        }\n        return;\n    }\n\n    /// @notice Ensures that the subnet is operating under Federated permission mode.\n    /// @dev Reverts if the subnet is not in Federated mode.\n    function enforceFederatedValidation() internal view {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n\n        if (s.validatorSet.permissionMode != PermissionMode.Federated) {\n            revert MethodNotAllowed(ERR_PERMISSIONED_AND_BOOTSTRAPPED);\n        }\n        return;\n    }\n\n    /// @dev This function is used to bootstrap the subnet,\n    ///     if its total collateral is greater than minimum activation collateral.\n    function bootstrapSubnetIfNeeded() internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n\n        uint256 totalCollateral = LibStaking.getTotalConfirmedCollateral();\n\n        if (totalCollateral >= s.minActivationCollateral) {\n            if (LibStaking.totalActiveValidators() >= s.minValidators) {\n                s.bootstrapped = true;\n                emit SubnetBootstrapped(s.genesisValidators);\n\n                // register adding the genesis circulating supply (if it exists)\n                IGateway(s.ipcGatewayAddr).register{\n                    value: totalCollateral + s.genesisCircSupply\n                }(s.genesisCircSupply);\n            }\n        }\n    }\n\n    /// @notice Converts a 65-byte public key to its corresponding address.\n    /// @param publicKey The 65-byte public key to be converted.\n    /// @return The address derived from the given public key.\n    function publicKeyToAddress(\n        bytes calldata publicKey\n    ) internal pure returns (address) {\n        assert(publicKey.length == VALIDATOR_SECP256K1_PUBLIC_KEY_LENGTH);\n        bytes32 hashed = keccak256(publicKey[1:]);\n        return address(uint160(uint256(hashed)));\n    }\n\n    /// @notice method that allows the contract owner to set the validators' federated power before.\n    /// @notice subnet has already been bootstrapped.\n    /// @param validators The list of validators' addresses.\n    /// @param publicKeys The list of validators' public keys.\n    /// @param powers The list of power values of the validators.\n    function preBootstrapSetFederatedPower(\n        address[] calldata validators,\n        bytes[] calldata publicKeys,\n        uint256[] calldata powers\n    ) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n\n        uint256 length = validators.length;\n\n        if (length <= s.minValidators) {\n            revert NotEnoughGenesisValidators();\n        }\n\n        for (uint256 i; i < length; ) {\n            // check addresses\n            address convertedAddress = publicKeyToAddress(publicKeys[i]);\n            if (convertedAddress != validators[i]) {\n                revert NotOwnerOfPublicKey();\n            }\n\n            // performing deduplication\n            // validator should have no power when first added\n            if (LibStaking.getPower(validators[i]) > 0) {\n                revert DuplicatedGenesisValidator();\n            }\n\n            LibStaking.setMetadataWithConfirm(validators[i], publicKeys[i]);\n            LibStaking.setFederatedPowerWithConfirm(validators[i], powers[i]);\n\n            s.genesisValidators.push(\n                Validator({\n                    addr: validators[i],\n                    weight: powers[i],\n                    metadata: publicKeys[i]\n                })\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        s.bootstrapped = true;\n        emit SubnetBootstrapped(s.genesisValidators);\n\n        // register adding the genesis circulating supply (if it exists)\n        IGateway(s.ipcGatewayAddr).register{value: s.genesisCircSupply}(\n            s.genesisCircSupply\n        );\n    }\n\n    /// @notice method that allows the contract owner to set the validators' federated power after\n    /// @dev subnet has already been bootstrapped.\n    /// @param validators The list of validators' addresses.\n    /// @param publicKeys The list of validators' public keys.\n    /// @param powers The list of power values of the validators.\n    function postBootstrapSetFederatedPower(\n        address[] calldata validators,\n        bytes[] calldata publicKeys,\n        uint256[] calldata powers\n    ) internal {\n        uint256 length = validators.length;\n        for (uint256 i; i < length; ) {\n            // check addresses\n            address convertedAddress = publicKeyToAddress(publicKeys[i]);\n            if (convertedAddress != validators[i]) {\n                revert NotOwnerOfPublicKey();\n            }\n\n            // no need to do deduplication as set directly set the power, there wont be any addition of\n            // federated power.\n            LibStaking.setFederatedPower({\n                validator: validators[i],\n                metadata: publicKeys[i],\n                amount: powers[i]\n            });\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @notice Removes an address from the initial balance keys.\n    /// @param addr The address to be removed from the genesis balance keys.\n    function rmAddressFromBalanceKey(address addr) internal {\n        SubnetActorStorage storage s = LibSubnetActorStorage.appStorage();\n\n        uint256 length = s.genesisBalanceKeys.length;\n        for (uint256 i; i < length; ) {\n            if (s.genesisBalanceKeys[i] == addr) {\n                s.genesisBalanceKeys[i] = s.genesisBalanceKeys[length - 1];\n                s.genesisBalanceKeys.pop();\n                // exit after removing the key\n                break;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/ipc/lib/LibSubnetActorStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {ConsensusType} from \"../enums/ConsensusType.sol\";\nimport {NotGateway, SubnetAlreadyKilled} from \"../errors/IPCErrors.sol\";\nimport {BottomUpCheckpoint, BottomUpMsgBatchInfo} from \"../structs/CrossNet.sol\";\nimport {SubnetID, ValidatorSet, StakingChangeLog, StakingReleaseQueue, SupplySource, Validator, PermissionMode} from \"../structs/Subnet.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nstruct SubnetActorStorage {\n    /// @notice initial circulating supply provided by genesis validators to use when bootstrapping\n    /// the network.\n    uint256 genesisCircSupply;\n    /// @notice The height of the last committed bottom-up checkpoint.\n    uint256 lastBottomUpCheckpointHeight;\n    /// @notice Minimal activation collateral\n    uint256 minActivationCollateral;\n    /// @notice number of blocks in a bottom-up epoch\n    uint256 bottomUpCheckPeriod;\n    // @notice Hash of the current subnet id\n    bytes32 currentSubnetHash;\n    /// @notice Address of the IPC gateway for the subnet\n    address ipcGatewayAddr;\n    /// @notice Maximum number of messages per batch\n    uint64 maxMsgsPerBottomUpBatch;\n    /// @notice majority percentage value (must be greater than or equal to 51)\n    uint8 majorityPercentage;\n    /// @notice Power scale determining the accuracy of the power scale (in number of decimals from whole FIL)\n    /// (e.g. Fil = 0, miliFil = 3; microFIL = 6, attoFil = 18, etc.)\n    /// We allow negative values to also allow 10 FIL = 1 unit of power for power_scale = -1.\n    int8 powerScale;\n    /// immutable params\n    ConsensusType consensus;\n    /// @notice Determines if the subnet has been bootstrapped (i.e. it has been activated)\n    bool bootstrapped;\n    /// @notice Minimal number of validators required for the subnet to be able to validate new blocks.\n    uint64 minValidators;\n    /// @notice Determines if the subnet has been successfully killed\n    bool killed;\n    /// @notice subnet supply strategy.\n    SupplySource supplySource;\n    /// @notice ID of the parent subnet\n    SubnetID parentId;\n    // =========== Staking ===========\n    /// @notice the list of validators staking\n    ValidatorSet validatorSet;\n    /// @notice Contains the list of changes to validator set. Configuration number is associated at each change.\n    StakingChangeLog changeSet;\n    /// @notice The staking release queue that only allow transfer of collateral after certain locking period.\n    StakingReleaseQueue releaseQueue;\n    /// =============\n    /// mapping of bootstrap owner to its bootstrap node address\n    mapping(address => string) bootstrapNodes;\n    /// @notice the list ov validators that announces bootstrap nodes\n    EnumerableSet.AddressSet bootstrapOwners;\n    /// @notice contains all committed bottom-up checkpoint at specific epoch\n    mapping(uint256 => BottomUpCheckpoint) committedCheckpoints;\n    /// @notice initial set of validators joining in genesis\n    Validator[] genesisValidators;\n    /// @notice genesis balance to be allocated to the subnet in genesis.\n    mapping(address => uint256) genesisBalance;\n    /// @notice genesis balance addresses\n    address[] genesisBalanceKeys;\n}\n\nlibrary LibSubnetActorStorage {\n    function appStorage()\n        internal\n        pure\n        returns (SubnetActorStorage storage ds)\n    {\n        assembly {\n            ds.slot := 0\n        }\n        return ds;\n    }\n}\n\ncontract SubnetActorModifiers {\n    SubnetActorStorage internal s;\n\n    function _onlyGateway() private view {\n        if (msg.sender != s.ipcGatewayAddr) {\n            revert NotGateway();\n        }\n    }\n\n    function _notKilled() private view {\n        if (s.killed) {\n            revert SubnetAlreadyKilled();\n        }\n    }\n\n    modifier onlyGateway() {\n        _onlyGateway();\n        _;\n    }\n\n    modifier notKilled() {\n        _notKilled();\n        _;\n    }\n}\n"
    },
    "contracts/ipc/lib/LibSubnetRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {SubnetCreationPrivileges} from \"../structs/Subnet.sol\";\n\nstruct SubnetRegistryActorStorage {\n    // solhint-disable-next-line var-name-mixedcase\n    address GATEWAY;\n    /// The getter and manager facet shared by diamond\n    // solhint-disable-next-line var-name-mixedcase\n    address SUBNET_ACTOR_GETTER_FACET;\n    // solhint-disable-next-line var-name-mixedcase\n    address SUBNET_ACTOR_MANAGER_FACET;\n    // solhint-disable-next-line var-name-mixedcase\n    address SUBNET_ACTOR_REWARD_FACET;\n    // solhint-disable-next-line var-name-mixedcase\n    address SUBNET_ACTOR_CHECKPOINTING_FACET;\n    // solhint-disable-next-line var-name-mixedcase\n    address SUBNET_ACTOR_PAUSE_FACET;\n    // solhint-disable-next-line var-name-mixedcase\n    address SUBNET_ACTOR_DIAMOND_CUT_FACET;\n    // solhint-disable-next-line var-name-mixedcase\n    address SUBNET_ACTOR_LOUPE_FACET;\n    // solhint-disable-next-line var-name-mixedcase\n    address SUBNET_ACTOR_OWNERSHIP_FACET;\n    /// The subnet actor getter facet functions selectors\n    bytes4[] subnetActorGetterSelectors;\n    /// The subnet actor manager facet functions selectors\n    bytes4[] subnetActorManagerSelectors;\n    /// The subnet actor reward facet functions selectors\n    bytes4[] subnetActorRewarderSelectors;\n    /// The subnet actor checkpointing facet functions selectors\n    bytes4[] subnetActorCheckpointerSelectors;\n    /// The subnet actor pause facet functions selectors\n    bytes4[] subnetActorPauserSelectors;\n    /// The subnet actor diamond cut facet functions selectors\n    bytes4[] subnetActorDiamondCutSelectors;\n    /// The subnet actor loupe facet functions selectors\n    bytes4[] subnetActorDiamondLoupeSelectors;\n    /// The subnet actor ownership facet functions selectors\n    bytes4[] subnetActorOwnershipSelectors;\n    /// @notice Mapping that tracks the deployed subnet actors per user.\n    /// Key is the hash of Subnet ID, values are addresses.\n    /// mapping owner => nonce => subnet\n    mapping(address => mapping(uint64 => address)) subnets;\n    /// @notice Mapping that tracks the latest nonce of the deployed\n    /// subnet for each user.\n    /// owner => nonce\n    mapping(address => uint64) userNonces;\n    /// @notice The subnet creation privileges.\n    SubnetCreationPrivileges creationPrivileges;\n}\n"
    },
    "contracts/ipc/lib/priority/LibMaxPQ.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {LibValidatorSet} from \"../LibStaking.sol\";\nimport {ValidatorSet} from \"../../structs/Subnet.sol\";\nimport {PQ, LibPQ} from \"./LibPQ.sol\";\n\nstruct MaxPQ {\n    PQ inner;\n}\n\n/// The max index priority queue for staking. The same implementation as LibMinPQ, just order compare\n/// is reversed.\nlibrary LibMaxPQ {\n    using LibPQ for PQ;\n    using LibValidatorSet for ValidatorSet;\n\n    function getSize(MaxPQ storage self) internal view returns (uint16) {\n        return self.inner.size;\n    }\n\n    function getAddress(MaxPQ storage self, uint16 i) internal view returns (address) {\n        return self.inner.posToAddress[i];\n    }\n\n    function contains(MaxPQ storage self, address validator) internal view returns (bool) {\n        return self.inner.contains(validator);\n    }\n\n    /// @notice Insert the validator address into this PQ.\n    /// NOTE that caller should ensure the valdiator is not already in the queue.\n    function insert(MaxPQ storage self, ValidatorSet storage validators, address validator) internal {\n        uint16 size = self.inner.size + 1;\n\n        self.inner.addressToPos[validator] = size;\n        self.inner.posToAddress[size] = validator;\n\n        self.inner.size = size;\n\n        uint256 power = validators.getPower(validator);\n        swim({self: self, validators: validators, pos: size, value: power});\n    }\n\n    /// @notice Pop the maximum value in the priority queue.\n    /// NOTE that caller should ensure the queue is not empty!\n    function pop(MaxPQ storage self, ValidatorSet storage validators) internal {\n        self.inner.requireNotEmpty();\n\n        uint16 size = self.inner.size;\n\n        self.inner.exchange(1, size);\n\n        self.inner.size = size - 1;\n        self.inner.del(size);\n\n        uint256 power = self.inner.getPower(validators, 1);\n        sink({self: self, validators: validators, pos: 1, value: power});\n    }\n\n    /// @notice Reheapify the heap when the validator is deleted.\n    /// NOTE that caller should ensure the queue is not empty.\n    function deleteReheapify(MaxPQ storage self, ValidatorSet storage validators, address validator) internal {\n        uint16 pos = self.inner.getPosOrRevert(validator);\n        uint16 size = self.inner.size;\n\n        self.inner.exchange(pos, size);\n\n        // remove the item\n        self.inner.size = size - 1;\n        self.inner.del(size);\n\n        if (size == pos) {\n            return;\n        }\n\n        // swim pos up in case exchanged index is smaller\n        uint256 power = self.inner.getPower(validators, pos);\n        swim({self: self, validators: validators, pos: pos, value: power});\n\n        // sink pos down in case updated pos is larger\n        power = self.inner.getPower(validators, pos);\n        sink({self: self, validators: validators, pos: pos, value: power});\n    }\n\n    /// @notice Reheapify the heap when the collateral of a key has increased.\n    /// NOTE that caller should ensure the queue is not empty.\n    function increaseReheapify(MaxPQ storage self, ValidatorSet storage validators, address validator) internal {\n        uint16 pos = self.inner.getPosOrRevert(validator);\n        uint256 power = validators.getPower(validator);\n        swim({self: self, validators: validators, pos: pos, value: power});\n    }\n\n    /// @notice Reheapify the heap when the collateral of a key has decreased.\n    /// NOTE that caller should ensure the queue is not empty.\n    function decreaseReheapify(MaxPQ storage self, ValidatorSet storage validators, address validator) internal {\n        uint16 pos = self.inner.getPosOrRevert(validator);\n        uint256 power = validators.getPower(validator);\n        sink({self: self, validators: validators, pos: pos, value: power});\n    }\n\n    /// @notice Get the maximum value in the priority queue.\n    /// NOTE that caller should ensure the queue is not empty!\n    function max(MaxPQ storage self, ValidatorSet storage validators) internal view returns (address, uint256) {\n        self.inner.requireNotEmpty();\n\n        address addr = self.inner.posToAddress[1];\n        uint256 power = validators.getPower(addr);\n        return (addr, power);\n    }\n\n    /***************************************************************************\n     * Heap internal helper functions, should not be called by external functions\n     ****************************************************************************/\n    function swim(MaxPQ storage self, ValidatorSet storage validators, uint16 pos, uint256 value) internal {\n        uint16 parentPos;\n        uint256 parentPower;\n\n        while (pos > 1) {\n            parentPos = pos >> 1; // parentPos = pos / 2\n            parentPower = self.inner.getPower(validators, parentPos);\n\n            // Parent power is not smaller than that of the current child, and the heap condition met.\n            if (!firstValueSmaller(parentPower, value)) {\n                break;\n            }\n\n            self.inner.exchange(parentPos, pos);\n            pos = parentPos;\n        }\n    }\n\n    function sink(MaxPQ storage self, ValidatorSet storage validators, uint16 pos, uint256 value) internal {\n        uint16 childPos = pos << 1; // childPos = pos * 2\n        uint256 childPower;\n\n        uint16 size = self.inner.size;\n\n        while (childPos <= size) {\n            if (childPos < size) {\n                // select the max of the two children\n                (childPos, childPower) = largerPosition({\n                    self: self,\n                    validators: validators,\n                    pos1: childPos,\n                    pos2: childPos + 1\n                });\n            } else {\n                childPower = self.inner.getPower(validators, childPos);\n            }\n\n            // parent, current idx, is not more than its two children, min heap condition is met.\n            if (!firstValueSmaller(value, childPower)) {\n                break;\n            }\n\n            self.inner.exchange(childPos, pos);\n            pos = childPos;\n            childPos = pos << 1;\n        }\n    }\n\n    /// @notice Get the larger index of pos1 and pos2.\n    function largerPosition(\n        MaxPQ storage self,\n        ValidatorSet storage validators,\n        uint16 pos1,\n        uint16 pos2\n    ) internal view returns (uint16, uint256) {\n        uint256 power1 = self.inner.getPower(validators, pos1);\n        uint256 power2 = self.inner.getPower(validators, pos2);\n\n        if (firstValueSmaller(power1, power2)) {\n            return (pos2, power2);\n        }\n        return (pos1, power1);\n    }\n\n    function firstValueSmaller(uint256 v1, uint256 v2) internal pure returns (bool) {\n        return v1 < v2;\n    }\n}"
    },
    "contracts/ipc/lib/priority/LibMinPQ.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {LibValidatorSet} from \"../LibStaking.sol\";\nimport {ValidatorSet} from \"../../structs/Subnet.sol\";\nimport {PQ, LibPQ} from \"./LibPQ.sol\";\n\nstruct MinPQ {\n    PQ inner;\n}\n\n/// The min index priority queue for staking\nlibrary LibMinPQ {\n    using LibPQ for PQ;\n    using LibValidatorSet for ValidatorSet;\n\n    function getSize(MinPQ storage self) internal view returns (uint16) {\n        return self.inner.size;\n    }\n\n    function getAddress(MinPQ storage self, uint16 i) internal view returns (address) {\n        return self.inner.posToAddress[i];\n    }\n\n    function contains(MinPQ storage self, address validator) internal view returns (bool) {\n        return self.inner.contains(validator);\n    }\n\n    /// @notice Insert the validator address into this PQ.\n    /// NOTE that caller should ensure the validator is not already in the queue.\n    function insert(MinPQ storage self, ValidatorSet storage validators, address validator) internal {\n        uint16 size = self.inner.size + 1;\n\n        self.inner.addressToPos[validator] = size;\n        self.inner.posToAddress[size] = validator;\n\n        self.inner.size = size;\n\n        uint256 power = validators.getPower(validator);\n        swim({self: self, validators: validators, pos: size, value: power});\n    }\n\n    /// @notice Pop the minimal value in the priority queue.\n    function pop(MinPQ storage self, ValidatorSet storage validators) internal {\n        self.inner.requireNotEmpty();\n\n        uint16 size = self.inner.size;\n\n        self.inner.exchange(1, size);\n\n        self.inner.size = size - 1;\n        self.inner.del(size);\n\n        uint256 power = self.inner.getPower(validators, 1);\n        sink({self: self, validators: validators, pos: 1, value: power});\n    }\n\n    /// @notice Reheapify the heap when the validator is deleted.\n    function deleteReheapify(MinPQ storage self, ValidatorSet storage validators, address validator) internal {\n        uint16 pos = self.inner.getPosOrRevert(validator);\n        uint16 size = self.inner.size;\n\n        self.inner.exchange(pos, size);\n\n        // remove the item\n        self.inner.size = size - 1;\n        self.inner.del(size);\n\n        if (size == pos) {\n            return;\n        }\n\n        // swim pos up in case exchanged index is smaller\n        uint256 val = self.inner.getPower(validators, pos);\n        swim({self: self, validators: validators, pos: pos, value: val});\n\n        // sink pos down in case updated pos is larger\n        val = self.inner.getPower(validators, pos);\n        sink({self: self, validators: validators, pos: pos, value: val});\n    }\n\n    /// @notice Reheapify the heap when the collateral of a key has increased.\n    function increaseReheapify(MinPQ storage self, ValidatorSet storage validators, address validator) internal {\n        uint16 pos = self.inner.getPosOrRevert(validator);\n        uint256 val = validators.getPower(validator);\n        sink({self: self, validators: validators, pos: pos, value: val});\n    }\n\n    /// @notice Reheapify the heap when the collateral of a key has decreased.\n    function decreaseReheapify(MinPQ storage self, ValidatorSet storage validators, address validator) internal {\n        uint16 pos = self.inner.getPosOrRevert(validator);\n        uint256 val = validators.getPower(validator);\n        swim({self: self, validators: validators, pos: pos, value: val});\n    }\n\n    /// @notice Get the minimal value in the priority queue.\n    /// NOTE that caller should ensure the queue is not empty!\n    function min(MinPQ storage self, ValidatorSet storage validators) internal view returns (address, uint256) {\n        self.inner.requireNotEmpty();\n\n        address addr = self.inner.posToAddress[1];\n        uint256 power = validators.getPower(addr);\n        return (addr, power);\n    }\n\n    /***************************************************************************\n     * Heap internal helper functions, should not be called by external functions\n     ****************************************************************************/\n    function swim(MinPQ storage self, ValidatorSet storage validators, uint16 pos, uint256 value) internal {\n        uint16 parentPos;\n        uint256 parentPower;\n\n        while (pos > 1) {\n            // parentPos = pos / 2;\n            parentPos = pos >> 1;\n            parentPower = self.inner.getPower(validators, parentPos);\n\n            // parent power is not more than that of the current child, heap condition met.\n            if (!firstValueLarger(parentPower, value)) {\n                break;\n            }\n\n            self.inner.exchange(parentPos, pos);\n            pos = parentPos;\n        }\n    }\n\n    function sink(MinPQ storage self, ValidatorSet storage validators, uint16 pos, uint256 value) internal {\n        uint16 childPos = pos * 2;\n        uint256 childPower;\n\n        uint16 size = self.inner.size;\n\n        while (childPos <= size) {\n            if (childPos < size) {\n                // select the min of the two children\n                (childPos, childPower) = smallerPosition({\n                    self: self,\n                    validators: validators,\n                    pos1: childPos,\n                    pos2: childPos + 1\n                });\n            } else {\n                childPower = self.inner.getPower(validators, childPos);\n            }\n\n            // parent, current idx, is not more than its two children, min heap condition is met.\n            if (!firstValueLarger(value, childPower)) {\n                break;\n            }\n\n            self.inner.exchange(childPos, pos);\n            pos = childPos;\n            childPos = pos * 2;\n        }\n    }\n\n    /// @notice Get the smaller index of pos1 and pos2.\n    function smallerPosition(\n        MinPQ storage self,\n        ValidatorSet storage validators,\n        uint16 pos1,\n        uint16 pos2\n    ) internal view returns (uint16, uint256) {\n        uint256 value1 = self.inner.getPower(validators, pos1);\n        uint256 value2 = self.inner.getPower(validators, pos2);\n\n        if (!firstValueLarger(value1, value2)) {\n            return (pos1, value1);\n        }\n        return (pos2, value2);\n    }\n\n    function firstValueLarger(uint256 v1, uint256 v2) internal pure returns (bool) {\n        return v1 > v2;\n    }\n}"
    },
    "contracts/ipc/lib/priority/LibPQ.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {LibValidatorSet} from \"../LibStaking.sol\";\nimport {ValidatorSet} from \"../../structs/Subnet.sol\";\nimport {PQEmpty, PQDoesNotContainAddress} from \"../../errors/IPCErrors.sol\";\n\n/// The implementation that mimics the Java impl in https://algs4.cs.princeton.edu/24pq/IndexMinPQ.java.html.\n\n/// The inner data structure for both min and max priority queue\nstruct PQ {\n    /// The size of the priority queue\n    uint16 size;\n    /// @notice The mapping from validator address to the position on the priority queue. Position is 1-based indexing.\n    mapping(address => uint16) addressToPos;\n    /// @notice The mapping from the position on the priority queue to validator address.\n    mapping(uint16 => address) posToAddress;\n}\n\nlibrary LibPQ {\n    using LibValidatorSet for ValidatorSet;\n\n    function isEmpty(PQ storage self) internal view returns (bool) {\n        return self.size == 0;\n    }\n\n    function requireNotEmpty(PQ storage self) internal view {\n        if (self.size == 0) {\n            revert PQEmpty();\n        }\n    }\n\n    function getSize(PQ storage self) internal view returns (uint16) {\n        return self.size;\n    }\n\n    function contains(PQ storage self, address validator) internal view returns (bool) {\n        return self.addressToPos[validator] != 0;\n    }\n\n    function getPosOrRevert(PQ storage self, address validator) internal view returns (uint16 pos) {\n        pos = self.addressToPos[validator];\n        if (pos == 0) {\n            revert PQDoesNotContainAddress();\n        }\n    }\n\n    function del(PQ storage self, uint16 pos) internal {\n        address addr = self.posToAddress[pos];\n        delete self.posToAddress[pos];\n        delete self.addressToPos[addr];\n    }\n\n    function getPower(\n        PQ storage self,\n        ValidatorSet storage validators,\n        uint16 pos\n    ) internal view returns (uint256) {\n        address addr = self.posToAddress[pos];\n        return validators.getPower(addr);\n    }\n\n    function getConfirmedCollateral(\n        PQ storage self,\n        ValidatorSet storage validators,\n        uint16 pos\n    ) internal view returns (uint256) {\n        address addr = self.posToAddress[pos];\n        return validators.getConfirmedCollateral(addr);\n    }\n\n    function exchange(PQ storage self, uint16 pos1, uint16 pos2) internal {\n        assert(pos1 <= self.size);\n        assert(pos2 <= self.size);\n\n        address addr1 = self.posToAddress[pos1];\n        address addr2 = self.posToAddress[pos2];\n\n        self.addressToPos[addr1] = pos2;\n        self.addressToPos[addr2] = pos1;\n\n        self.posToAddress[pos2] = addr1;\n        self.posToAddress[pos1] = addr2;\n    }\n}"
    },
    "contracts/ipc/lib/SubnetIDHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {SubnetID} from \"../structs/Subnet.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/// @title Helper library for manipulating SubnetID struct\n/// @author LimeChain team\nlibrary SubnetIDHelper {\n    using Strings for address;\n\n    error NoParentForSubnet();\n    error NoAddressForRoot();\n    error EmptySubnet();\n    error DifferentRootNetwork();\n    error InvalidRoute();\n\n    function getAddress(SubnetID memory subnet) public pure returns (address) {\n        uint256 length = subnet.route.length;\n\n        if (length == 0) {\n            revert NoAddressForRoot();\n        }\n        return subnet.route[length - 1];\n    }\n\n    function getParentSubnet(\n        SubnetID memory subnet\n    ) public pure returns (SubnetID memory) {\n        if (subnet.route.length == 0) {\n            revert NoParentForSubnet();\n        }\n\n        address[] memory route = new address[](subnet.route.length - 1);\n        uint256 routeLength = route.length;\n        for (uint256 i; i < routeLength; ) {\n            route[i] = subnet.route[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return SubnetID({root: subnet.root, route: route});\n    }\n\n    function toString(\n        SubnetID calldata subnet\n    ) public pure returns (string memory) {\n        string memory route = string.concat(\n            \"/r\",\n            Strings.toString(subnet.root)\n        );\n        uint256 subnetLength = subnet.route.length;\n        for (uint256 i; i < subnetLength; ) {\n            route = string.concat(route, \"/\");\n            route = string.concat(route, subnet.route[i].toHexString());\n            unchecked {\n                ++i;\n            }\n        }\n\n        return route;\n    }\n\n    function toHash(SubnetID calldata subnet) public pure returns (bytes32) {\n        return keccak256(abi.encode(subnet));\n    }\n\n    function createSubnetId(\n        SubnetID calldata subnet,\n        address actor\n    ) public pure returns (SubnetID memory newSubnet) {\n        newSubnet.root = subnet.root;\n        uint256 subnetRouteLength = subnet.route.length;\n        newSubnet.route = new address[](subnetRouteLength + 1);\n        for (uint256 i; i < subnetRouteLength; ) {\n            newSubnet.route[i] = subnet.route[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        newSubnet.route[newSubnet.route.length - 1] = actor;\n    }\n\n    function getActor(SubnetID calldata subnet) public pure returns (address) {\n        if (subnet.route.length == 0) {\n            return address(0);\n        }\n\n        return subnet.route[subnet.route.length - 1];\n    }\n\n    function isRoot(SubnetID calldata subnet) public pure returns (bool) {\n        // gas-opt: original check: subnet.root > 0\n        return subnet.route.length == 0 && subnet.root != 0;\n    }\n\n    function equals(\n        SubnetID calldata subnet1,\n        SubnetID calldata subnet2\n    ) public pure returns (bool) {\n        if (subnet1.root != subnet2.root) {\n            return false;\n        }\n        if (subnet1.route.length != subnet2.route.length) {\n            return false;\n        }\n\n        return toHash(subnet1) == toHash(subnet2);\n    }\n\n    /// @notice Computes the common parent of the current subnet and the one given as argument\n    function commonParent(\n        SubnetID calldata subnet1,\n        SubnetID calldata subnet2\n    ) public pure returns (SubnetID memory) {\n        if (subnet1.root != subnet2.root) {\n            return SubnetID({root: 0, route: new address[](0)});\n        }\n\n        uint256 i;\n        uint256 subnet1routeLength = subnet1.route.length;\n        uint256 subnet2routeLength = subnet2.route.length;\n        while (\n            i < subnet1routeLength &&\n            i < subnet2routeLength &&\n            subnet1.route[i] == subnet2.route[i]\n        ) {\n            unchecked {\n                ++i;\n            }\n        }\n        if (i == 0) {\n            return SubnetID({root: subnet1.root, route: new address[](0)});\n        }\n\n        address[] memory route = new address[](i);\n        for (uint256 j; j < i; ) {\n            route[j] = subnet1.route[j];\n            unchecked {\n                ++j;\n            }\n        }\n\n        return SubnetID({root: subnet1.root, route: route});\n    }\n\n    /// @notice In the path determined by the current subnet id, it moves\n    /// down in the path from the subnet id given as argument.\n    /// subnet2 needs to be a prefix of the subnet1.\n    /// If subnet1 is /a/b/c/d and subnet2 is /a/b, then the returned ID should be /a/b/c.\n    /// @dev Revert will be triggered if subnet2 is an invalid input.\n    function down(\n        SubnetID calldata subnet1,\n        SubnetID calldata subnet2\n    ) public pure returns (SubnetID memory) {\n        if (subnet1.root != subnet2.root) {\n            revert DifferentRootNetwork();\n        }\n        if (subnet1.route.length <= subnet2.route.length) {\n            revert InvalidRoute();\n        }\n\n        uint256 i;\n        uint256 subnet2routeLength = subnet2.route.length;\n        while (i < subnet2routeLength && subnet1.route[i] == subnet2.route[i]) {\n            unchecked {\n                ++i;\n            }\n        }\n\n        ++i;\n\n        address[] memory route = new address[](i);\n\n        for (uint256 j; j < i; ) {\n            route[j] = subnet1.route[j];\n            unchecked {\n                ++j;\n            }\n        }\n\n        return SubnetID({root: subnet1.root, route: route});\n    }\n\n    function isEmpty(SubnetID calldata subnetId) public pure returns (bool) {\n        return subnetId.route.length == 0 && subnetId.root == 0;\n    }\n}\n"
    },
    "contracts/ipc/lib/SupplySourceHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.23;\n\nimport {NotEnoughBalance} from \"../errors/IPCErrors.sol\";\nimport {SupplySource, SupplyKind} from \"../structs/Subnet.sol\";\nimport {EMPTY_BYTES} from \"../constants/Constants.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {SubnetActorGetterFacet} from \"../subnet/SubnetActorGetterFacet.sol\";\n\n/// @notice Helpers to deal with a supply source.\nlibrary SupplySourceHelper {\n    using SafeERC20 for IERC20;\n\n    error InvalidERC20Address();\n    error NoBalanceIncrease();\n    error UnexpectedSupplySource();\n    error UnknownSupplySource();\n\n    /// @notice Assumes that the address provided belongs to a subnet rooted on this network,\n    ///         and checks if its supply kind matches the provided one.\n    ///         It reverts if the address does not correspond to a subnet actor.\n    function hasSupplyOfKind(\n        address subnetActor,\n        SupplyKind compare\n    ) internal view returns (bool) {\n        return\n            SubnetActorGetterFacet(subnetActor).supplySource().kind == compare;\n    }\n\n    /// @notice Checks that a given supply strategy is correctly formed and its preconditions are met.\n    ///         It reverts if conditions are not met.\n    function validate(SupplySource memory supplySource) internal view {\n        if (supplySource.kind == SupplyKind.ERC20) {\n            if (supplySource.tokenAddress == address(0)) {\n                revert InvalidERC20Address();\n            }\n            // We require that the ERC20 token contract exists beforehand.\n            // The call to balanceOf will revert if the supplied address does not exist, or if it's not an ERC20 contract.\n            // Ideally we'd use ERC165 to check if the contract implements the ERC20 standard, but the latter does not support supportsInterface().\n            IERC20 token = IERC20(supplySource.tokenAddress);\n            token.balanceOf(address(0));\n        }\n    }\n\n    /// @notice Asserts that the supply strategy is of the given kind. If not, it reverts.\n    function expect(\n        SupplySource memory supplySource,\n        SupplyKind kind\n    ) internal pure {\n        if (supplySource.kind != kind) {\n            revert UnexpectedSupplySource();\n        }\n    }\n\n    /// @notice Locks the specified amount from msg.sender into custody.\n    ///         Reverts with NoBalanceIncrease if the token balance does not increase.\n    ///         May return more than requested for inflationary tokens due to balance rise.\n    function lock(\n        SupplySource memory supplySource,\n        uint256 value\n    ) internal returns (uint256) {\n        if (supplySource.kind == SupplyKind.ERC20) {\n            IERC20 token = IERC20(supplySource.tokenAddress);\n            uint256 initialBalance = token.balanceOf(address(this));\n            token.safeTransferFrom({\n                from: msg.sender,\n                to: address(this),\n                value: value\n            });\n            uint256 finalBalance = token.balanceOf(address(this));\n            if (finalBalance <= initialBalance) {\n                revert NoBalanceIncrease();\n            }\n            // Safe arithmetic is not necessary because underflow is not possible due to the check above\n            return finalBalance - initialBalance;\n        }\n        // Do nothing for native.\n        return value;\n    }\n\n    /// @notice Transfers the specified amount out of our treasury to the recipient address.\n    function transferFunds(\n        SupplySource memory supplySource,\n        address payable recipient,\n        uint256 value\n    ) internal returns (bool success, bytes memory ret) {\n        if (supplySource.kind == SupplyKind.Native) {\n            success = sendValue(payable(recipient), value);\n            return (success, EMPTY_BYTES);\n        } else if (supplySource.kind == SupplyKind.ERC20) {\n            return ierc20Transfer(supplySource, recipient, value);\n        }\n    }\n\n    /// @notice Wrapper for an IERC20 transfer that bubbles up the success or failure\n    /// and the return value instead of reverting so a cross-message receipt can be\n    /// triggered from the execution.\n    /// This function the `safeTransfer` function used before.\n    function ierc20Transfer(\n        SupplySource memory supplySource,\n        address recipient,\n        uint256 value\n    ) internal returns (bool success, bytes memory ret) {\n        return\n            supplySource.tokenAddress.call(\n                // using IERC20 transfer instead of safe transfer so we can\n                // bubble-up the failure instead of reverting on failure so we\n                // can send the receipt.\n                abi.encodePacked(\n                    IERC20.transfer.selector,\n                    abi.encode(recipient, value)\n                )\n            );\n    }\n\n    /// @notice Calls the target with the specified data, ensuring it receives the specified value.\n    function performCall(\n        SupplySource memory supplySource,\n        address payable target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bool success, bytes memory ret) {\n        // If value is zero, we can just go ahead and call the function.\n        if (value == 0) {\n            return functionCallWithValue(target, data, 0);\n        }\n\n        // Otherwise, we need to do something different.\n        if (supplySource.kind == SupplyKind.Native) {\n            // Use the optimized path to send value along with the call.\n            (success, ret) = functionCallWithValue({\n                target: target,\n                data: data,\n                value: value\n            });\n        } else if (supplySource.kind == SupplyKind.ERC20) {\n            (success, ret) = functionCallWithERC20Value({\n                supplySource: supplySource,\n                target: target,\n                data: data,\n                value: value\n            });\n        }\n        return (success, ret);\n    }\n\n    /// @dev Performs the function call with ERC20 value atomically\n    function functionCallWithERC20Value(\n        SupplySource memory supplySource,\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bool success, bytes memory ret) {\n        // Transfer the tokens first, _then_ perform the call.\n        (success, ret) = ierc20Transfer(supplySource, target, value);\n\n        if (success) {\n            // Perform the call only if the ERC20 was successful.\n            (success, ret) = functionCallWithValue(target, data, 0);\n        }\n\n        if (!success) {\n            // following the implementation of `@openzeppelin/contracts/utils/Address.sol`\n            if (ret.length > 0) {\n                assembly {\n                    let returndata_size := mload(ret)\n                    // see https://ethereum.stackexchange.com/questions/133748/trying-to-understand-solidity-assemblys-revert-function\n                    revert(add(32, ret), returndata_size)\n                }\n            }\n            // disable solhint as the failing call does not have return data as well.\n            /* solhint-disable reason-string */\n            revert();\n        }\n        return (success, ret);\n    }\n\n    /// @dev Adaptation from implementation `@openzeppelin/contracts/utils/Address.sol`\n    /// that doesn't revert immediately in case of failure and merely notifies of the outcome.\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bool success, bytes memory) {\n        if (address(this).balance < value) {\n            revert NotEnoughBalance();\n        }\n\n        return target.call{value: value}(data);\n    }\n\n    /**\n     *\n     * @dev Adaptation from implementation `@openzeppelin/contracts/utils/Address.sol`\n     * so it doesn't revert immediately and bubbles up the success of the call\n     *\n     * Replacement for Solidity's `transfer`: sends `value` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(\n        address payable recipient,\n        uint256 value\n    ) internal returns (bool) {\n        if (address(this).balance < value) {\n            revert NotEnoughBalance();\n        }\n        (bool success, ) = recipient.call{value: value}(\"\");\n        return success;\n    }\n\n    /// @notice Gets the balance in our treasury.\n    function balance(\n        SupplySource memory supplySource\n    ) internal view returns (uint256 ret) {\n        if (supplySource.kind == SupplyKind.Native) {\n            ret = address(this).balance;\n        } else if (supplySource.kind == SupplyKind.ERC20) {\n            ret = IERC20(supplySource.tokenAddress).balanceOf(address(this));\n        }\n    }\n\n    function native() internal pure returns (SupplySource memory) {\n        return\n            SupplySource({kind: SupplyKind.Native, tokenAddress: address(0)});\n    }\n}\n"
    },
    "contracts/ipc/sdk/interfaces/IIpcHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {IpcEnvelope, ResultMsg, CallMsg, IpcMsgKind} from \"../../structs/CrossNet.sol\";\n\n// Interface that needs to be implemented by IPC-aware contracts.\ninterface IIpcHandler {\n    error CallerIsNotGateway();\n    error UnsupportedMsgKind();\n    error UnrecognizedResult();\n\n    /// @notice Entrypoint for handling xnet messages in IPC-aware contracts.\n    function handleIpcMessage(\n        IpcEnvelope calldata envelope\n    ) external payable returns (bytes memory ret);\n}\n"
    },
    "contracts/ipc/sdk/IpcContract.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {IpcEnvelope, ResultMsg, CallMsg, IpcMsgKind} from \"../structs/CrossNet.sol\";\nimport {IPCAddress} from \"../structs/Subnet.sol\";\nimport {EMPTY_BYTES} from \"../constants/Constants.sol\";\nimport {IGateway} from \"../interfaces/IGateway.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {CrossMsgHelper} from \"../lib/CrossMsgHelper.sol\";\nimport {IIpcHandler} from \"./interfaces/IIpcHandler.sol\";\n\nabstract contract IpcExchange is IIpcHandler, Ownable, ReentrancyGuard {\n    using CrossMsgHelper for IpcEnvelope;\n\n    // The address of the gateway in the network.\n    address public immutable gatewayAddr;\n\n    // List of messages in-flight for which the contract hasn't received a receipt yet.\n    mapping(bytes32 => IpcEnvelope) public inflightMsgs;\n\n    constructor(address gatewayAddr_) Ownable(msg.sender) {\n        gatewayAddr = gatewayAddr_;\n    }\n\n    /// @notice Entrypoint for IPC-enabled contracts. This function is always called by\n    /// the gateway when a `Call` or `Receipt` cross-net messages is targeted to\n    /// a specific address in the subnet.\n    function handleIpcMessage(\n        IpcEnvelope calldata envelope\n    ) external payable onlyGateway returns (bytes memory) {\n        // internal dispatch of the cross-net message to the right method.\n        if (envelope.kind == IpcMsgKind.Call) {\n            CallMsg memory call = abi.decode(envelope.message, (CallMsg));\n            return _handleIpcCall(envelope, call);\n        } else if (envelope.kind == IpcMsgKind.Result) {\n            ResultMsg memory result = abi.decode(envelope.message, (ResultMsg));\n\n            // Recover the original message.\n            // If we were not tracking it, or if some details don't match, refuse to handle the receipt.\n            IpcEnvelope storage orig = inflightMsgs[result.id];\n            if (\n                orig.message.length == 0 ||\n                keccak256(abi.encode(envelope.from)) !=\n                keccak256(abi.encode(orig.to))\n            ) {\n                revert IIpcHandler.UnrecognizedResult();\n            }\n\n            /// Note: if the result handler reverts, we will\n            _handleIpcResult(orig, envelope, result);\n            delete inflightMsgs[result.id];\n            return EMPTY_BYTES;\n        }\n        revert UnsupportedMsgKind();\n    }\n\n    /// @notice Function to be overridden by the child contract to handle incoming IPC calls.\n    ///\n    /// NOTE: It's fine for this method to revert. If that happens, IPC will carry the error to the caller.\n    function _handleIpcCall(\n        IpcEnvelope memory envelope,\n        CallMsg memory callMsg\n    ) internal virtual returns (bytes memory);\n\n    /// @notice Function to be overridden by the child contract to handle results from previously performed IPC calls.\n    ///\n    /// NOTE: This must not revert as doing so will leave the correlation map in an inconsistent state.\n    /// (IPC will consider the result delivery attempted, and will not repeat it again).\n    function _handleIpcResult(\n        IpcEnvelope storage original,\n        IpcEnvelope memory result,\n        ResultMsg memory resultMsg\n    ) internal virtual;\n\n    /// @notice Method the implementation of this contract can invoke to perform an IPC call.\n    function performIpcCall(\n        IPCAddress memory to,\n        CallMsg memory callMsg,\n        uint256 value\n    ) internal nonReentrant returns (IpcEnvelope memory envelope) {\n        // Queue the cross-net message for dispatch.\n        envelope = IGateway(gatewayAddr).sendContractXnetMessage{value: value}(\n            IpcEnvelope({\n                kind: IpcMsgKind.Call,\n                from: to, // TODO: will anyway be replaced by sendContractXnetMessage.\n                to: to,\n                nonce: 0, // TODO: will be replaced.\n                value: value,\n                message: abi.encode(callMsg)\n            })\n        );\n        // Add the message to the list of inflights\n        bytes32 id = envelope.toHash();\n        inflightMsgs[id] = envelope;\n    }\n\n    function dropMessages(bytes32[] calldata ids) public onlyOwner {\n        uint256 length = ids.length;\n        for (uint256 i; i < length; ) {\n            delete inflightMsgs[ids[i]];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _onlyGateway() private view {\n        // only the gateway address is allowed to deliver xnet messages.\n        if (msg.sender != gatewayAddr) {\n            revert IIpcHandler.CallerIsNotGateway();\n        }\n    }\n\n    modifier onlyGateway() {\n        _onlyGateway();\n        _;\n    }\n}\n"
    },
    "contracts/ipc/sdk/IpcContractUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {IpcEnvelope, ResultMsg, CallMsg, IpcMsgKind} from \"../structs/CrossNet.sol\";\nimport {IPCAddress} from \"../structs/Subnet.sol\";\nimport {EMPTY_BYTES} from \"../constants/Constants.sol\";\nimport {IGateway} from \"../interfaces/IGateway.sol\";\nimport {ReentrancyGuardUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\nimport {CrossMsgHelper} from \"../lib/CrossMsgHelper.sol\";\n\nimport {IIpcHandler} from \"./interfaces/IIpcHandler.sol\";\n\nabstract contract IpcExchangeUpgradeable is\n    Initializable,\n    IIpcHandler,\n    OwnableUpgradeable,\n    ReentrancyGuardUpgradeable\n{\n    using CrossMsgHelper for IpcEnvelope;\n\n    // The address of the gateway in the network.\n    address public gatewayAddr;\n\n    // List of messages in-flight for which the contract hasn't received a receipt yet.\n    mapping(bytes32 => IpcEnvelope) public inflightMsgs;\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function __IpcExchangeUpgradeable_init(\n        address gatewayAddr_\n    ) public onlyInitializing {\n        gatewayAddr = gatewayAddr_;\n        __Ownable_init(msg.sender);\n        __ReentrancyGuard_init();\n    }\n\n    /// @notice Entrypoint for IPC-enabled contracts. This function is always called by\n    /// the gateway when a `Call` or `Receipt` cross-net messages is targeted to\n    /// a specific address in the subnet.\n    function handleIpcMessage(\n        IpcEnvelope calldata envelope\n    ) external payable onlyGateway returns (bytes memory) {\n        // internal dispatch of the cross-net message to the right method.\n        if (envelope.kind == IpcMsgKind.Call) {\n            CallMsg memory call = abi.decode(envelope.message, (CallMsg));\n            return _handleIpcCall(envelope, call);\n        } else if (envelope.kind == IpcMsgKind.Result) {\n            ResultMsg memory result = abi.decode(envelope.message, (ResultMsg));\n\n            // Recover the original message.\n            // If we were not tracking it, or if some details don't match, refuse to handle the receipt.\n            IpcEnvelope storage orig = inflightMsgs[result.id];\n            if (\n                orig.message.length == 0 ||\n                keccak256(abi.encode(envelope.from)) !=\n                keccak256(abi.encode(orig.to))\n            ) {\n                revert IIpcHandler.UnrecognizedResult();\n            }\n\n            /// Note: if the result handler reverts, we will\n            _handleIpcResult(orig, envelope, result);\n            delete inflightMsgs[result.id];\n            return EMPTY_BYTES;\n        }\n        revert UnsupportedMsgKind();\n    }\n\n    /// @notice Function to be overridden by the child contract to handle incoming IPC calls.\n    ///\n    /// NOTE: It's fine for this method to revert. If that happens, IPC will carry the error to the caller.\n    function _handleIpcCall(\n        IpcEnvelope memory envelope,\n        CallMsg memory callMsg\n    ) internal virtual returns (bytes memory);\n\n    /// @notice Function to be overridden by the child contract to handle results from previously performed IPC calls.\n    ///\n    /// NOTE: This must not revert as doing so will leave the correlation map in an inconsistent state.\n    /// (IPC will consider the result delivery attempted, and will not repeat it again).\n    function _handleIpcResult(\n        IpcEnvelope storage original,\n        IpcEnvelope memory result,\n        ResultMsg memory resultMsg\n    ) internal virtual;\n\n    /// @notice Method the implementation of this contract can invoke to perform an IPC call.\n    function performIpcCall(\n        IPCAddress memory to,\n        CallMsg memory callMsg,\n        uint256 value\n    ) internal nonReentrant returns (IpcEnvelope memory envelope) {\n        // Queue the cross-net message for dispatch.\n        envelope = IGateway(gatewayAddr).sendContractXnetMessage{value: value}(\n            IpcEnvelope({\n                kind: IpcMsgKind.Call,\n                from: to, // TODO: will anyway be replaced by sendContractXnetMessage.\n                to: to,\n                nonce: 0, // TODO: will be replaced.\n                value: value,\n                message: abi.encode(callMsg)\n            })\n        );\n        // Add the message to the list of inflights\n        bytes32 id = envelope.toHash();\n        inflightMsgs[id] = envelope;\n    }\n\n    function dropMessages(bytes32[] calldata ids) public onlyOwner {\n        uint256 length = ids.length;\n        for (uint256 i; i < length; ) {\n            delete inflightMsgs[ids[i]];\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function _onlyGateway() private view {\n        // only the gateway address is allowed to deliver xnet messages.\n        if (msg.sender != gatewayAddr) {\n            revert IIpcHandler.CallerIsNotGateway();\n        }\n    }\n\n    modifier onlyGateway() {\n        _onlyGateway();\n        _;\n    }\n}\n"
    },
    "contracts/ipc/structs/CrossNet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {SubnetID, IPCAddress} from \"./Subnet.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nuint64 constant MAX_MSGS_PER_BATCH = 10;\nuint256 constant BATCH_PERIOD = 100;\n\n/// @notice The parent finality for IPC parent at certain height.\nstruct ParentFinality {\n    uint256 height;\n    bytes32 blockHash;\n}\n\n/// @notice A bottom-up checkpoint type.\nstruct BottomUpCheckpoint {\n    /// @dev Child subnet ID, for replay protection from other subnets where the exact same validators operate.\n    /// Alternatively it can be appended to the hash before signing, similar to how we use the chain ID.\n    SubnetID subnetID;\n    /// @dev The height of the child subnet at which this checkpoint was cut.\n    /// Has to follow the previous checkpoint by checkpoint period.\n    uint256 blockHeight;\n    /// @dev The hash of the block.\n    bytes32 blockHash;\n    /// @dev The number of the membership (validator set) which is going to sign the next checkpoint.\n    /// This one expected to be signed by the validators from the membership reported in the previous checkpoint.\n    /// 0 could mean \"no change\".\n    uint64 nextConfigurationNumber;\n    /// @dev Batch of messages to execute.\n    IpcEnvelope[] msgs;\n}\n\n/// @notice A batch of bottom-up messages for execution.\nstruct BottomUpMsgBatch {\n    /// @dev Child subnet ID, for replay protection from other subnets where the exact same validators operate.\n    SubnetID subnetID;\n    /// @dev The height of the child subnet at which the batch was cut.\n    uint256 blockHeight;\n    /// @dev Batch of envelopes to execute.\n    IpcEnvelope[] msgs;\n}\n\n/// @notice Tracks information about the last batch executed.\nstruct BottomUpMsgBatchInfo {\n    uint256 blockHeight;\n    bytes32 hash;\n}\n\n/// @notice Type of cross-net messages currently supported\nenum IpcMsgKind {\n    /// @dev for cross-net messages that move native token, i.e. fund/release.\n    /// and in the future multi-level token transactions.\n    Transfer,\n    /// @dev general-purpose cross-net transaction that call smart contracts.\n    Call,\n    /// @dev receipt from the execution of cross-net messages\n    /// (currently limited to `Transfer` messages)\n    Result\n}\n\n/// @notice Envelope used to propagate IPC cross-net messages\nstruct IpcEnvelope {\n    /// @dev type of message being propagated.\n    IpcMsgKind kind;\n    /// @dev destination of the message\n    /// It makes sense to extract from the encoded message\n    /// all shared fields required by all message, so they\n    /// can be inspected without having to decode the message.\n    IPCAddress to;\n    /// @dev address sending the message\n    IPCAddress from;\n    /// @dev outgoing nonce for the envelope.\n    /// This nonce is set by the gateway when committing the message for propagation\n    uint64 nonce;\n    /// @dev value being sent in the message.\n    /// If we want receipts to return value, and all messages to be able\n    /// to handle different supply sources we can expose the value\n    /// as a common field.\n    uint256 value;\n    /// @dev abi.encoded message\n    bytes message;\n    /// @dev the gas limit is currently not used.\n    // FIXME: currently not used.\n    // uint256 gasLimit;\n}\n\n/// @notice Message format used for `Transfer` and `Call` messages.\nstruct CallMsg {\n    /// @dev Target method. A bytes4 function selector for EVM/Solidity targets, or a uint64 for Wasm actors.\n    bytes method;\n    /// @dev arguments of the method being called.\n    bytes params;\n}\n\n/// @notice This struct indicates if the cross message execution is sucess, IPC system error or from the invoked\n///         contract\nenum OutcomeType {\n    /// @dev The execution is successful, parse the return bytes according to the contract logic\n    Ok,\n    /// @dev The result is an IPC system error, parse the return bytes as an IPC error type.\n    SystemErr,\n    /// @dev The error is coming from the invoked contract, parse the return bytes according to\n    /// the contract logic\n    ActorErr\n}\n\nstruct ResultMsg {\n    /// @dev Id of the envelope the result belongs to.\n    bytes32 id;\n    /// @dev Flag to signal if the call succeeded or the type of the error\n    OutcomeType outcome;\n    /// @dev abi encoded return value, or the reason for the\n    /// failure (if any).\n    bytes ret;\n    //\n    // NOTE: In the future we may include events and other result information.\n}\n"
    },
    "contracts/ipc/structs/FvmAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\n/*\n * @dev The corresponding implementation of Fil Address from FVM.\n * Currently it supports only f1 addresses.\n * See: https://github.com/filecoin-project/ref-fvm/blob/db8c0b12c801f364e87bda6f52d00c6bd0e1b878/shared/src/address/payload.rs#L87\n */\nstruct FvmAddress {\n    uint8 addrType;\n    bytes payload;\n}\n\n/*\n * @dev The delegated f4 address in Fil Address from FVM.\n */\nstruct DelegatedAddress {\n    uint64 namespace;\n    uint128 length;\n    bytes buffer;\n}\n"
    },
    "contracts/ipc/structs/Quorum.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @notice A kind of quorum.\nenum QuorumObjKind {\n    Checkpoint,\n    BottomUpMsgBatch\n}\n\n/// @notice Checkpoint quorum information.\nstruct QuorumInfo {\n    /// @dev The hash of the corresponding bottom-up checkpoint.\n    bytes32 hash;\n    /// @dev The root hash of the Merkle tree built from the validator public keys and their weight.\n    bytes32 rootHash;\n    /// @dev The target weight that must be reached to accept the checkpoint.\n    uint256 threshold;\n    /// @dev The current weight of the checkpoint.\n    uint256 currentWeight;\n    /// @dev Whether the quorum has already been reached.\n    bool reached;\n}\n\n/// @notice A type aggregating quorum related information.\nstruct QuorumMap {\n    /// @notice flags the type of object we are running a quorum over.\n    QuorumObjKind quorumObjKind;\n    /// @notice The height of the first bottom-up checkpoint that must be retained since they have not been processed in the parent.\n    /// All checkpoint with the height less than this number may be garbage collected in the child subnet.\n    /// @dev Initial retention index is 1.\n    uint256 retentionHeight;\n    /// @notice A mapping of block numbers to quorum info\n    mapping(uint256 => QuorumInfo) quorumInfo;\n    /// @notice A list of incomplete checkpoints.\n    // slither-disable-next-line uninitialized-state\n    EnumerableSet.UintSet incompleteQuorums;\n    /// @notice The addresses of the validators that have already sent signatures at height `h`\n    mapping(uint256 => EnumerableSet.AddressSet) quorumSignatureSenders;\n    /// @notice The list of the collected signatures at height `h`\n    mapping(uint256 => mapping(address => bytes)) quorumSignatures;\n}\n"
    },
    "contracts/ipc/structs/Subnet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {FvmAddress} from \"./FvmAddress.sol\";\nimport {MaxPQ} from \"../lib/priority/LibMaxPQ.sol\";\nimport {MinPQ} from \"../lib/priority/LibMinPQ.sol\";\n\n/// @notice A subnet identity type.\nstruct SubnetID {\n    /// @notice chainID of the root subnet\n    uint64 root;\n    /// @notice parent path of the subnet\n    address[] route;\n}\n\n/// @notice A Subnet type.\nstruct Subnet {\n    uint256 stake;\n    uint256 genesisEpoch;\n    uint256 circSupply;\n    uint64 topDownNonce;\n    uint64 appliedBottomUpNonce;\n    SubnetID id;\n}\n\n/// @notice Subnet staking operations.\nenum StakingOperation {\n    Deposit,\n    Withdraw,\n    SetMetadata,\n    SetFederatedPower\n}\n\n/// @notice The change request to validator staking.\nstruct StakingChange {\n    StakingOperation op;\n    bytes payload;\n    address validator;\n}\n\n/// @notice The change associated with its corresponding configuration number.\nstruct StakingChangeRequest {\n    StakingChange change;\n    uint64 configurationNumber;\n}\n\n/// @notice The collection of staking changes.\nstruct StakingChangeLog {\n    /// @notice The next configuration number to assign to new changes.\n    uint64 nextConfigurationNumber;\n    /// @notice The starting configuration number stored.\n    uint64 startConfigurationNumber;\n    /// The details of the changes, mapping of configuration number to changes.\n    mapping(uint64 => StakingChange) changes;\n}\n\n/// @notice Each staking release amount and time.\nstruct StakingRelease {\n    /// @notice The block number that this fund can be released\n    uint256 releaseAt;\n    /// @notice The amount that is locked in the release\n    uint256 amount;\n}\n\n/// @notice Tracks the staking releases of an address.\n/// @dev    Mimics the implementation of array in solidity,\n///         this way is more aligned with our use case.\nstruct AddressStakingReleases {\n    uint16 length;\n    uint16 startIdx;\n    mapping(uint16 => StakingRelease) releases;\n}\n\n/// @notice Manages the staking release queue.\nstruct StakingReleaseQueue {\n    /// @notice The number of blocks that locks the collateral.\n    uint256 lockingDuration;\n    /// @notice Keeps track of the validators and their releases.\n    mapping(address => AddressStakingReleases) releases;\n}\n\n/// @notice Keeping track of the validator information.\n/// @dev There are two types of collaterals:\n///     - Confirmed: The amount of collateral actually confirmed in child subnet;\n///     - Total: Aside from Confirmed, there is also the collateral has been supplied, but not yet confirmed in child.\nstruct ValidatorInfo {\n    /// The power set by contract admin\n    uint256 federatedPower;\n    uint256 confirmedCollateral;\n    uint256 totalCollateral;\n    /// The metadata associated with the validator, i.e. off-chain network address.\n    /// This information is not important to the protocol, off-chain should know how\n    /// to parse or decode the bytes.\n    bytes metadata;\n}\n\n/// @notice Determines the permission mode for validators.\nenum PermissionMode {\n    /// Validator power is determined by the collateral staked\n    Collateral,\n    /// Validator power is assigned by the owner of the subnet\n    Federated,\n    /// Validator power is determined by the initial collateral staked and does not change anymore\n    Static\n}\n\n/// @notice Determines the permission mode for who can create subet\nenum SubnetCreationPrivileges {\n    /// No permission check at all, any address can create\n    Unrestricted,\n    /// Only the owner can create subnet\n    Owner\n}\n\n/// @notice Keeping track of the list of validators.\n/// @dev There are two types of validators:\n///     - Active\n///     - Waiting\n/// Active validators are those that are producing blocks in the child subnet.\n/// Waiting validators are those that do no have as high collateral as Active validators.\n///\n/// The max number of active validators is limited by `activeLimit` and the size of waiting\n/// validators is not bounded.\n///\n/// With each validator staking change, waiting validators can be promoted to active validators\n/// and active validators can be knocked off.\nstruct ValidatorSet {\n    /// The permission mode for validators\n    PermissionMode permissionMode;\n    /// The total number of active validators allowed.\n    uint16 activeLimit;\n    /// The total collateral confirmed.\n    uint256 totalConfirmedCollateral;\n    /// The mapping of each validator address to its information.\n    mapping(address => ValidatorInfo) validators;\n    /// @notice The active validators tracked using min priority queue.\n    MinPQ activeValidators;\n    /// @notice The waiting validators tracked using max priority queue.\n    MaxPQ waitingValidators;\n}\n\n/// @notice Tracks the parent validator changes and apply them in the child.\nstruct ParentValidatorsTracker {\n    ValidatorSet validators;\n    StakingChangeLog changes;\n}\n\n/// @notice An IPC address type.\nstruct IPCAddress {\n    SubnetID subnetId;\n    FvmAddress rawAddress;\n}\n\n/// @notice Validator struct stored in the gateway.\nstruct Validator {\n    uint256 weight;\n    address addr;\n    bytes metadata;\n}\n\n/// @notice Membership information stored in the gateway.\nstruct Membership {\n    Validator[] validators;\n    uint64 configurationNumber;\n}\n\n/// @notice Defines the supply source of a subnet on its parent subnet.\nstruct SupplySource {\n    /// @notice The kind of supply.\n    SupplyKind kind;\n    /// @notice The address of the ERC20 token if that supply kind is selected.\n    address tokenAddress;\n}\n\n/// @notice Determines the type of supply used by the subnet.\nenum SupplyKind {\n    Native,\n    ERC20\n}\n"
    },
    "contracts/ipc/subnet/SubnetActorCheckpointingFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {InvalidBatchEpoch, MaxMsgsPerBatchExceeded, InvalidSignatureErr, BottomUpCheckpointAlreadySubmitted, CannotSubmitFutureCheckpoint, InvalidCheckpointEpoch} from \"../errors/IPCErrors.sol\";\nimport {IGateway} from \"../interfaces/IGateway.sol\";\nimport {BottomUpCheckpoint, BottomUpMsgBatch, BottomUpMsgBatchInfo} from \"../structs/CrossNet.sol\";\nimport {Validator, ValidatorSet} from \"../structs/Subnet.sol\";\nimport {MultisignatureChecker} from \"../lib/LibMultisignatureChecker.sol\";\nimport {ReentrancyGuard} from \"../lib/LibReentrancyGuard.sol\";\nimport {SubnetActorModifiers} from \"../lib/LibSubnetActorStorage.sol\";\nimport {LibValidatorSet, LibStaking} from \"../lib/LibStaking.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {LibSubnetActor} from \"../lib/LibSubnetActor.sol\";\nimport {Pausable} from \"../lib/LibPausable.sol\";\nimport {LibGateway} from \"../lib/LibGateway.sol\";\n\ncontract SubnetActorCheckpointingFacet is\n    SubnetActorModifiers,\n    ReentrancyGuard,\n    Pausable\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using LibValidatorSet for ValidatorSet;\n\n    /// @notice Submits a checkpoint commitment for execution.\n    /// @dev    It triggers the commitment of the checkpoint and any other side-effects that\n    ///         need to be triggered by the checkpoint such as relayer reward book keeping.\n    /// @param checkpoint The executed bottom-up checkpoint.\n    /// @param signatories The addresses of validators signing the checkpoint.\n    /// @param signatures The signatures of validators on the checkpoint.\n    function submitCheckpoint(\n        BottomUpCheckpoint calldata checkpoint,\n        address[] calldata signatories,\n        bytes[] calldata signatures\n    ) external whenNotPaused {\n        ensureValidCheckpoint(checkpoint);\n\n        bytes32 checkpointHash = keccak256(abi.encode(checkpoint));\n\n        // validate signatures and quorum threshold, revert if validation fails\n        validateActiveQuorumSignatures({\n            signatories: signatories,\n            hash: checkpointHash,\n            signatures: signatures\n        });\n\n        // If the checkpoint height is the next expected height then this is a new checkpoint which must be executed\n        // in the Gateway Actor, the checkpoint and the relayer must be stored, last bottom-up checkpoint updated.\n        s.committedCheckpoints[checkpoint.blockHeight] = checkpoint;\n\n        s.lastBottomUpCheckpointHeight = checkpoint.blockHeight;\n\n        // Commit in gateway to distribute rewards\n        IGateway(s.ipcGatewayAddr).commitCheckpoint(checkpoint);\n\n        // confirming the changes in membership in the child\n        LibStaking.confirmChange(checkpoint.nextConfigurationNumber);\n    }\n\n    /// @notice Checks whether the signatures are valid for the provided signatories and hash within the current validator set.\n    ///         Reverts otherwise.\n    /// @dev Signatories in `signatories` and their signatures in `signatures` must be provided in the same order.\n    ///       Having it public allows external users to perform sanity-check verification if needed.\n    /// @param signatories The addresses of the signatories.\n    /// @param hash The hash of the checkpoint.\n    /// @param signatures The packed signatures of the checkpoint.\n    function validateActiveQuorumSignatures(\n        address[] memory signatories,\n        bytes32 hash,\n        bytes[] memory signatures\n    ) public view {\n        // This call reverts if at least one of the signatories (validator) is not in the active validator set.\n        uint256[] memory collaterals = s.validatorSet.getTotalPowerOfValidators(\n            signatories\n        );\n        uint256 activeCollateral = s.validatorSet.getTotalActivePower();\n\n        uint256 threshold = (activeCollateral * s.majorityPercentage) / 100;\n\n        (bool valid, MultisignatureChecker.Error err) = MultisignatureChecker\n            .isValidWeightedMultiSignature({\n                signatories: signatories,\n                weights: collaterals,\n                threshold: threshold,\n                hash: hash,\n                signatures: signatures\n            });\n\n        if (!valid) {\n            revert InvalidSignatureErr(uint8(err));\n        }\n    }\n\n    /// @notice Ensures the checkpoint is valid.\n    /// @dev The checkpoint block height must be equal to the last bottom-up checkpoint height or\n    /// @dev the next one or the number of bottom up messages exceeds the max batch size.\n    function ensureValidCheckpoint(\n        BottomUpCheckpoint calldata checkpoint\n    ) internal view {\n        uint64 maxMsgsPerBottomUpBatch = s.maxMsgsPerBottomUpBatch;\n        if (checkpoint.msgs.length > maxMsgsPerBottomUpBatch) {\n            revert MaxMsgsPerBatchExceeded();\n        }\n\n        uint256 lastBottomUpCheckpointHeight = s.lastBottomUpCheckpointHeight;\n        uint256 bottomUpCheckPeriod = s.bottomUpCheckPeriod;\n\n        // cannot submit past bottom up checkpoint\n        if (checkpoint.blockHeight <= lastBottomUpCheckpointHeight) {\n            revert BottomUpCheckpointAlreadySubmitted();\n        }\n\n        uint256 nextCheckpointHeight = LibGateway.getNextEpoch(\n            lastBottomUpCheckpointHeight,\n            bottomUpCheckPeriod\n        );\n\n        if (checkpoint.blockHeight > nextCheckpointHeight) {\n            revert CannotSubmitFutureCheckpoint();\n        }\n\n        // the expected bottom up checkpoint height, valid height\n        if (checkpoint.blockHeight == nextCheckpointHeight) {\n            return;\n        }\n\n        // if the bottom up messages' length is max, we consider that epoch valid, allow early submission\n        if (checkpoint.msgs.length == s.maxMsgsPerBottomUpBatch) {\n            return;\n        }\n\n        revert InvalidCheckpointEpoch();\n    }\n}\n"
    },
    "contracts/ipc/subnet/SubnetActorGetterFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {ConsensusType} from \"../enums/ConsensusType.sol\";\nimport {BottomUpCheckpoint, IpcEnvelope} from \"../structs/CrossNet.sol\";\nimport {SubnetID, SupplySource} from \"../structs/Subnet.sol\";\nimport {SubnetID, ValidatorInfo, Validator, PermissionMode} from \"../structs/Subnet.sol\";\nimport {SubnetActorStorage} from \"../lib/LibSubnetActorStorage.sol\";\nimport {SubnetIDHelper} from \"../lib/SubnetIDHelper.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {LibStaking} from \"../lib/LibStaking.sol\";\n\ncontract SubnetActorGetterFacet {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using SubnetIDHelper for SubnetID;\n    using Address for address payable;\n\n    // slither-disable-next-line uninitialized-state\n    SubnetActorStorage internal s;\n\n    /// @notice Returns the parent subnet id.\n    function getParent() external view returns (SubnetID memory) {\n        return s.parentId;\n    }\n\n    /// @notice Returns the permission mode.\n    function permissionMode() external view returns (PermissionMode) {\n        return s.validatorSet.permissionMode;\n    }\n\n    /// @notice Returns the gateway address.\n    function ipcGatewayAddr() external view returns (address) {\n        return s.ipcGatewayAddr;\n    }\n\n    /// @notice Returns the minimum validators number needed to activate the subnet.\n    function minValidators() external view returns (uint64) {\n        return s.minValidators;\n    }\n\n    /// @notice Returns the majority percentage required for consensus.\n    function majorityPercentage() external view returns (uint8) {\n        return s.majorityPercentage;\n    }\n\n    /// @notice Fetches the limit on the number of active validators.\n    function activeValidatorsLimit() external view returns (uint16) {\n        return s.validatorSet.activeLimit;\n    }\n\n    /// @notice Returns the next and start configuration numbers related to the changes.\n    function getConfigurationNumbers() external view returns (uint64, uint64) {\n        return (\n            s.changeSet.nextConfigurationNumber,\n            s.changeSet.startConfigurationNumber\n        );\n    }\n\n    /// @notice Returns the initial set of validators of the genesis block.\n    function genesisValidators() external view returns (Validator[] memory) {\n        return s.genesisValidators;\n    }\n\n    // @notice Provides the circulating supply of the genesis block.\n    function genesisCircSupply() external view returns (uint256) {\n        return s.genesisCircSupply;\n    }\n\n    /// @notice Retrieves initial balances and corresponding addresses of the genesis block.\n    function genesisBalances()\n        external\n        view\n        returns (address[] memory, uint256[] memory)\n    {\n        uint256 numAddresses = s.genesisBalanceKeys.length;\n        address[] memory addresses = new address[](numAddresses);\n        uint256[] memory balances = new uint256[](numAddresses);\n\n        for (uint256 i; i < numAddresses; ) {\n            address addr = s.genesisBalanceKeys[i];\n            addresses[i] = addr;\n            balances[i] = s.genesisBalance[addr];\n\n            unchecked {\n                ++i;\n            }\n        }\n        return (addresses, balances);\n    }\n\n    /// @notice Returns the period for bottom-up checkpointing operations.\n    function bottomUpCheckPeriod() external view returns (uint256) {\n        return s.bottomUpCheckPeriod;\n    }\n\n    /// @notice Returns the block height of the last bottom-up checkpoint.\n    function lastBottomUpCheckpointHeight() external view returns (uint256) {\n        return s.lastBottomUpCheckpointHeight;\n    }\n\n    /// @notice Returns the consensus protocol type used in the subnet.\n    function consensus() external view returns (ConsensusType) {\n        return s.consensus;\n    }\n\n    /// @notice Checks if the subnet has been bootstrapped.\n    function bootstrapped() external view returns (bool) {\n        return s.bootstrapped;\n    }\n\n    /// @notice Checks if the subnet has been terminated or \"killed\".\n    function killed() external view returns (bool) {\n        return s.killed;\n    }\n\n    /// @notice Returns the minimum collateral required for subnet activation.\n    function minActivationCollateral() external view returns (uint256) {\n        return s.minActivationCollateral;\n    }\n\n    /// @notice Returns detailed information about a specific validator.\n    /// @param validatorAddress The address of the validator to query information for.\n    function getValidator(\n        address validatorAddress\n    ) external view returns (ValidatorInfo memory validator) {\n        validator = s.validatorSet.validators[validatorAddress];\n    }\n\n    /// @notice Returns the total number of validators (active and waiting).\n    function getTotalValidatorsNumber() external view returns (uint16) {\n        return LibStaking.totalValidators();\n    }\n\n    /// @notice Returns the number of active validators.\n    function getActiveValidatorsNumber() external view returns (uint16) {\n        return LibStaking.totalActiveValidators();\n    }\n\n    /// @notice Returns the total amount of confirmed collateral across all validators.\n    function getTotalConfirmedCollateral() external view returns (uint256) {\n        return LibStaking.getTotalConfirmedCollateral();\n    }\n\n    /// @notice Returns the total collateral held by all validators.\n    function getTotalCollateral() external view returns (uint256) {\n        return LibStaking.getTotalCollateral();\n    }\n\n    /// @notice Returns the total collateral amount for a specific validator.\n    /// @param validator The address of the validator for which collateral is queried.\n    function getTotalValidatorCollateral(\n        address validator\n    ) external view returns (uint256) {\n        return LibStaking.totalValidatorCollateral(validator);\n    }\n\n    /// @notice Checks if the validator address is in an active state.\n    /// @param validator The address of the checked validator\n    function getPower(address validator) external view returns (uint256) {\n        return LibStaking.getPower(validator);\n    }\n\n    /// @notice Checks if the validator address is an active validator\n    function isActiveValidator(address validator) external view returns (bool) {\n        return LibStaking.isActiveValidator(validator);\n    }\n\n    /// @notice Checks if the validator is in a waiting state.\n    /// @param validator The address of the checked validator.\n    function isWaitingValidator(\n        address validator\n    ) external view returns (bool) {\n        return LibStaking.isWaitingValidator(validator);\n    }\n\n    /// @notice returns the committed bottom-up checkpoint at specific epoch.\n    /// @param epoch - the epoch to check.\n    /// @return exists - whether the checkpoint exists.\n    /// @return checkpoint - the checkpoint struct.\n    function bottomUpCheckpointAtEpoch(\n        uint256 epoch\n    ) public view returns (bool exists, BottomUpCheckpoint memory checkpoint) {\n        checkpoint = s.committedCheckpoints[epoch];\n        exists = !checkpoint.subnetID.isEmpty();\n        return (exists, checkpoint);\n    }\n\n    /// @notice returns the historical committed bottom-up checkpoint hash.\n    /// @param epoch - the epoch to check\n    /// @return exists - whether the checkpoint exists\n    /// @return hash - the hash of the checkpoint\n    function bottomUpCheckpointHashAtEpoch(\n        uint256 epoch\n    ) external view returns (bool, bytes32) {\n        (\n            bool exists,\n            BottomUpCheckpoint memory checkpoint\n        ) = bottomUpCheckpointAtEpoch(epoch);\n        return (exists, keccak256(abi.encode(checkpoint)));\n    }\n\n    /// @notice Returns the power scale in number of decimals from whole FIL.\n    function powerScale() external view returns (int8) {\n        return s.powerScale;\n    }\n\n    /// @notice Returns the bootstrap nodes addresses.\n    function getBootstrapNodes() external view returns (string[] memory) {\n        uint256 n = s.bootstrapOwners.length();\n        string[] memory nodes = new string[](n);\n        if (n == 0) {\n            return nodes;\n        }\n        address[] memory owners = s.bootstrapOwners.values();\n        for (uint256 i; i < n; ) {\n            nodes[i] = s.bootstrapNodes[owners[i]];\n            unchecked {\n                ++i;\n            }\n        }\n        return nodes;\n    }\n\n    /// @notice Computes a hash of an array of IpcEnvelopes.\n    /// @dev This exists for testing purposes.\n    /// @param messages An array of cross-chain envelopes to be hashed.\n    /// @return The keccak256 hash of the encoded cross-chain messages.\n    function crossMsgsHash(\n        IpcEnvelope[] calldata messages\n    ) external pure returns (bytes32) {\n        return keccak256(abi.encode(messages));\n    }\n\n    /// @notice Returns the supply strategy for the subnet.\n    function supplySource() external view returns (SupplySource memory supply) {\n        return s.supplySource;\n    }\n}\n"
    },
    "contracts/ipc/subnet/SubnetActorManagerFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {VALIDATOR_SECP256K1_PUBLIC_KEY_LENGTH} from \"../constants/Constants.sol\";\nimport {ERR_VALIDATOR_JOINED, ERR_VALIDATOR_NOT_JOINED} from \"../errors/IPCErrors.sol\";\nimport {InvalidFederationPayload, SubnetAlreadyBootstrapped, NotEnoughFunds, CollateralIsZero, CannotReleaseZero, NotOwnerOfPublicKey, EmptyAddress, NotEnoughBalance, NotEnoughCollateral, NotValidator, NotAllValidatorsHaveLeft, InvalidPublicKeyLength, MethodNotAllowed, SubnetNotBootstrapped} from \"../errors/IPCErrors.sol\";\nimport {IGateway} from \"../interfaces/IGateway.sol\";\nimport {Validator, ValidatorSet} from \"../structs/Subnet.sol\";\nimport {LibDiamond} from \"../lib/LibDiamond.sol\";\nimport {ReentrancyGuard} from \"../lib/LibReentrancyGuard.sol\";\nimport {SubnetActorModifiers} from \"../lib/LibSubnetActorStorage.sol\";\nimport {LibValidatorSet, LibStaking} from \"../lib/LibStaking.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\nimport {LibSubnetActor} from \"../lib/LibSubnetActor.sol\";\nimport {Pausable} from \"../lib/LibPausable.sol\";\n\ncontract SubnetActorManagerFacet is\n    SubnetActorModifiers,\n    ReentrancyGuard,\n    Pausable\n{\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using LibValidatorSet for ValidatorSet;\n    using Address for address payable;\n\n    /// @notice method to add some initial balance into a subnet that hasn't yet bootstrapped.\n    /// @dev This balance is added to user addresses in genesis, and becomes part of the genesis\n    /// circulating supply.\n    function preFund() external payable {\n        if (msg.value == 0) {\n            revert NotEnoughFunds();\n        }\n\n        if (s.bootstrapped) {\n            revert SubnetAlreadyBootstrapped();\n        }\n\n        if (s.genesisBalance[msg.sender] == 0) {\n            s.genesisBalanceKeys.push(msg.sender);\n        }\n\n        s.genesisBalance[msg.sender] += msg.value;\n        s.genesisCircSupply += msg.value;\n    }\n\n    /// @notice method to remove funds from the initial balance of a subnet.\n    /// @dev This method can be used by users looking to recover part of their\n    /// initial balance before the subnet bootstraps.\n    /// @param amount The amount to remove.\n    function preRelease(uint256 amount) external nonReentrant {\n        if (amount == 0) {\n            revert NotEnoughFunds();\n        }\n\n        if (s.bootstrapped) {\n            revert SubnetAlreadyBootstrapped();\n        }\n\n        if (s.genesisBalance[msg.sender] < amount) {\n            revert NotEnoughBalance();\n        }\n\n        s.genesisBalance[msg.sender] -= amount;\n        s.genesisCircSupply -= amount;\n\n        if (s.genesisBalance[msg.sender] == 0) {\n            LibSubnetActor.rmAddressFromBalanceKey(msg.sender);\n        }\n\n        payable(msg.sender).sendValue(amount);\n    }\n\n    /// @notice Sets the federated power of validators.\n    /// @dev method that allows the contract owner to set the validators' federated power.\n    /// @param validators The addresses of validators.\n    /// @param publicKeys The public keys of validators.\n    /// @param powers The federated powers to be assigned to validators.\n    function setFederatedPower(\n        address[] calldata validators,\n        bytes[] calldata publicKeys,\n        uint256[] calldata powers\n    ) external notKilled {\n        LibDiamond.enforceIsContractOwner();\n\n        LibSubnetActor.enforceFederatedValidation();\n\n        if (validators.length != powers.length) {\n            revert InvalidFederationPayload();\n        }\n\n        if (validators.length != publicKeys.length) {\n            revert InvalidFederationPayload();\n        }\n\n        if (s.bootstrapped) {\n            LibSubnetActor.postBootstrapSetFederatedPower({\n                validators: validators,\n                publicKeys: publicKeys,\n                powers: powers\n            });\n        } else {\n            LibSubnetActor.preBootstrapSetFederatedPower({\n                validators: validators,\n                publicKeys: publicKeys,\n                powers: powers\n            });\n        }\n    }\n\n    /// @notice method that allows a validator to join the subnet.\n    ///         If the total confirmed collateral of the subnet is greater\n    ///         or equal to minimum activation collateral as a result of this operation,\n    ///         then  subnet will be registered.\n    /// @param publicKey The off-chain 65 byte public key that should be associated with the validator\n    function join(\n        bytes calldata publicKey\n    ) external payable nonReentrant whenNotPaused notKilled {\n        // Adding this check to prevent new validators from joining\n        // after the subnet has been bootstrapped, if the subnet mode is not Collateral.\n        // We will increase the functionality in the future to support explicit permissioning.\n        if (s.bootstrapped) {\n            LibSubnetActor.enforceCollateralValidation();\n        }\n        if (msg.value == 0) {\n            revert CollateralIsZero();\n        }\n\n        if (LibStaking.isValidator(msg.sender)) {\n            revert MethodNotAllowed(ERR_VALIDATOR_JOINED);\n        }\n\n        if (publicKey.length != VALIDATOR_SECP256K1_PUBLIC_KEY_LENGTH) {\n            // Taking 65 bytes because the FVM libraries have some assertions checking it, it's more convenient.\n            revert InvalidPublicKeyLength();\n        }\n\n        address convertedAddress = LibSubnetActor.publicKeyToAddress(publicKey);\n        if (convertedAddress != msg.sender) {\n            revert NotOwnerOfPublicKey();\n        }\n\n        if (!s.bootstrapped) {\n            // if the subnet has not been bootstrapped, join directly\n            // without delays, and collect collateral to register\n            // in the gateway\n\n            // confirm validators deposit immediately\n            LibStaking.setMetadataWithConfirm(msg.sender, publicKey);\n            LibStaking.depositWithConfirm(msg.sender, msg.value);\n\n            LibSubnetActor.bootstrapSubnetIfNeeded();\n        } else {\n            // if the subnet has been bootstrapped, join with postponed confirmation.\n            LibStaking.setValidatorMetadata(msg.sender, publicKey);\n            LibStaking.deposit(msg.sender, msg.value);\n        }\n    }\n\n    /// @notice method that allows a validator to increase its stake.\n    ///         If the total confirmed collateral of the subnet is greater\n    ///         or equal to minimum activation collateral as a result of this operation,\n    ///         then  subnet will be registered.\n    function stake() external payable whenNotPaused notKilled {\n        // disabling validator changes for federated subnets (at least for now\n        // until a more complex mechanism is implemented).\n        LibSubnetActor.enforceCollateralValidation();\n        if (msg.value == 0) {\n            revert CollateralIsZero();\n        }\n\n        if (!LibStaking.isValidator(msg.sender)) {\n            revert MethodNotAllowed(ERR_VALIDATOR_NOT_JOINED);\n        }\n\n        if (!s.bootstrapped) {\n            LibStaking.depositWithConfirm(msg.sender, msg.value);\n\n            LibSubnetActor.bootstrapSubnetIfNeeded();\n        } else {\n            LibStaking.deposit(msg.sender, msg.value);\n        }\n    }\n\n    /// @notice method that allows a validator to unstake a part of its collateral from a subnet.\n    /// @dev `leave` must be used to unstake the entire stake.\n    /// @param amount The amount to unstake.\n    function unstake(\n        uint256 amount\n    ) external nonReentrant whenNotPaused notKilled {\n        // disbling validator changes for federated validation subnets (at least for now\n        // until a more complex mechanism is implemented).\n        LibSubnetActor.enforceCollateralValidation();\n\n        if (amount == 0) {\n            revert CannotReleaseZero();\n        }\n\n        uint256 collateral = LibStaking.totalValidatorCollateral(msg.sender);\n\n        if (collateral == 0) {\n            revert NotValidator(msg.sender);\n        }\n        if (collateral <= amount) {\n            revert NotEnoughCollateral();\n        }\n        if (!s.bootstrapped) {\n            LibStaking.withdrawWithConfirm(msg.sender, amount);\n            return;\n        }\n\n        LibStaking.withdraw(msg.sender, amount);\n    }\n\n    /// @notice method that allows a validator to leave the subnet.\n    function leave() external nonReentrant whenNotPaused notKilled {\n        // disbling validator changes for federated subnets (at least for now\n        // until a more complex mechanism is implemented).\n        // This means that initial validators won't be able to recover\n        // their collateral ever (worth noting in the docs if this ends\n        // up sticking around for a while).\n        if (s.bootstrapped) {\n            LibSubnetActor.enforceCollateralValidation();\n        }\n\n        // remove bootstrap nodes added by this validator\n        uint256 amount = LibStaking.totalValidatorCollateral(msg.sender);\n        if (amount == 0) {\n            revert NotValidator(msg.sender);\n        }\n\n        // slither-disable-next-line unused-return\n        s.bootstrapOwners.remove(msg.sender);\n        delete s.bootstrapNodes[msg.sender];\n\n        if (!s.bootstrapped) {\n            // check if the validator had some initial balance and return it if not bootstrapped\n            uint256 genesisBalance = s.genesisBalance[msg.sender];\n            if (genesisBalance != 0) {\n                s.genesisBalance[msg.sender] == 0;\n                s.genesisCircSupply -= genesisBalance;\n                LibSubnetActor.rmAddressFromBalanceKey(msg.sender);\n                payable(msg.sender).sendValue(genesisBalance);\n            }\n\n            // interaction must be performed after checks and changes\n            LibStaking.withdrawWithConfirm(msg.sender, amount);\n            return;\n        }\n        LibStaking.withdraw(msg.sender, amount);\n    }\n\n    /// @notice method that allows to kill the subnet when all validators left.\n    /// @dev It is not a privileged operation.\n    function kill() external notKilled {\n        if (LibStaking.totalValidators() != 0) {\n            revert NotAllValidatorsHaveLeft();\n        }\n        if (!s.bootstrapped) {\n            revert SubnetNotBootstrapped();\n        }\n        s.killed = true;\n        IGateway(s.ipcGatewayAddr).kill();\n    }\n\n    /// @notice Add a bootstrap node.\n    /// @param netAddress The network address of the new bootstrap node.\n    function addBootstrapNode(string memory netAddress) external whenNotPaused {\n        if (!s.validatorSet.isActiveValidator(msg.sender)) {\n            revert NotValidator(msg.sender);\n        }\n        if (bytes(netAddress).length == 0) {\n            revert EmptyAddress();\n        }\n        s.bootstrapNodes[msg.sender] = netAddress;\n        // slither-disable-next-line unused-return\n        s.bootstrapOwners.add(msg.sender);\n    }\n}\n"
    },
    "contracts/ipc/subnet/SubnetActorRewardFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {QuorumObjKind} from \"../structs/Quorum.sol\";\nimport {Pausable} from \"../lib/LibPausable.sol\";\nimport {ReentrancyGuard} from \"../lib/LibReentrancyGuard.sol\";\nimport {SubnetActorModifiers} from \"../lib/LibSubnetActorStorage.sol\";\nimport {LibStaking} from \"../lib/LibStaking.sol\";\nimport {LibSubnetActor} from \"../lib/LibSubnetActor.sol\";\n\ncontract SubnetActorRewardFacet is SubnetActorModifiers, ReentrancyGuard, Pausable {\n    /// @notice Validator claims their released collateral.\n    function claim() external nonReentrant whenNotPaused {\n        LibStaking.claimCollateral(msg.sender);\n    }\n}\n"
    },
    "contracts/ipc/SubnetActorDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {SubnetActorStorage} from \"./lib/LibSubnetActorStorage.sol\";\nimport {ConsensusType} from \"./enums/ConsensusType.sol\";\nimport {IDiamond} from \"./interfaces/IDiamond.sol\";\nimport {IDiamondCut} from \"./interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"./interfaces/IDiamondLoupe.sol\";\nimport {IERC165} from \"./interfaces/IERC165.sol\";\nimport {GatewayCannotBeZero, NotGateway, InvalidSubmissionPeriod, InvalidCollateral, InvalidMajorityPercentage, InvalidPowerScale} from \"./errors/IPCErrors.sol\";\nimport {BATCH_PERIOD, MAX_MSGS_PER_BATCH} from \"./structs/CrossNet.sol\";\nimport {LibDiamond} from \"./lib/LibDiamond.sol\";\nimport {PermissionMode, SubnetID, SupplyKind, SupplySource} from \"./structs/Subnet.sol\";\nimport {SubnetIDHelper} from \"./lib/SubnetIDHelper.sol\";\nimport {LibStaking} from \"./lib/LibStaking.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SupplySourceHelper} from \"./lib/SupplySourceHelper.sol\";\nerror FunctionNotFound(bytes4 _functionSelector);\n\ncontract SubnetActorDiamond {\n    SubnetActorStorage internal s;\n\n    using SubnetIDHelper for SubnetID;\n    using SupplySourceHelper for SupplySource;\n\n    struct ConstructorParams {\n        uint256 minActivationCollateral;\n        uint64 minValidators;\n        uint64 bottomUpCheckPeriod;\n        address ipcGatewayAddr;\n        uint16 activeValidatorsLimit;\n        uint8 majorityPercentage;\n        ConsensusType consensus;\n        int8 powerScale;\n        PermissionMode permissionMode;\n        SupplySource supplySource;\n        SubnetID parentId;\n    }\n\n    constructor(\n        IDiamond.FacetCut[] memory _diamondCut,\n        ConstructorParams memory params,\n        address owner\n    ) {\n        if (params.ipcGatewayAddr == address(0)) {\n            revert GatewayCannotBeZero();\n        }\n        // The bottomUpCheckPeriod should be non-zero for now.\n        if (params.bottomUpCheckPeriod == 0) {\n            revert InvalidSubmissionPeriod();\n        }\n        if (\n            params.permissionMode != PermissionMode.Federated &&\n            params.minActivationCollateral == 0\n        ) {\n            revert InvalidCollateral();\n        }\n        if (params.majorityPercentage < 51 || params.majorityPercentage > 100) {\n            revert InvalidMajorityPercentage();\n        }\n        if (params.powerScale > 18) {\n            revert InvalidPowerScale();\n        }\n\n        params.supplySource.validate();\n\n        LibDiamond.setContractOwner(owner);\n        LibDiamond.diamondCut({\n            _diamondCut: _diamondCut,\n            _init: address(0),\n            _calldata: new bytes(0)\n        });\n\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        // adding ERC165 data\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n\n        if (params.permissionMode == PermissionMode.Federated) {\n            // ignore min activation collateral for now\n            params.minActivationCollateral = 0;\n        }\n\n        s.parentId = params.parentId;\n        s.ipcGatewayAddr = params.ipcGatewayAddr;\n        s.consensus = params.consensus;\n        s.minActivationCollateral = params.minActivationCollateral;\n        s.minValidators = params.minValidators;\n        s.bottomUpCheckPeriod = params.bottomUpCheckPeriod;\n        s.majorityPercentage = params.majorityPercentage;\n        s.powerScale = params.powerScale;\n        s.currentSubnetHash = s.parentId.createSubnetId(address(this)).toHash();\n        s.validatorSet.permissionMode = params.permissionMode;\n\n        // BottomUpMsgBatch config parameters.\n        // NOTE: Let's fix them for now, but we could make them configurable\n        // through the gateway constructor in the future.\n        s.maxMsgsPerBottomUpBatch = MAX_MSGS_PER_BATCH;\n\n        s.validatorSet.activeLimit = params.activeValidatorsLimit;\n        // Start the next configuration number from 1, 0 is reserved for no change and the genesis membership\n        s.changeSet.nextConfigurationNumber = LibStaking\n            .INITIAL_CONFIGURATION_NUMBER;\n        // The startConfiguration number is also 1 to match with nextConfigurationNumber, indicating we have\n        // empty validator change logs\n        s.changeSet.startConfigurationNumber = LibStaking\n            .INITIAL_CONFIGURATION_NUMBER;\n        // Set the supply strategy.\n        s.supplySource = params.supplySource;\n    }\n\n    function _fallback() internal {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        // slither-disable-next-line assembly\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds\n            .facetAddressAndSelectorPosition[msg.sig]\n            .facetAddress;\n        if (facet == address(0)) {\n            revert FunctionNotFound(msg.sig);\n        }\n        // Execute external function from facet using delegatecall and return any value.\n        // slither-disable-next-line assembly\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /// @notice Will run when no functions matches call data\n    fallback() external payable {\n        _fallback();\n    }\n\n    /// @notice Same as fallback but called when calldata is empty\n    /* solhint-disable no-empty-blocks */\n    receive() external payable onlyGateway {\n        // The function body is empty since here we are implementing Diamond mechanism.\n    }\n\n    /* solhint-enable no-empty-blocks */\n\n    function _onlyGateway() private view {\n        if (msg.sender != s.ipcGatewayAddr) {\n            revert NotGateway();\n        }\n    }\n\n    modifier onlyGateway() {\n        _onlyGateway();\n        _;\n    }\n}\n"
    },
    "contracts/ipc/subnetregistry/RegisterSubnetFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {IDiamond} from \"../interfaces/IDiamond.sol\";\nimport {SubnetActorDiamond} from \"../SubnetActorDiamond.sol\";\nimport {SubnetRegistryActorStorage} from \"../lib/LibSubnetRegistryStorage.sol\";\n\nimport {ReentrancyGuard} from \"../lib/LibReentrancyGuard.sol\";\nimport {WrongGateway} from \"../errors/IPCErrors.sol\";\n\nimport {SubnetCreationPrivileges} from \"../structs/Subnet.sol\";\nimport {LibDiamond} from \"../lib/LibDiamond.sol\";\n\ncontract RegisterSubnetFacet is ReentrancyGuard {\n    SubnetRegistryActorStorage internal s;\n\n    /// @notice Event emitted when a new subnet is deployed.\n    event SubnetDeployed(address subnetAddr);\n\n    /// @notice Deploys a new subnet actor.\n    /// @param _params The constructor params for Subnet Actor Diamond.\n    function newSubnetActor(\n        SubnetActorDiamond.ConstructorParams calldata _params\n    ) external nonReentrant returns (address subnetAddr) {\n        if (_params.ipcGatewayAddr != s.GATEWAY) {\n            revert WrongGateway();\n        }\n\n        ensurePrivileges();\n\n        IDiamond.FacetCut[] memory diamondCut = new IDiamond.FacetCut[](8);\n\n        // set the diamond cut for subnet getter\n        diamondCut[0] = IDiamond.FacetCut({\n            facetAddress: s.SUBNET_ACTOR_GETTER_FACET,\n            action: IDiamond.FacetCutAction.Add,\n            functionSelectors: s.subnetActorGetterSelectors\n        });\n\n        // set the diamond cut for subnet manager\n        diamondCut[1] = IDiamond.FacetCut({\n            facetAddress: s.SUBNET_ACTOR_MANAGER_FACET,\n            action: IDiamond.FacetCutAction.Add,\n            functionSelectors: s.subnetActorManagerSelectors\n        });\n\n        diamondCut[2] = IDiamond.FacetCut({\n            facetAddress: s.SUBNET_ACTOR_REWARD_FACET,\n            action: IDiamond.FacetCutAction.Add,\n            functionSelectors: s.subnetActorRewarderSelectors\n        });\n\n        diamondCut[3] = IDiamond.FacetCut({\n            facetAddress: s.SUBNET_ACTOR_CHECKPOINTING_FACET,\n            action: IDiamond.FacetCutAction.Add,\n            functionSelectors: s.subnetActorCheckpointerSelectors\n        });\n\n        diamondCut[4] = IDiamond.FacetCut({\n            facetAddress: s.SUBNET_ACTOR_PAUSE_FACET,\n            action: IDiamond.FacetCutAction.Add,\n            functionSelectors: s.subnetActorPauserSelectors\n        });\n\n        diamondCut[5] = IDiamond.FacetCut({\n            facetAddress: s.SUBNET_ACTOR_DIAMOND_CUT_FACET,\n            action: IDiamond.FacetCutAction.Add,\n            functionSelectors: s.subnetActorDiamondCutSelectors\n        });\n\n        diamondCut[6] = IDiamond.FacetCut({\n            facetAddress: s.SUBNET_ACTOR_LOUPE_FACET,\n            action: IDiamond.FacetCutAction.Add,\n            functionSelectors: s.subnetActorDiamondLoupeSelectors\n        });\n\n        diamondCut[7] = IDiamond.FacetCut({\n            facetAddress: s.SUBNET_ACTOR_OWNERSHIP_FACET,\n            action: IDiamond.FacetCutAction.Add,\n            functionSelectors: s.subnetActorOwnershipSelectors\n        });\n\n        // slither-disable-next-line reentrancy-benign\n        subnetAddr = address(new SubnetActorDiamond(diamondCut, _params, msg.sender));\n\n        //nonces start with 1, similar to eip 161\n        ++s.userNonces[msg.sender];\n        s.subnets[msg.sender][s.userNonces[msg.sender]] = subnetAddr;\n\n        emit SubnetDeployed(subnetAddr);\n\n        return subnetAddr;\n    }\n\n    function ensurePrivileges() internal view {\n        if (s.creationPrivileges == SubnetCreationPrivileges.Unrestricted) {\n            return;\n        }\n        LibDiamond.enforceIsContractOwner();\n    }\n}\n"
    },
    "contracts/ipc/subnetregistry/SubnetGetterFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\nimport {SubnetRegistryActorStorage} from \"../lib/LibSubnetRegistryStorage.sol\";\nimport {CannotFindSubnet, FacetCannotBeZero} from \"../errors/IPCErrors.sol\";\nimport {LibDiamond} from \"../lib/LibDiamond.sol\";\n\ncontract SubnetGetterFacet {\n    // slither-disable-next-line uninitialized-state\n    SubnetRegistryActorStorage internal s;\n\n    /// @notice Returns the address of the latest subnet actor deployed by a user.\n    /// @param owner The address of the user whose latest subnet deployment is queried.\n    function latestSubnetDeployed(address owner) external view returns (address subnet) {\n        uint64 nonce = s.userNonces[owner];\n        if (nonce == 0) {\n            revert CannotFindSubnet();\n        }\n\n        subnet = s.subnets[owner][nonce];\n        if (subnet == address(0)) {\n            revert CannotFindSubnet();\n        }\n    }\n\n    /// @notice Returns the address of a subnet actor deployed for a specific nonce by a user.\n    /// @param owner The address of the user whose subnet deployment is queried.\n    /// @param nonce The specific nonce associated with the subnet deployment.\n    function getSubnetDeployedByNonce(address owner, uint64 nonce) external view returns (address subnet) {\n        if (nonce == 0) {\n            revert CannotFindSubnet();\n        }\n        subnet = s.subnets[owner][nonce];\n        if (subnet == address(0)) {\n            revert CannotFindSubnet();\n        }\n    }\n\n    /// @notice Returns the last nonce used by the owner.\n    /// @param user The address of the user whose last nonce is being queried.\n    function getUserLastNonce(address user) external view returns (uint64 nonce) {\n        nonce = s.userNonces[user];\n        if (nonce == 0) {\n            revert CannotFindSubnet();\n        }\n    }\n\n    /// @notice Returns the gateway.\n    function getGateway() external view returns (address) {\n        return s.GATEWAY;\n    }\n\n    /// @notice Returns the address of the SUBNET_GETTER_FACET.\n    function getSubnetActorGetterFacet() external view returns (address) {\n        return s.SUBNET_ACTOR_GETTER_FACET;\n    }\n\n    /// @notice Returns the address of the SUBNET_MANAGER_FACET.\n    function getSubnetActorManagerFacet() external view returns (address) {\n        return s.SUBNET_ACTOR_MANAGER_FACET;\n    }\n\n    /// @notice Returns the address of the SUBNET_ACTOR_REWARDER_FACET.\n    function getSubnetActorRewarderFacet() external view returns (address) {\n        return s.SUBNET_ACTOR_REWARD_FACET;\n    }\n\n    /// @notice Returns the address of the SUBNET_ACTOR_CHECKPOINTER_FACET.\n    function getSubnetActorCheckpointerFacet() external view returns (address) {\n        return s.SUBNET_ACTOR_CHECKPOINTING_FACET;\n    }\n\n    /// @notice Returns the address of the SUBNET_ACTOR_PAUSER_FACET.\n    function getSubnetActorPauserFacet() external view returns (address) {\n        return s.SUBNET_ACTOR_PAUSE_FACET;\n    }\n\n    /// @notice Returns the subnet actor getter selectors.\n    function getSubnetActorGetterSelectors() external view returns (bytes4[] memory) {\n        return s.subnetActorGetterSelectors;\n    }\n\n    /// @notice Returns the subnet actor manager selectors.\n    function getSubnetActorManagerSelectors() external view returns (bytes4[] memory) {\n        return s.subnetActorManagerSelectors;\n    }\n\n    /// @notice Returns the subnet actor rewarder selectors.\n    function getSubnetActorRewarderSelectors() external view returns (bytes4[] memory) {\n        return s.subnetActorRewarderSelectors;\n    }\n\n    /// @notice Returns the subnet actor checkpointer selectors.\n    function getSubnetActorCheckpointerSelectors() external view returns (bytes4[] memory) {\n        return s.subnetActorCheckpointerSelectors;\n    }\n\n    /// @notice Returns the subnet actor pauser selectors.\n    function getSubnetActorPauserSelectors() external view returns (bytes4[] memory) {\n        return s.subnetActorPauserSelectors;\n    }\n\n    /// @notice Updates references to the subnet contract components, including facets and selector sets.\n    /// Only callable by the contract owner.\n    /// @param newGetterFacet The address of the new subnet getter facet.\n    /// @param newManagerFacet The address of the new subnet manager facet.\n    /// @param newSubnetGetterSelectors An array of function selectors for the new subnet getter facet.\n    /// @param newSubnetManagerSelectors An array of function selectors for the new subnet manager facet.\n    function updateReferenceSubnetContract(\n        address newGetterFacet,\n        address newManagerFacet,\n        bytes4[] calldata newSubnetGetterSelectors,\n        bytes4[] calldata newSubnetManagerSelectors\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n\n        // Validate addresses are not zero\n        if (newGetterFacet == address(0)) {\n            revert FacetCannotBeZero();\n        }\n        if (newManagerFacet == address(0)) {\n            revert FacetCannotBeZero();\n        }\n\n        // Update the storage variables\n        s.SUBNET_ACTOR_GETTER_FACET = newGetterFacet;\n        s.SUBNET_ACTOR_MANAGER_FACET = newManagerFacet;\n\n        s.subnetActorGetterSelectors = newSubnetGetterSelectors;\n        s.subnetActorManagerSelectors = newSubnetManagerSelectors;\n    }\n}\n"
    },
    "contracts/ipc/SubnetRegistryDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity ^0.8.23;\n\nimport {IDiamond} from \"./interfaces/IDiamond.sol\";\nimport {IDiamondCut} from \"./interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"./interfaces/IDiamondLoupe.sol\";\nimport {IERC165} from \"./interfaces/IERC165.sol\";\nimport {SubnetRegistryActorStorage} from \"./lib/LibSubnetRegistryStorage.sol\";\nimport {GatewayCannotBeZero, FacetCannotBeZero} from \"./errors/IPCErrors.sol\";\nimport {LibDiamond} from \"./lib/LibDiamond.sol\";\nimport {SubnetCreationPrivileges} from \"./structs/Subnet.sol\";\n\nerror FunctionNotFound(bytes4 _functionSelector);\n\ncontract SubnetRegistryDiamond {\n    SubnetRegistryActorStorage internal s;\n\n    struct ConstructorParams {\n        address gateway;\n        address getterFacet;\n        address managerFacet;\n        address rewarderFacet;\n        address checkpointerFacet;\n        address pauserFacet;\n        address diamondCutFacet;\n        address diamondLoupeFacet;\n        address ownershipFacet;\n        bytes4[] subnetActorGetterSelectors;\n        bytes4[] subnetActorManagerSelectors;\n        bytes4[] subnetActorRewarderSelectors;\n        bytes4[] subnetActorCheckpointerSelectors;\n        bytes4[] subnetActorPauserSelectors;\n        bytes4[] subnetActorDiamondCutSelectors;\n        bytes4[] subnetActorDiamondLoupeSelectors;\n        bytes4[] subnetActorOwnershipSelectors;\n        SubnetCreationPrivileges creationPrivileges;\n    }\n\n    constructor(\n        IDiamond.FacetCut[] memory _diamondCut,\n        ConstructorParams memory params\n    ) {\n        if (params.gateway == address(0)) {\n            revert GatewayCannotBeZero();\n        }\n        if (params.getterFacet == address(0)) {\n            revert FacetCannotBeZero();\n        }\n        if (params.managerFacet == address(0)) {\n            revert FacetCannotBeZero();\n        }\n        if (params.rewarderFacet == address(0)) {\n            revert FacetCannotBeZero();\n        }\n        if (params.checkpointerFacet == address(0)) {\n            revert FacetCannotBeZero();\n        }\n        if (params.pauserFacet == address(0)) {\n            revert FacetCannotBeZero();\n        }\n        if (params.diamondCutFacet == address(0)) {\n            revert FacetCannotBeZero();\n        }\n        if (params.diamondLoupeFacet == address(0)) {\n            revert FacetCannotBeZero();\n        }\n        if (params.ownershipFacet == address(0)) {\n            revert FacetCannotBeZero();\n        }\n\n        LibDiamond.setContractOwner(msg.sender);\n        LibDiamond.diamondCut({\n            _diamondCut: _diamondCut,\n            _init: address(0),\n            _calldata: new bytes(0)\n        });\n\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        // adding ERC165 data\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n\n        s.GATEWAY = params.gateway;\n        s.SUBNET_ACTOR_GETTER_FACET = params.getterFacet;\n        s.SUBNET_ACTOR_MANAGER_FACET = params.managerFacet;\n        s.SUBNET_ACTOR_REWARD_FACET = params.rewarderFacet;\n        s.SUBNET_ACTOR_CHECKPOINTING_FACET = params.checkpointerFacet;\n        s.SUBNET_ACTOR_PAUSE_FACET = params.pauserFacet;\n        s.SUBNET_ACTOR_DIAMOND_CUT_FACET = params.diamondCutFacet;\n        s.SUBNET_ACTOR_LOUPE_FACET = params.diamondLoupeFacet;\n        s.SUBNET_ACTOR_OWNERSHIP_FACET = params.ownershipFacet;\n\n        s.subnetActorGetterSelectors = params.subnetActorGetterSelectors;\n        s.subnetActorManagerSelectors = params.subnetActorManagerSelectors;\n        s.subnetActorRewarderSelectors = params.subnetActorRewarderSelectors;\n        s.subnetActorCheckpointerSelectors = params\n            .subnetActorCheckpointerSelectors;\n        s.subnetActorPauserSelectors = params.subnetActorPauserSelectors;\n        s.subnetActorDiamondCutSelectors = params\n            .subnetActorDiamondCutSelectors;\n        s.subnetActorDiamondLoupeSelectors = params\n            .subnetActorDiamondLoupeSelectors;\n        s.subnetActorOwnershipSelectors = params.subnetActorOwnershipSelectors;\n\n        s.creationPrivileges = params.creationPrivileges;\n    }\n\n    function _fallback() internal {\n        LibDiamond.DiamondStorage storage ds;\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        // slither-disable-next-line assembly\n        assembly {\n            ds.slot := position\n        }\n        // get facet from function selector\n        address facet = ds\n            .facetAddressAndSelectorPosition[msg.sig]\n            .facetAddress;\n        if (facet == address(0)) {\n            revert FunctionNotFound(msg.sig);\n        }\n        // Execute external function from facet using delegatecall and return any value.\n        // slither-disable-next-line assembly\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /// @notice Will run when no functions matches call data\n    fallback() external payable {\n        _fallback();\n    }\n\n    /// @notice Same as fallback but called when calldata is empty\n    receive() external payable {\n        _fallback();\n    }\n}\n"
    },
    "contracts/IRegisterSubnetFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {SubnetActorDiamond} from \"./ipc/SubnetActorDiamond.sol\";\n\ninterface IRegisterSubnetFacet {\n    function newSubnetActor(\n        SubnetActorDiamond.ConstructorParams calldata _params\n    ) external returns (address subnetAddr);\n}\n"
    },
    "contracts/IVerifiAIMarketApiHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n/**\n * @title IVeriFlowMarketApiHelper\n * @dev Interface for MarketAPI helper contract\n * @notice Clean interface without MarketAPI imports to avoid stack depth issues\n */\ninterface IVerifiAIMarketApiHelper {\n    \n    /// @notice Simple struct for deal activation info\n    struct DealActivationInfo {\n        bool isActivated;\n        bool isTerminated;\n        int64 activatedEpoch;\n        int64 terminatedEpoch;\n    }\n\n    /// @notice Simple struct for deal data info\n    struct DealDataInfo {\n        bool isValid;\n        uint64 dataSize;\n        bytes32 dataCommitment;\n    }\n\n    /**\n     * @notice Get deal activation information\n     * @param dealId Deal ID to check\n     * @return info Deal activation information\n     */\n    function getDealActivationInfo(uint64 dealId) \n        external \n        returns (DealActivationInfo memory info);\n\n    /**\n     * @notice Get deal data information\n     * @param dealId Deal ID to check\n     * @return info Deal data information\n     */\n    function getDealDataInfo(uint64 dealId) \n        external \n        returns (DealDataInfo memory info);\n\n    /**\n     * @notice Simple check if deal is active and valid\n     * @param dealId Deal ID to check\n     * @return isActive Whether deal is active\n     */\n    function isDealActive(uint64 dealId) external returns (bool isActive);\n\n    /**\n     * @notice Get deal client ID\n     * @param dealId Deal ID\n     * @return clientId Client ID\n     */\n    function getDealClient(uint64 dealId) external returns (uint64 clientId);\n\n    /**\n     * @notice Get deal provider ID  \n     * @param dealId Deal ID\n     * @return providerId Provider ID\n     */\n    function getDealProvider(uint64 dealId) external returns (uint64 providerId);\n} "
    },
    "contracts/IVerifiAIVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\n/**\n * @title IVeriFlowVerification\n * @dev Interface for the VeriFlow verification system\n */\ninterface IVerifiAIVerification {\n    /// @notice Enumeration for verification status\n    enum VerificationStatus {\n        PENDING,\n        VERIFIED,\n        FAILED,\n        DISPUTED,\n        CANCELLED\n    }\n\n    /// @notice Enumeration for AI model types\n    enum ModelType {\n        CLASSIFICATION,\n        REGRESSION,\n        NLP,\n        COMPUTER_VISION,\n        REINFORCEMENT_LEARNING,\n        GENERATIVE,\n        MULTIMODAL\n    }\n\n    /// @notice Structure for performance metrics\n    struct PerformanceMetrics {\n        uint256 accuracy;      // Accuracy percentage (0-10000)\n        uint256 precision;     // Precision percentage (0-10000)\n        uint256 recall;        // Recall percentage (0-10000)\n        uint256 f1Score;       // F1 score percentage (0-10000)\n        uint256 confidence;    // Confidence level (0-10000)\n        string customMetrics;  // JSON string for additional metrics\n    }\n\n    /// @notice Structure for training session\n    struct TrainingSession {\n        uint256 id;\n        address trainer;\n        uint256 datasetId;\n        string modelHash;      // IPFS hash of trained model\n        string datasetHash;    // IPFS hash of training dataset\n        ModelType modelType;\n        PerformanceMetrics metrics;\n        VerificationStatus status;\n        uint256 stakeAmount;\n        uint256 submissionTime;\n        uint256 verificationTime;\n        bytes32 tellorQueryId;\n        bool hasReward;\n    }\n\n    /**\n     * @notice Submit AI training session for verification\n     * @param datasetId Dataset used for training\n     * @param modelHash IPFS hash of the trained model\n     * @param datasetHash IPFS hash of the dataset\n     * @param modelType Type of AI model\n     * @param metrics Self-reported performance metrics\n     */\n    function submitTraining(\n        uint256 datasetId,\n        string memory modelHash,\n        string memory datasetHash,\n        ModelType modelType,\n        PerformanceMetrics memory metrics\n    ) external;\n\n    /**\n     * @notice Get verification result from Tellor oracle\n     * @param trainingId Training session ID\n     */\n    function getVerificationResult(uint256 trainingId) external;\n\n    /**\n     * @notice Get training session details\n     * @param trainingId Training session ID\n     * @return Training session details\n     */\n    function getTrainingSession(uint256 trainingId) \n        external \n        view \n        returns (TrainingSession memory);\n\n    /**\n     * @notice Get verified training sessions for a dataset\n     * @param datasetId Dataset ID\n     * @return Array of verified training session IDs\n     */\n    function getVerifiedTrainingSessions(uint256 datasetId) \n        external \n        view \n        returns (uint256[] memory);\n\n    /**\n     * @notice Calculate average performance metrics for a dataset\n     * @param datasetId Dataset ID\n     * @return avgAccuracy Average accuracy\n     * @return avgPrecision Average precision\n     * @return avgRecall Average recall\n     * @return avgF1Score Average F1 score\n     * @return sessionCount Number of verified sessions\n     */\n    function getDatasetPerformanceStats(uint256 datasetId) \n        external \n        view \n        returns (\n            uint256 avgAccuracy,\n            uint256 avgPrecision,\n            uint256 avgRecall,\n            uint256 avgF1Score,\n            uint256 sessionCount\n        );\n} "
    },
    "contracts/USDFC.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title USDFC - Mock USD Filecoin for Calibration Testnet\n * @dev Mock USDFC token for testing VerifiAI marketplace\n * @notice Based on the real USDFC by Secured Finance, this is a testnet version\n */\ncontract USDFC is ERC20, Ownable {\n    uint8 private _decimals = 18;\n    \n    // Mock collateral ratio (110% like real USDFC)\n    uint256 public constant COLLATERAL_RATIO = 110;\n    \n    event Mint(address indexed user, uint256 amount, uint256 collateralAmount);\n    event Redeem(address indexed user, uint256 amount, uint256 collateralAmount);\n    event CollateralDeposited(address indexed user, uint256 amount);\n    \n    // Track FIL collateral deposited by users\n    mapping(address => uint256) public collateralDeposits;\n    \n    constructor() ERC20(\"USD Filecoin\", \"USDFC\") Ownable(msg.sender) {\n        // Mint initial supply for testing (100,000 USDFC)\n        _mint(msg.sender, 100000 * 10**decimals());\n    }\n    \n    /**\n     * @dev Mint USDFC by depositing FIL as collateral (mock version)\n     * @notice Real USDFC requires 110% collateral ratio\n     */\n    function mintWithCollateral() external payable {\n        require(msg.value > 0, \"Must send FIL as collateral\");\n        \n        // Calculate USDFC to mint (assuming 1 FIL = $5 for testing)\n        // With 110% collateral ratio: 1 FIL ($5) -> 4.54 USDFC\n        uint256 usdcAmount = (msg.value * 454) / 100; // 4.54 USDFC per FIL\n        \n        collateralDeposits[msg.sender] += msg.value;\n        _mint(msg.sender, usdcAmount);\n        \n        emit Mint(msg.sender, usdcAmount, msg.value);\n        emit CollateralDeposited(msg.sender, msg.value);\n    }\n    \n    /**\n     * @dev Redeem USDFC for FIL collateral\n     * @param amount Amount of USDFC to redeem\n     */\n    function redeem(uint256 amount) external {\n        require(balanceOf(msg.sender) >= amount, \"Insufficient USDFC balance\");\n        \n        // Calculate FIL to return\n        uint256 filAmount = (amount * 100) / 454; // Reverse calculation\n        require(collateralDeposits[msg.sender] >= filAmount, \"Insufficient collateral\");\n        \n        collateralDeposits[msg.sender] -= filAmount;\n        _burn(msg.sender, amount);\n        payable(msg.sender).transfer(filAmount);\n        \n        emit Redeem(msg.sender, amount, filAmount);\n    }\n    \n    /**\n     * @dev Mint tokens directly (only owner, for testing purposes)\n     * @param to Address to mint tokens to\n     * @param amount Amount to mint\n     */\n    function mint(address to, uint256 amount) external onlyOwner {\n        _mint(to, amount);\n    }\n    \n    /**\n     * @dev Returns the number of decimals (18 like real USDFC)\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n    \n    /**\n     * @dev Get user's collateral info\n     * @param user User address\n     * @return depositedCollateral Amount of FIL deposited as collateral\n     * @return collateralRatio Current collateral ratio percentage\n     */\n    function getCollateralInfo(address user) external view returns (\n        uint256 depositedCollateral,\n        uint256 collateralRatio\n    ) {\n        depositedCollateral = collateralDeposits[user];\n        uint256 userBalance = balanceOf(user);\n        \n        if (userBalance == 0) {\n            collateralRatio = 0;\n        } else {\n            // Calculate ratio: (collateral * 454 / 100) / userBalance * 100\n            collateralRatio = (depositedCollateral * 454) / userBalance;\n        }\n    }\n    \n    /**\n     * @dev Fallback function to handle direct FIL transfers for minting\n     */\n    receive() external payable {\n        require(msg.value > 0, \"Must send FIL as collateral\");\n        \n        // Calculate USDFC to mint (assuming 1 FIL = $5 for testing)\n        uint256 usdcAmount = (msg.value * 454) / 100;\n        \n        collateralDeposits[msg.sender] += msg.value;\n        _mint(msg.sender, usdcAmount);\n        \n        emit Mint(msg.sender, usdcAmount, msg.value);\n        emit CollateralDeposited(msg.sender, msg.value);\n    }\n} "
    },
    "contracts/VerifiAIMarketApiHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\n// MarketAPI imports isolated to this contract only\nimport {MarketAPI} from \"@zondax/filecoin-solidity/contracts/v0.8/MarketAPI.sol\";\nimport {CommonTypes} from \"@zondax/filecoin-solidity/contracts/v0.8/types/CommonTypes.sol\";\nimport {MarketTypes} from \"@zondax/filecoin-solidity/contracts/v0.8/types/MarketTypes.sol\";\nimport {FilAddresses} from \"@zondax/filecoin-solidity/contracts/v0.8/utils/FilAddresses.sol\";\n\n/**\n * @title VeriFlowMarketApiHelper\n * @dev Isolated contract for MarketAPI interactions to avoid stack depth issues\n * @notice This contract handles all complex Filecoin MarketAPI operations\n */\ncontract VeriFlowMarketApiHelper {\n    \n    /// @notice Simple struct for deal activation info\n    struct DealActivationInfo {\n        bool isActivated;\n        bool isTerminated;\n        int64 activatedEpoch;\n        int64 terminatedEpoch;\n    }\n\n    /// @notice Simple struct for deal data info\n    struct DealDataInfo {\n        bool isValid;\n        uint64 dataSize;\n        bytes32 dataCommitment;\n    }\n\n    /**\n     * @notice Get deal activation information (stack-optimized)\n     * @param dealId Deal ID to check\n     * @return info Deal activation information\n     */\n    function getDealActivationInfo(uint64 dealId) \n        external \n        returns (DealActivationInfo memory info) \n    {\n        require(dealId > 0, \"Invalid deal ID\");\n        \n        MarketTypes.GetDealActivationReturn memory activation = MarketAPI.getDealActivation(dealId);\n        \n        info.activatedEpoch = CommonTypes.ChainEpoch.unwrap(activation.activated);\n        info.terminatedEpoch = CommonTypes.ChainEpoch.unwrap(activation.terminated);\n        info.isActivated = info.activatedEpoch > 0;\n        info.isTerminated = info.terminatedEpoch > 0;\n    }\n\n    /**\n     * @notice Get deal data information (stack-optimized)\n     * @param dealId Deal ID to check\n     * @return info Deal data information\n     */\n    function getDealDataInfo(uint64 dealId) \n        external \n        returns (DealDataInfo memory info) \n    {\n        require(dealId > 0, \"Invalid deal ID\");\n        \n        MarketTypes.GetDealDataCommitmentReturn memory dealData = MarketAPI.getDealDataCommitment(dealId);\n        \n        info.isValid = dealData.data.length > 0;\n        info.dataSize = dealData.size;\n        info.dataCommitment = keccak256(dealData.data);\n    }\n\n    /**\n     * @notice Simple check if deal is active and valid\n     * @param dealId Deal ID to check\n     * @return isActive Whether deal is active\n     */\n    function isDealActive(uint64 dealId) external returns (bool isActive) {\n        if (dealId == 0) return false;\n        \n        DealActivationInfo memory info = this.getDealActivationInfo(dealId);\n        return info.isActivated && !info.isTerminated;\n    }\n\n    /**\n     * @notice Get deal client ID\n     * @param dealId Deal ID\n     * @return clientId Client ID\n     */\n    function getDealClient(uint64 dealId) external returns (uint64 clientId) {\n        require(dealId > 0, \"Invalid deal ID\");\n        clientId = MarketAPI.getDealClient(dealId);\n    }\n\n    /**\n     * @notice Get deal provider ID  \n     * @param dealId Deal ID\n     * @return providerId Provider ID\n     */\n    function getDealProvider(uint64 dealId) external returns (uint64 providerId) {\n        require(dealId > 0, \"Invalid deal ID\");\n        providerId = MarketAPI.getDealProvider(dealId);\n    }\n} "
    },
    "contracts/VerifiAIMarketplace.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/**\n * @title VerifiAIMarketplace\n * @notice Verifiable AI Training Data Marketplace for Protocol Labs Genesis Hackathon 2025\n * @dev Minimized core version to avoid Yul stack depth issues\n */\ncontract VerifiAIMarketplace is Ownable, ReentrancyGuard {\n    \n    /// @notice USDFC token contract for payments\n    IERC20 public immutable usdfc;\n    \n    /// @notice Treasury address for fees\n    address public treasury;\n    \n    /// @notice Minimum stake amount for providers\n    uint256 public providerStakeAmount;\n    \n    /// @notice Current dataset ID counter\n    uint256 public datasetCounter;\n    \n    /// @notice Dataset information\n    struct Dataset {\n        uint256 id;\n        address provider;\n        string metadataUri;\n        uint256 pricePerBatch;\n        uint64 filecoinDealId;\n        bool isActive;\n        uint256 totalSales;\n    }\n    \n    /// @notice Purchase information\n    struct Purchase {\n        uint256 id;\n        uint256 datasetId;\n        address buyer;\n        uint256 amount;\n        uint256 timestamp;\n        bool isVerified;\n    }\n    \n    /// @notice Mapping from dataset ID to dataset info\n    mapping(uint256 => Dataset) public datasets;\n    \n    /// @notice Mapping from purchase ID to purchase info\n    mapping(uint256 => Purchase) public purchases;\n    \n    /// @notice Provider stakes\n    mapping(address => uint256) public providerStakes;\n    \n    /// @notice Purchase counter\n    uint256 public purchaseCounter;\n    \n    /// @notice Platform fee (in basis points, 250 = 2.5%)\n    uint256 public platformFeeRate = 250;\n    \n    // Events\n    event DatasetListed(\n        uint256 indexed datasetId, \n        address indexed provider, \n        uint256 pricePerBatch\n    );\n    \n    event DatasetPurchased(\n        uint256 indexed purchaseId,\n        uint256 indexed datasetId,\n        address indexed buyer,\n        uint256 amount\n    );\n    \n    event ProviderStaked(address indexed provider, uint256 amount);\n    event ProviderUnstaked(address indexed provider, uint256 amount);\n    \n    /**\n     * @notice Constructor\n     * @param _usdfc USDFC token address\n     * @param _treasury Treasury address\n     * @param _providerStakeAmount Minimum provider stake amount\n     */\n    constructor(\n        address _usdfc,\n        address _treasury,\n        uint256 _providerStakeAmount\n    ) Ownable(msg.sender) {\n        require(_usdfc != address(0), \"Invalid USDFC address\");\n        require(_treasury != address(0), \"Invalid treasury address\");\n        \n        usdfc = IERC20(_usdfc);\n        treasury = _treasury;\n        providerStakeAmount = _providerStakeAmount;\n    }\n    \n    /// @notice Modifier to check if provider has sufficient stake\n    modifier onlyStakedProvider() {\n        require(providerStakes[msg.sender] >= providerStakeAmount, \"Insufficient stake\");\n        _;\n    }\n    \n    /// @notice Modifier to check valid dataset\n    modifier validDataset(uint256 datasetId) {\n        require(datasetId > 0 && datasetId <= datasetCounter, \"Invalid dataset ID\");\n        require(datasets[datasetId].isActive, \"Dataset not active\");\n        _;\n    }\n    \n    /**\n     * @notice Stake USDFC to become a data provider\n     * @param amount Amount to stake\n     */\n    function stakeAsProvider(uint256 amount) external nonReentrant {\n        require(amount >= providerStakeAmount, \"Insufficient stake amount\");\n        \n        usdfc.transferFrom(msg.sender, address(this), amount);\n        providerStakes[msg.sender] += amount;\n        \n        emit ProviderStaked(msg.sender, amount);\n    }\n    \n    /**\n     * @notice List a new dataset for sale\n     * @param metadataUri IPFS URI for dataset metadata\n     * @param pricePerBatch Price per training batch in USDFC\n     * @param filecoinDealId Associated Filecoin deal ID (optional)\n     */\n    function listDataset(\n        string calldata metadataUri,\n        uint256 pricePerBatch,\n        uint64 filecoinDealId\n    ) external onlyStakedProvider {\n        require(bytes(metadataUri).length > 0, \"Invalid metadata URI\");\n        require(pricePerBatch > 0, \"Invalid price\");\n        \n        datasetCounter++;\n        \n        datasets[datasetCounter] = Dataset({\n            id: datasetCounter,\n            provider: msg.sender,\n            metadataUri: metadataUri,\n            pricePerBatch: pricePerBatch,\n            filecoinDealId: filecoinDealId,\n            isActive: true,\n            totalSales: 0\n        });\n        \n        emit DatasetListed(datasetCounter, msg.sender, pricePerBatch);\n    }\n    \n    /**\n     * @notice Purchase training data\n     * @param datasetId Dataset to purchase\n     * @param batchCount Number of batches to purchase\n     */\n    function purchaseData(\n        uint256 datasetId,\n        uint256 batchCount\n    ) external validDataset(datasetId) nonReentrant {\n        require(batchCount > 0, \"Invalid batch count\");\n        \n        Dataset storage dataset = datasets[datasetId];\n        uint256 totalAmount = dataset.pricePerBatch * batchCount;\n        \n        // Calculate platform fee\n        uint256 platformFee = (totalAmount * platformFeeRate) / 10000;\n        uint256 providerAmount = totalAmount - platformFee;\n        \n        // Transfer payment\n        usdfc.transferFrom(msg.sender, treasury, platformFee);\n        usdfc.transferFrom(msg.sender, dataset.provider, providerAmount);\n        \n        // Record purchase\n        purchaseCounter++;\n        purchases[purchaseCounter] = Purchase({\n            id: purchaseCounter,\n            datasetId: datasetId,\n            buyer: msg.sender,\n            amount: totalAmount,\n            timestamp: block.timestamp,\n            isVerified: false\n        });\n        \n        // Update dataset stats\n        dataset.totalSales += totalAmount;\n        \n        emit DatasetPurchased(purchaseCounter, datasetId, msg.sender, totalAmount);\n    }\n    \n    /**\n     * @notice Get dataset information\n     * @param datasetId Dataset ID\n     * @return Dataset information\n     */\n    function getDataset(uint256 datasetId) external view returns (Dataset memory) {\n        require(datasetId > 0 && datasetId <= datasetCounter, \"Invalid dataset ID\");\n        return datasets[datasetId];\n    }\n    \n    /**\n     * @notice Get purchase information\n     * @param purchaseId Purchase ID\n     * @return Purchase information\n     */\n    function getPurchase(uint256 purchaseId) external view returns (Purchase memory) {\n        require(purchaseId > 0 && purchaseId <= purchaseCounter, \"Invalid purchase ID\");\n        return purchases[purchaseId];\n    }\n    \n    /**\n     * @notice Check if a dataset has an active Filecoin deal\n     * @param datasetId Dataset ID\n     * @return isActive Whether the deal is active (basic check: deal ID exists)\n     * @return dealId The Filecoin deal ID (0 if no deal)\n     */\n    function isDatasetDealActive(uint256 datasetId) \n        external \n        view\n        validDataset(datasetId) \n        returns (bool isActive, uint64 dealId) \n    {\n        dealId = datasets[datasetId].filecoinDealId;\n        isActive = dealId > 0;\n    }\n    \n    /**\n     * @notice Update platform fee rate (owner only)\n     * @param newFeeRate New fee rate in basis points\n     */\n    function updatePlatformFeeRate(uint256 newFeeRate) external onlyOwner {\n        require(newFeeRate <= 1000, \"Fee rate too high\"); // Max 10%\n        platformFeeRate = newFeeRate;\n    }\n    \n    /**\n     * @notice Update provider stake requirement (owner only)\n     * @param newStakeAmount New minimum stake amount\n     */\n    function updateProviderStakeAmount(uint256 newStakeAmount) external onlyOwner {\n        providerStakeAmount = newStakeAmount;\n    }\n} "
    },
    "contracts/VerifiAIPayments.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\n\n/**\n * @title VerifiAIPayments\n * @dev USDFC payment processor with escrow and subscription management\n * @notice Handles all payment operations for the VerifiAI marketplace\n */\ncontract VerifiAIPayments is Ownable, ReentrancyGuard, Pausable {\n    using SafeERC20 for IERC20;\n\n    /// @notice Platform fee in basis points (100 = 1%)\n    uint256 public constant PLATFORM_FEE = 250; // 2.5%\n    \n    /// @notice Maximum subscription duration (1 year)\n    uint256 public constant MAX_SUBSCRIPTION_DURATION = 365 days;\n    \n    /// @notice Minimum escrow duration (1 hour)\n    uint256 public constant MIN_ESCROW_DURATION = 1 hours;\n\n    /// @notice USDFC stablecoin contract\n    IERC20 public immutable usdfc;\n    \n    /// @notice Platform treasury address\n    address public treasury;\n    \n    /// @notice VerifiAI marketplace contract address\n    address public marketplace;\n\n    /// @notice Current escrow ID counter\n    uint256 public currentEscrowId;\n    \n    /// @notice Current subscription ID counter\n    uint256 public currentSubscriptionId;\n\n    /// @notice Enumeration for payment types\n    enum PaymentType {\n        ONE_TIME,\n        SUBSCRIPTION,\n        ESCROW,\n        STAKE\n    }\n\n    /// @notice Enumeration for escrow status\n    enum EscrowStatus {\n        ACTIVE,\n        COMPLETED,\n        DISPUTED,\n        REFUNDED,\n        CANCELLED\n    }\n\n    /// @notice Enumeration for subscription status\n    enum SubscriptionStatus {\n        ACTIVE,\n        PAUSED,\n        CANCELLED,\n        EXPIRED\n    }\n\n    /// @notice Structure for escrow details\n    struct EscrowDetails {\n        uint256 id;\n        address buyer;\n        address seller;\n        uint256 amount;\n        uint256 createdAt;\n        uint256 releaseTime;\n        EscrowStatus status;\n        string description;\n        uint256 datasetId;\n    }\n\n    /// @notice Structure for subscription details\n    struct Subscription {\n        uint256 id;\n        address subscriber;\n        address provider;\n        uint256 amountPerPeriod;\n        uint256 periodDuration;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 lastPayment;\n        SubscriptionStatus status;\n        uint256 datasetId;\n        string accessLevel;\n    }\n\n    /// @notice Structure for payment record\n    struct PaymentRecord {\n        uint256 id;\n        address payer;\n        address recipient;\n        uint256 amount;\n        uint256 platformFee;\n        PaymentType paymentType;\n        uint256 timestamp;\n        uint256 relatedId; // escrow ID, subscription ID, etc.\n        string description;\n    }\n\n    /// @notice Mapping of escrow ID to escrow details\n    mapping(uint256 => EscrowDetails) public escrows;\n    \n    /// @notice Mapping of subscription ID to subscription details\n    mapping(uint256 => Subscription) public subscriptions;\n    \n    /// @notice Mapping of payment ID to payment record\n    mapping(uint256 => PaymentRecord) public payments;\n    \n    /// @notice Mapping of user to their subscription IDs\n    mapping(address => uint256[]) public userSubscriptions;\n    \n    /// @notice Mapping of user to their escrow IDs (as buyer)\n    mapping(address => uint256[]) public userEscrows;\n    \n    /// @notice Current payment ID counter\n    uint256 public currentPaymentId;\n\n    /// @notice Events\n    event EscrowCreated(\n        uint256 indexed escrowId,\n        address indexed buyer,\n        address indexed seller,\n        uint256 amount,\n        uint256 datasetId\n    );\n\n    event EscrowReleased(\n        uint256 indexed escrowId,\n        address indexed recipient,\n        uint256 amount\n    );\n\n    event EscrowRefunded(\n        uint256 indexed escrowId,\n        address indexed buyer,\n        uint256 amount\n    );\n\n    event SubscriptionCreated(\n        uint256 indexed subscriptionId,\n        address indexed subscriber,\n        address indexed provider,\n        uint256 amountPerPeriod,\n        uint256 duration\n    );\n\n    event SubscriptionPayment(\n        uint256 indexed subscriptionId,\n        uint256 amount,\n        uint256 nextPaymentDue\n    );\n\n    event SubscriptionCancelled(\n        uint256 indexed subscriptionId,\n        address indexed canceller\n    );\n\n    event PaymentProcessed(\n        uint256 indexed paymentId,\n        address indexed payer,\n        address indexed recipient,\n        uint256 amount,\n        PaymentType paymentType\n    );\n\n    /// @notice Modifiers\n    modifier onlyMarketplace() {\n        require(msg.sender == marketplace, \"Only marketplace\");\n        _;\n    }\n\n    modifier validEscrow(uint256 escrowId) {\n        require(escrowId > 0 && escrowId <= currentEscrowId, \"Invalid escrow ID\");\n        _;\n    }\n\n    modifier validSubscription(uint256 subscriptionId) {\n        require(subscriptionId > 0 && subscriptionId <= currentSubscriptionId, \"Invalid subscription ID\");\n        _;\n    }\n\n    /**\n     * @dev Constructor\n     * @param _usdfc USDFC token contract address\n     * @param _treasury Platform treasury address\n     */\n    constructor(\n        address _usdfc,\n        address _treasury\n    ) Ownable(msg.sender) {\n        require(_usdfc != address(0), \"Invalid USDFC address\");\n        require(_treasury != address(0), \"Invalid treasury address\");\n        \n        usdfc = IERC20(_usdfc);\n        treasury = _treasury;\n    }\n\n    /**\n     * @notice Set marketplace contract address (admin only)\n     * @param _marketplace Marketplace contract address\n     */\n    function setMarketplace(address _marketplace) external onlyOwner {\n        require(_marketplace != address(0), \"Invalid marketplace address\");\n        marketplace = _marketplace;\n    }\n\n    /**\n     * @notice Process one-time payment\n     * @param recipient Payment recipient\n     * @param amount Payment amount\n     * @param datasetId Related dataset ID\n     * @param description Payment description\n     */\n    function processPayment(\n        address recipient,\n        uint256 amount,\n        uint256 datasetId,\n        string memory description\n    ) external onlyMarketplace nonReentrant whenNotPaused {\n        require(recipient != address(0), \"Invalid recipient\");\n        require(amount > 0, \"Amount must be positive\");\n\n        uint256 platformFee = (amount * PLATFORM_FEE) / 10000;\n        uint256 recipientAmount = amount - platformFee;\n\n        // Transfer tokens\n        usdfc.safeTransferFrom(msg.sender, treasury, platformFee);\n        usdfc.safeTransferFrom(msg.sender, recipient, recipientAmount);\n\n        // Record payment\n        currentPaymentId++;\n        payments[currentPaymentId] = PaymentRecord({\n            id: currentPaymentId,\n            payer: msg.sender,\n            recipient: recipient,\n            amount: amount,\n            platformFee: platformFee,\n            paymentType: PaymentType.ONE_TIME,\n            timestamp: block.timestamp,\n            relatedId: datasetId,\n            description: description\n        });\n\n        emit PaymentProcessed(\n            currentPaymentId,\n            msg.sender,\n            recipient,\n            amount,\n            PaymentType.ONE_TIME\n        );\n    }\n\n    /**\n     * @notice Create escrow for secure transactions\n     * @param seller Seller address\n     * @param amount Escrow amount\n     * @param releaseTime When funds can be released\n     * @param datasetId Related dataset ID\n     * @param description Escrow description\n     */\n    function createEscrow(\n        address seller,\n        uint256 amount,\n        uint256 releaseTime,\n        uint256 datasetId,\n        string memory description\n    ) external nonReentrant whenNotPaused {\n        require(seller != address(0), \"Invalid seller\");\n        require(amount > 0, \"Amount must be positive\");\n        require(releaseTime > block.timestamp + MIN_ESCROW_DURATION, \"Invalid release time\");\n\n        // Transfer tokens to escrow\n        usdfc.safeTransferFrom(msg.sender, address(this), amount);\n\n        currentEscrowId++;\n        escrows[currentEscrowId] = EscrowDetails({\n            id: currentEscrowId,\n            buyer: msg.sender,\n            seller: seller,\n            amount: amount,\n            createdAt: block.timestamp,\n            releaseTime: releaseTime,\n            status: EscrowStatus.ACTIVE,\n            description: description,\n            datasetId: datasetId\n        });\n\n        userEscrows[msg.sender].push(currentEscrowId);\n\n        emit EscrowCreated(currentEscrowId, msg.sender, seller, amount, datasetId);\n    }\n\n    /**\n     * @notice Release escrow funds to seller\n     * @param escrowId Escrow ID to release\n     */\n    function releaseEscrow(uint256 escrowId) \n        external \n        validEscrow(escrowId) \n        nonReentrant \n    {\n        EscrowDetails storage escrow = escrows[escrowId];\n        require(escrow.status == EscrowStatus.ACTIVE, \"Escrow not active\");\n        require(\n            msg.sender == escrow.buyer || \n            msg.sender == escrow.seller || \n            msg.sender == owner() ||\n            block.timestamp >= escrow.releaseTime,\n            \"Not authorized to release\"\n        );\n\n        escrow.status = EscrowStatus.COMPLETED;\n\n        uint256 platformFee = (escrow.amount * PLATFORM_FEE) / 10000;\n        uint256 sellerAmount = escrow.amount - platformFee;\n\n        // Transfer funds\n        usdfc.safeTransfer(treasury, platformFee);\n        usdfc.safeTransfer(escrow.seller, sellerAmount);\n\n        emit EscrowReleased(escrowId, escrow.seller, sellerAmount);\n    }\n\n    /**\n     * @notice Refund escrow to buyer (only before release time or by admin)\n     * @param escrowId Escrow ID to refund\n     */\n    function refundEscrow(uint256 escrowId) \n        external \n        validEscrow(escrowId) \n        nonReentrant \n    {\n        EscrowDetails storage escrow = escrows[escrowId];\n        require(escrow.status == EscrowStatus.ACTIVE, \"Escrow not active\");\n        require(\n            msg.sender == escrow.buyer || \n            msg.sender == owner(),\n            \"Not authorized to refund\"\n        );\n\n        escrow.status = EscrowStatus.REFUNDED;\n\n        // Return full amount to buyer (no platform fee on refund)\n        usdfc.safeTransfer(escrow.buyer, escrow.amount);\n\n        emit EscrowRefunded(escrowId, escrow.buyer, escrow.amount);\n    }\n\n    /**\n     * @notice Create subscription for recurring payments\n     * @param provider Service provider address\n     * @param amountPerPeriod Amount to pay per period\n     * @param periodDuration Duration of each period in seconds\n     * @param totalPeriods Total number of periods\n     * @param datasetId Related dataset ID\n     * @param accessLevel Access level description\n     */\n    function createSubscription(\n        address provider,\n        uint256 amountPerPeriod,\n        uint256 periodDuration,\n        uint256 totalPeriods,\n        uint256 datasetId,\n        string memory accessLevel\n    ) external nonReentrant whenNotPaused {\n        require(provider != address(0), \"Invalid provider\");\n        require(amountPerPeriod > 0, \"Amount must be positive\");\n        require(periodDuration > 0, \"Period duration must be positive\");\n        require(totalPeriods > 0, \"Total periods must be positive\");\n        require(\n            periodDuration * totalPeriods <= MAX_SUBSCRIPTION_DURATION,\n            \"Subscription too long\"\n        );\n\n        currentSubscriptionId++;\n        uint256 endTime = block.timestamp + (periodDuration * totalPeriods);\n        \n        subscriptions[currentSubscriptionId] = Subscription({\n            id: currentSubscriptionId,\n            subscriber: msg.sender,\n            provider: provider,\n            amountPerPeriod: amountPerPeriod,\n            periodDuration: periodDuration,\n            startTime: block.timestamp,\n            endTime: endTime,\n            lastPayment: 0,\n            status: SubscriptionStatus.ACTIVE,\n            datasetId: datasetId,\n            accessLevel: accessLevel\n        });\n\n        userSubscriptions[msg.sender].push(currentSubscriptionId);\n\n        emit SubscriptionCreated(\n            currentSubscriptionId,\n            msg.sender,\n            provider,\n            amountPerPeriod,\n            endTime\n        );\n\n        // Process first payment\n        _processSubscriptionPayment(currentSubscriptionId);\n    }\n\n    /**\n     * @notice Process subscription payment\n     * @param subscriptionId Subscription ID\n     */\n    function processSubscriptionPayment(uint256 subscriptionId) \n        external \n        validSubscription(subscriptionId) \n        nonReentrant \n        whenNotPaused \n    {\n        _processSubscriptionPayment(subscriptionId);\n    }\n\n    /**\n     * @notice Internal function to process subscription payment\n     * @param subscriptionId Subscription ID\n     */\n    function _processSubscriptionPayment(uint256 subscriptionId) internal {\n        Subscription storage sub = subscriptions[subscriptionId];\n        require(sub.status == SubscriptionStatus.ACTIVE, \"Subscription not active\");\n        require(block.timestamp < sub.endTime, \"Subscription expired\");\n        \n        uint256 nextPaymentDue = sub.lastPayment + sub.periodDuration;\n        require(block.timestamp >= nextPaymentDue, \"Payment not due yet\");\n\n        uint256 platformFee = (sub.amountPerPeriod * PLATFORM_FEE) / 10000;\n        uint256 providerAmount = sub.amountPerPeriod - platformFee;\n\n        // Transfer tokens\n        usdfc.safeTransferFrom(sub.subscriber, treasury, platformFee);\n        usdfc.safeTransferFrom(sub.subscriber, sub.provider, providerAmount);\n\n        sub.lastPayment = block.timestamp;\n\n        // Record payment\n        currentPaymentId++;\n        payments[currentPaymentId] = PaymentRecord({\n            id: currentPaymentId,\n            payer: sub.subscriber,\n            recipient: sub.provider,\n            amount: sub.amountPerPeriod,\n            platformFee: platformFee,\n            paymentType: PaymentType.SUBSCRIPTION,\n            timestamp: block.timestamp,\n            relatedId: subscriptionId,\n            description: \"Subscription payment\"\n        });\n\n        uint256 nextDue = sub.lastPayment + sub.periodDuration;\n        emit SubscriptionPayment(subscriptionId, sub.amountPerPeriod, nextDue);\n    }\n\n    /**\n     * @notice Cancel subscription\n     * @param subscriptionId Subscription ID to cancel\n     */\n    function cancelSubscription(uint256 subscriptionId) \n        external \n        validSubscription(subscriptionId) \n    {\n        Subscription storage sub = subscriptions[subscriptionId];\n        require(\n            msg.sender == sub.subscriber || \n            msg.sender == sub.provider || \n            msg.sender == owner(),\n            \"Not authorized to cancel\"\n        );\n        require(sub.status == SubscriptionStatus.ACTIVE, \"Subscription not active\");\n\n        sub.status = SubscriptionStatus.CANCELLED;\n\n        emit SubscriptionCancelled(subscriptionId, msg.sender);\n    }\n\n    /**\n     * @notice Get user's subscriptions\n     * @param user User address\n     * @return Array of subscription IDs\n     */\n    function getUserSubscriptions(address user) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return userSubscriptions[user];\n    }\n\n    /**\n     * @notice Get user's escrows\n     * @param user User address\n     * @return Array of escrow IDs\n     */\n    function getUserEscrows(address user) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return userEscrows[user];\n    }\n\n    /**\n     * @notice Check if subscription payment is due\n     * @param subscriptionId Subscription ID\n     * @return Whether payment is due\n     */\n    function isPaymentDue(uint256 subscriptionId) \n        external \n        view \n        validSubscription(subscriptionId)\n        returns (bool) \n    {\n        Subscription storage sub = subscriptions[subscriptionId];\n        if (sub.status != SubscriptionStatus.ACTIVE) return false;\n        if (block.timestamp >= sub.endTime) return false;\n        \n        uint256 nextPaymentDue = sub.lastPayment + sub.periodDuration;\n        return block.timestamp >= nextPaymentDue;\n    }\n\n    /**\n     * @notice Emergency pause function\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Unpause function\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Update treasury address\n     * @param newTreasury New treasury address\n     */\n    function updateTreasury(address newTreasury) external onlyOwner {\n        require(newTreasury != address(0), \"Invalid address\");\n        treasury = newTreasury;\n    }\n\n    /**\n     * @notice Emergency withdrawal (admin only)\n     * @param amount Amount to withdraw\n     */\n    function emergencyWithdraw(uint256 amount) external onlyOwner {\n        usdfc.safeTransfer(owner(), amount);\n    }\n} "
    },
    "contracts/VerifiAIVerification.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.23;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {UsingTellor} from \"usingtellor/contracts/UsingTellor.sol\";\n\n/**\n * @title VerifiAIVerification\n * @dev AI model verification system using Tellor oracles\n * @notice Verifies AI training sessions and model performance metrics\n */\ncontract VerifiAIVerification is Ownable, ReentrancyGuard, UsingTellor {\n    /// @notice Minimum stake required for submitting training proofs\n    uint256 public constant TRAINING_STAKE = 100 * 10**18; // 100 USDFC\n    \n    /// @notice Time window for oracle responses (15 minutes)\n    uint256 public constant ORACLE_TIMEOUT = 15 minutes;\n    \n    /// @notice Minimum confidence threshold for verification (80%)\n    uint256 public constant MIN_CONFIDENCE = 8000; // 80.00%\n    \n    /// @notice Dispute period for challenges (24 hours)\n    uint256 public constant DISPUTE_PERIOD = 24 hours;\n\n    /// @notice USDFC token for payments and stakes\n    IERC20 public immutable usdfc;\n\n    /// @notice Current training session ID counter\n    uint256 public currentTrainingId;\n\n    /// @notice Enumeration for verification status\n    enum VerificationStatus {\n        PENDING,\n        VERIFIED,\n        FAILED,\n        DISPUTED,\n        CANCELLED\n    }\n\n    /// @notice Enumeration for AI model types\n    enum ModelType {\n        CLASSIFICATION,\n        REGRESSION,\n        NLP,\n        COMPUTER_VISION,\n        REINFORCEMENT_LEARNING,\n        GENERATIVE,\n        MULTIMODAL\n    }\n\n    /// @notice Structure for performance metrics\n    struct PerformanceMetrics {\n        uint256 accuracy;      // Accuracy percentage (0-10000)\n        uint256 precision;     // Precision percentage (0-10000)\n        uint256 recall;        // Recall percentage (0-10000)\n        uint256 f1Score;       // F1 score percentage (0-10000)\n        uint256 confidence;    // Confidence level (0-10000)\n        string customMetrics;  // JSON string for additional metrics\n    }\n\n    /// @notice Structure for training session\n    struct TrainingSession {\n        uint256 id;\n        address trainer;\n        uint256 datasetId;\n        string modelHash;      // IPFS hash of trained model\n        string datasetHash;    // IPFS hash of training dataset\n        ModelType modelType;\n        PerformanceMetrics metrics;\n        VerificationStatus status;\n        uint256 stakeAmount;\n        uint256 submissionTime;\n        uint256 verificationTime;\n        bytes32 tellorQueryId;\n        bool hasReward;\n    }\n\n    /// @notice Structure for verification challenge\n    struct Challenge {\n        uint256 trainingId;\n        address challenger;\n        string reason;\n        uint256 challengeTime;\n        bool isResolved;\n        bool isValid;\n    }\n\n    /// @notice Mapping of training ID to training session\n    mapping(uint256 => TrainingSession) public trainingSessions;\n    \n    /// @notice Mapping of trainer to their training session IDs\n    mapping(address => uint256[]) public trainerSessions;\n    \n    /// @notice Mapping of dataset to training sessions using it\n    mapping(uint256 => uint256[]) public datasetTrainingSessions;\n    \n    /// @notice Mapping of challenge ID to challenge details\n    mapping(uint256 => Challenge) public challenges;\n    \n    /// @notice Current challenge ID counter\n    uint256 public currentChallengeId;\n\n    /// @notice Mapping for custom Tellor query types\n    mapping(string => bool) public supportedQueryTypes;\n\n    /// @notice Events\n    event TrainingSubmitted(\n        uint256 indexed trainingId,\n        address indexed trainer,\n        uint256 indexed datasetId,\n        string modelHash\n    );\n\n    event VerificationCompleted(\n        uint256 indexed trainingId,\n        VerificationStatus status,\n        PerformanceMetrics metrics\n    );\n\n    event ChallengeSubmitted(\n        uint256 indexed challengeId,\n        uint256 indexed trainingId,\n        address indexed challenger\n    );\n\n    event ChallengeResolved(\n        uint256 indexed challengeId,\n        bool isValid,\n        address resolver\n    );\n\n    event TellorQuerySubmitted(\n        uint256 indexed trainingId,\n        bytes32 queryId,\n        string queryType\n    );\n\n    /// @notice Modifiers\n    modifier validTraining(uint256 trainingId) {\n        require(trainingId > 0 && trainingId <= currentTrainingId, \"Invalid training ID\");\n        _;\n    }\n\n    modifier onlyTrainer(uint256 trainingId) {\n        require(trainingSessions[trainingId].trainer == msg.sender, \"Not the trainer\");\n        _;\n    }\n\n    /**\n     * @dev Constructor\n     * @param _tellor Tellor oracle contract address\n     * @param _usdfc USDFC token contract address\n     */\n    constructor(\n        address payable _tellor,\n        address _usdfc\n    ) UsingTellor(_tellor) Ownable(msg.sender) {\n        require(_usdfc != address(0), \"Invalid USDFC address\");\n        usdfc = IERC20(_usdfc);\n        \n        // Initialize supported query types\n        supportedQueryTypes[\"AIModelPerformance\"] = true;\n        supportedQueryTypes[\"DatasetQuality\"] = true;\n        supportedQueryTypes[\"TrainingVerification\"] = true;\n        supportedQueryTypes[\"ModelBenchmark\"] = true;\n    }\n\n    /**\n     * @notice Submit AI training session for verification\n     * @param datasetId Dataset used for training\n     * @param modelHash IPFS hash of the trained model\n     * @param datasetHash IPFS hash of the dataset\n     * @param modelType Type of AI model\n     * @param metrics Self-reported performance metrics\n     */\n    function submitTraining(\n        uint256 datasetId,\n        string memory modelHash,\n        string memory datasetHash,\n        ModelType modelType,\n        PerformanceMetrics memory metrics\n    ) external nonReentrant {\n        require(bytes(modelHash).length > 0, \"Model hash required\");\n        require(bytes(datasetHash).length > 0, \"Dataset hash required\");\n        require(metrics.confidence <= 10000, \"Invalid confidence level\");\n\n        // Transfer stake\n        require(\n            usdfc.transferFrom(msg.sender, address(this), TRAINING_STAKE),\n            \"Stake transfer failed\"\n        );\n\n        currentTrainingId++;\n        uint256 trainingId = currentTrainingId;\n\n        trainingSessions[trainingId] = TrainingSession({\n            id: trainingId,\n            trainer: msg.sender,\n            datasetId: datasetId,\n            modelHash: modelHash,\n            datasetHash: datasetHash,\n            modelType: modelType,\n            metrics: metrics,\n            status: VerificationStatus.PENDING,\n            stakeAmount: TRAINING_STAKE,\n            submissionTime: block.timestamp,\n            verificationTime: 0,\n            tellorQueryId: bytes32(0),\n            hasReward: false\n        });\n\n        trainerSessions[msg.sender].push(trainingId);\n        datasetTrainingSessions[datasetId].push(trainingId);\n\n        emit TrainingSubmitted(trainingId, msg.sender, datasetId, modelHash);\n\n        // Automatically request oracle verification\n        _requestOracleVerification(trainingId);\n    }\n\n    /**\n     * @notice Request Tellor oracle verification for training session\n     * @param trainingId Training session ID\n     */\n    function _requestOracleVerification(uint256 trainingId) internal {\n        TrainingSession storage session = trainingSessions[trainingId];\n        \n        // Create Tellor query for AI model performance verification\n        bytes memory queryData = abi.encode(\n            \"AIModelPerformance\",\n            abi.encode(\n                session.modelHash,\n                session.datasetHash,\n                uint256(session.modelType),\n                session.metrics.accuracy,\n                session.metrics.precision,\n                session.metrics.recall,\n                session.metrics.f1Score\n            )\n        );\n        \n        bytes32 queryId = keccak256(queryData);\n        session.tellorQueryId = queryId;\n\n        emit TellorQuerySubmitted(trainingId, queryId, \"AIModelPerformance\");\n    }\n\n    /**\n     * @notice Get verification result from Tellor oracle\n     * @param trainingId Training session ID\n     */\n    function getVerificationResult(uint256 trainingId) \n        external \n        validTraining(trainingId) \n    {\n        TrainingSession storage session = trainingSessions[trainingId];\n        require(session.status == VerificationStatus.PENDING, \"Not pending verification\");\n        require(session.tellorQueryId != bytes32(0), \"No oracle query submitted\");\n\n        // Get data from Tellor oracle\n        (bytes memory value, uint256 timestamp) = _getDataBefore(\n            session.tellorQueryId,\n            block.timestamp - ORACLE_TIMEOUT\n        );\n\n        require(timestamp > 0, \"No oracle data available\");\n        require(block.timestamp - timestamp <= ORACLE_TIMEOUT, \"Oracle data too old\");\n\n        // Decode oracle response\n        (\n            bool isValid,\n            uint256 verifiedAccuracy,\n            uint256 verifiedPrecision,\n            uint256 verifiedRecall,\n            uint256 verifiedF1,\n            uint256 confidenceLevel\n        ) = abi.decode(value, (bool, uint256, uint256, uint256, uint256, uint256));\n\n        // Update session with verified metrics\n        session.metrics.accuracy = verifiedAccuracy;\n        session.metrics.precision = verifiedPrecision;\n        session.metrics.recall = verifiedRecall;\n        session.metrics.f1Score = verifiedF1;\n        session.metrics.confidence = confidenceLevel;\n        session.verificationTime = block.timestamp;\n\n        // Determine verification status\n        if (isValid && confidenceLevel >= MIN_CONFIDENCE) {\n            session.status = VerificationStatus.VERIFIED;\n            \n            // Return stake plus reward\n            uint256 rewardAmount = session.stakeAmount + (session.stakeAmount * 20 / 100); // 20% reward\n            session.hasReward = true;\n            \n            require(\n                usdfc.transfer(session.trainer, rewardAmount),\n                \"Reward transfer failed\"\n            );\n        } else {\n            session.status = VerificationStatus.FAILED;\n            // Stake is forfeited\n        }\n\n        emit VerificationCompleted(trainingId, session.status, session.metrics);\n    }\n\n    /**\n     * @notice Submit a challenge to a verified training session\n     * @param trainingId Training session to challenge\n     * @param reason Reason for the challenge\n     */\n    function submitChallenge(\n        uint256 trainingId,\n        string memory reason\n    ) external validTraining(trainingId) {\n        TrainingSession storage session = trainingSessions[trainingId];\n        require(session.status == VerificationStatus.VERIFIED, \"Only verified sessions can be challenged\");\n        require(\n            block.timestamp <= session.verificationTime + DISPUTE_PERIOD,\n            \"Challenge period expired\"\n        );\n        require(bytes(reason).length > 0, \"Reason required\");\n\n        // Require challenger stake (same as training stake)\n        require(\n            usdfc.transferFrom(msg.sender, address(this), TRAINING_STAKE),\n            \"Challenge stake transfer failed\"\n        );\n\n        currentChallengeId++;\n        challenges[currentChallengeId] = Challenge({\n            trainingId: trainingId,\n            challenger: msg.sender,\n            reason: reason,\n            challengeTime: block.timestamp,\n            isResolved: false,\n            isValid: false\n        });\n\n        session.status = VerificationStatus.DISPUTED;\n\n        emit ChallengeSubmitted(currentChallengeId, trainingId, msg.sender);\n    }\n\n    /**\n     * @notice Resolve a challenge (admin function)\n     * @param challengeId Challenge ID to resolve\n     * @param isValid Whether the challenge is valid\n     */\n    function resolveChallenge(\n        uint256 challengeId,\n        bool isValid\n    ) external onlyOwner {\n        Challenge storage challenge = challenges[challengeId];\n        require(!challenge.isResolved, \"Challenge already resolved\");\n        \n        TrainingSession storage session = trainingSessions[challenge.trainingId];\n        \n        challenge.isResolved = true;\n        challenge.isValid = isValid;\n\n        if (isValid) {\n            // Challenge is valid - mark training as failed\n            session.status = VerificationStatus.FAILED;\n            \n            // Return challenger's stake and give them the training stake\n            uint256 totalReward = TRAINING_STAKE * 2;\n            require(\n                usdfc.transfer(challenge.challenger, totalReward),\n                \"Challenge reward transfer failed\"\n            );\n        } else {\n            // Challenge is invalid - restore verified status\n            session.status = VerificationStatus.VERIFIED;\n            \n            // Return training stake to original trainer\n            require(\n                usdfc.transfer(session.trainer, TRAINING_STAKE),\n                \"Trainer stake return failed\"\n            );\n        }\n\n        emit ChallengeResolved(challengeId, isValid, msg.sender);\n    }\n\n    /**\n     * @notice Get training session details\n     * @param trainingId Training session ID\n     * @return Training session details\n     */\n    function getTrainingSession(uint256 trainingId) \n        external \n        view \n        validTraining(trainingId)\n        returns (TrainingSession memory) \n    {\n        return trainingSessions[trainingId];\n    }\n\n    /**\n     * @notice Get training sessions by trainer\n     * @param trainer Trainer address\n     * @return Array of training session IDs\n     */\n    function getTrainerSessions(address trainer) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return trainerSessions[trainer];\n    }\n\n    /**\n     * @notice Get training sessions using a dataset\n     * @param datasetId Dataset ID\n     * @return Array of training session IDs\n     */\n    function getDatasetTrainingSessions(uint256 datasetId) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        return datasetTrainingSessions[datasetId];\n    }\n\n    /**\n     * @notice Get verified training sessions for a dataset\n     * @param datasetId Dataset ID\n     * @return Array of verified training session IDs\n     */\n    function getVerifiedTrainingSessions(uint256 datasetId) \n        external \n        view \n        returns (uint256[] memory) \n    {\n        uint256[] memory allSessions = datasetTrainingSessions[datasetId];\n        uint256[] memory verifiedSessions = new uint256[](allSessions.length);\n        uint256 count = 0;\n\n        for (uint256 i = 0; i < allSessions.length; i++) {\n            if (trainingSessions[allSessions[i]].status == VerificationStatus.VERIFIED) {\n                verifiedSessions[count] = allSessions[i];\n                count++;\n            }\n        }\n\n        // Resize array to actual count\n        assembly {\n            mstore(verifiedSessions, count)\n        }\n\n        return verifiedSessions;\n    }\n\n    /**\n     * @notice Calculate average performance metrics for a dataset\n     * @param datasetId Dataset ID\n     * @return avgAccuracy Average accuracy\n     * @return avgPrecision Average precision\n     * @return avgRecall Average recall\n     * @return avgF1Score Average F1 score\n     * @return sessionCount Number of verified sessions\n     */\n    function getDatasetPerformanceStats(uint256 datasetId) \n        external \n        view \n        returns (\n            uint256 avgAccuracy,\n            uint256 avgPrecision,\n            uint256 avgRecall,\n            uint256 avgF1Score,\n            uint256 sessionCount\n        ) \n    {\n        uint256[] memory sessions = datasetTrainingSessions[datasetId];\n        uint256 totalAccuracy = 0;\n        uint256 totalPrecision = 0;\n        uint256 totalRecall = 0;\n        uint256 totalF1 = 0;\n        uint256 verifiedCount = 0;\n\n        for (uint256 i = 0; i < sessions.length; i++) {\n            TrainingSession storage session = trainingSessions[sessions[i]];\n            if (session.status == VerificationStatus.VERIFIED) {\n                totalAccuracy += session.metrics.accuracy;\n                totalPrecision += session.metrics.precision;\n                totalRecall += session.metrics.recall;\n                totalF1 += session.metrics.f1Score;\n                verifiedCount++;\n            }\n        }\n\n        if (verifiedCount > 0) {\n            avgAccuracy = totalAccuracy / verifiedCount;\n            avgPrecision = totalPrecision / verifiedCount;\n            avgRecall = totalRecall / verifiedCount;\n            avgF1Score = totalF1 / verifiedCount;\n        }\n\n        sessionCount = verifiedCount;\n    }\n\n    /**\n     * @notice Add supported Tellor query type (admin function)\n     * @param queryType Query type to add\n     */\n    function addSupportedQueryType(string memory queryType) external onlyOwner {\n        supportedQueryTypes[queryType] = true;\n    }\n\n    /**\n     * @notice Emergency withdrawal of stuck funds (admin function)\n     * @param amount Amount to withdraw\n     */\n    function emergencyWithdraw(uint256 amount) external onlyOwner {\n        require(usdfc.transfer(owner(), amount), \"Withdrawal failed\");\n    }\n} "
    },
    "fevmate/contracts/utils/FilAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n/**\n * @author fevmate (https://github.com/wadealexc/fevmate)\n * @notice Utility functions for converting between id and\n * eth addresses. Helps implement address normalization.\n *\n * See README for more details about how to use this when\n * developing for the FEVM.\n */\nlibrary FilAddress {\n    \n    // Custom errors\n    error CallFailed();\n    error InvalidAddress();\n    error InsufficientFunds();\n\n    // Builtin Actor addresses (singletons)\n    address constant SYSTEM_ACTOR = 0xfF00000000000000000000000000000000000000;\n    address constant INIT_ACTOR = 0xff00000000000000000000000000000000000001;\n    address constant REWARD_ACTOR = 0xff00000000000000000000000000000000000002;\n    address constant CRON_ACTOR = 0xFF00000000000000000000000000000000000003;\n    address constant POWER_ACTOR = 0xFf00000000000000000000000000000000000004;\n    address constant MARKET_ACTOR = 0xff00000000000000000000000000000000000005;\n    address constant VERIFIED_REGISTRY_ACTOR = 0xFF00000000000000000000000000000000000006;\n    address constant DATACAP_TOKEN_ACTOR = 0xfF00000000000000000000000000000000000007;\n    address constant EAM_ACTOR = 0xfF0000000000000000000000000000000000000a;\n\n    // FEVM precompile addresses\n    address constant RESOLVE_ADDRESS = 0xFE00000000000000000000000000000000000001;\n    address constant LOOKUP_DELEGATED_ADDRESS = 0xfE00000000000000000000000000000000000002;\n    address constant CALL_ACTOR = 0xfe00000000000000000000000000000000000003;\n    // address constant GET_ACTOR_TYPE = 0xFe00000000000000000000000000000000000004; // (deprecated)\n    address constant CALL_ACTOR_BY_ID = 0xfe00000000000000000000000000000000000005;\n\n    // An ID address with id == 0. It's also equivalent to the system actor address\n    // This is useful for bitwise operations\n    address constant ZERO_ID_ADDRESS = SYSTEM_ACTOR;\n    \n    /**\n     * @notice Convert ID to Eth address. Returns input if conversion fails.\n     *\n     * Attempt to convert address _a from an ID address to an Eth address\n     * If _a is NOT an ID address, this returns _a\n     * If _a does NOT have a corresponding Eth address, this returns _a\n     * \n     * NOTE: It is possible this returns an ID address! If you want a method\n     *       that will NEVER return an ID address, see mustNormalize below.\n     */\n    function normalize(address _a) internal view returns (address) {\n        // First, check if we have an ID address. If we don't, return as-is\n        (bool isID, uint64 id) = isIDAddress(_a);\n        if (!isID) {\n            return _a;\n        }\n\n        // We have an ID address -- attempt the conversion\n        // If there is no corresponding Eth address, return _a\n        (bool success, address eth) = getEthAddress(id);\n        if (!success) {\n            return _a;\n        } else {\n            return eth;\n        }\n    }\n\n    /**\n     * @notice Convert ID to Eth address. Reverts if conversion fails.\n     *\n     * Attempt to convert address _a from an ID address to an Eth address\n     * If _a is NOT an ID address, this returns _a unchanged\n     * If _a does NOT have a corresponding Eth address, this method reverts\n     *\n     * This method can be used when you want a guarantee that an ID address is not\n     * returned. Note, though, that rejecting ID addresses may mean you don't support\n     * other Filecoin-native actors.\n     */\n    function mustNormalize(address _a) internal view returns (address) {\n        // First, check if we have an ID address. If we don't, return as-is\n        (bool isID, uint64 id) = isIDAddress(_a);\n        if (!isID) {\n            return _a;\n        }\n\n        // We have an ID address -- attempt the conversion\n        // If there is no corresponding Eth address, revert\n        (bool success, address eth) = getEthAddress(id);\n        if (!success) revert InvalidAddress();\n        return eth;\n    }\n\n    // Used to clear the last 8 bytes of an address    (addr & U64_MASK)\n    address constant U64_MASK = 0xFffFfFffffFfFFffffFFFffF0000000000000000;\n    // Used to retrieve the last 8 bytes of an address (addr & MAX_U64)\n    address constant MAX_U64 = 0x000000000000000000000000fFFFFFffFFFFfffF;\n\n    /**\n     * @notice Checks whether _a matches the ID address format.\n     * If it does, returns true and the id\n     * \n     * The ID address format is:\n     * 0xFF | bytes11(0) | uint64(id)\n     */\n    function isIDAddress(address _a) internal pure returns (bool isID, uint64 id) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Zeroes out the last 8 bytes of _a\n            let a_mask := and(_a, U64_MASK)\n\n            // If the result is equal to the ZERO_ID_ADDRESS,\n            // _a is an ID address.\n            if eq(a_mask, ZERO_ID_ADDRESS) {\n                isID := true\n                id := and(_a, MAX_U64)\n            }\n        }\n    }\n\n    /**\n     * @notice Given an Actor ID, converts it to an EVM-compatible address.\n     * \n     * If _id has a corresponding Eth address, we return that\n     * Otherwise, _id is returned as a 20-byte ID address\n     */\n    function toAddress(uint64 _id) internal view returns (address) {\n        (bool success, address eth) = getEthAddress(_id);\n        if (success) {\n            return eth;\n        } else {\n            return toIDAddress(_id);\n        }\n    }\n\n    /**\n     * @notice Given an Actor ID, converts it to a 20-byte ID address\n     * \n     * Note that this method does NOT check if the _id has a corresponding\n     * Eth address. If you want that, try toAddress above.\n     */\n    function toIDAddress(uint64 _id) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly { addr := or(ZERO_ID_ADDRESS, _id) }\n    }\n\n    // An address with all bits set. Used to clean higher-order bits\n    address constant ADDRESS_MASK = 0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF;\n\n    /**\n     * @notice Convert ID to Eth address by querying the lookup_delegated_address\n     * precompile.\n     *\n     * If the actor ID corresponds to an Eth address, this will return (true, addr)\n     * If the actor ID does NOT correspond to an Eth address, this will return (false, 0)\n     * \n     * --- About ---\n     * \n     * The lookup_delegated_address precompile retrieves the actor state corresponding\n     * to the id. If the actor has a delegated address, it is returned using fil\n     * address encoding (see below).\n     *\n     * f4, or delegated addresses, have a namespace as well as a subaddress that can\n     * be up to 54 bytes long. This is to support future address formats. Currently,\n     * though, the f4 format is only used to support Eth addresses.\n     *\n     * Consequently, the only addresses lookup_delegated_address should return have:\n     * - Prefix:     \"f4\" address      - 1 byte   - (0x04)\n     * - Namespace:  EAM actor id 10   - 1 byte   - (0x0A)\n     * - Subaddress: EVM-style address - 20 bytes - (EVM address)\n     * \n     * This method checks that the precompile output exactly matches this format:\n     * 22 bytes, starting with 0x040A.\n     * \n     * If we get anything else, we return (false, 0x00).\n     */\n    function getEthAddress(uint64 _id) internal view returns (bool success, address eth) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Call LOOKUP_DELEGATED_ADDRESS precompile\n            //\n            // Input: uint64 id, in standard EVM format (left-padded to 32 bytes)\n            //\n            // Output: LOOKUP_DELEGATED_ADDRESS returns an f4-encoded address. \n            // For Eth addresses, the format is a 20-byte address, prefixed with\n            // 0x040A. So, we expect exactly 22 bytes of returndata.\n            // \n            // Since we want to read an address from the returndata, we place the\n            // output at memory offset 10, which means the address is already\n            // word-aligned (10 + 22 == 32)\n            //\n            // NOTE: success and returndatasize checked at the end of the function\n            mstore(0, _id)\n            success := staticcall(gas(), LOOKUP_DELEGATED_ADDRESS, 0, 32, 10, 22)\n\n            // Read result. LOOKUP_DELEGATED_ADDRESS returns raw, unpadded\n            // bytes. Assuming we succeeded, we can extract the eth address\n            // by reading from offset 0 and cleaning any higher-order bits:\n            let result := mload(0)\n            eth := and(ADDRESS_MASK, result)\n\n            // Check that the returned address has the expected prefix. The\n            // prefix is the first 2 bytes of returndata, located at memory \n            // offset 10. \n            // \n            // To isolate it, shift right by the # of bits in an address (160),\n            // and clean all but the last 2 bytes.\n            let prefix := and(0xFFFF, shr(160, result))\n            if iszero(eq(prefix, 0x040A)) {\n                success := false\n                eth := 0\n            }\n        }\n        // Checking these here because internal functions don't have\n        // a good way to return from inline assembly.\n        //\n        // But, it's very important we do check these. If the output\n        // wasn't exactly what we expected, we assume there's no eth\n        // address and return (false, 0).\n        if (!success || returnDataSize() != 22) {\n            return (false, address(0));\n        }\n    }\n\n    /**\n     * @notice Convert ID to Eth address by querying the resolve_address precompile.\n     *\n     * If the passed-in address is already in ID form, returns (true, id)\n     * If the Eth address has no corresponding ID address, returns (false, 0)\n     * Otherwise, the lookup succeeds and this returns (true, id)\n     * \n     * --- About ---\n     *\n     * The resolve_address precompile can resolve any fil-encoded address to its\n     * corresponding actor ID, if there is one. This means resolve_address handles\n     * all address protocols: f0, f1, f2, f3, and f4. \n     * \n     * An address might not have an actor ID if it does not exist in state yet. A \n     * typical example of this is a public-key-type address, which can exist even \n     * if it hasn't been used on-chain yet.\n     *\n     * This method is only meant to look up ids for Eth addresses, so it contains\n     * very specific logic to correctly encode an Eth address into its f4 format.\n     * \n     * Note: This is essentially just the reverse of getEthAddress above, so check\n     * the comments there for more details on f4 encoding.\n     */\n    function getActorID(address _eth) internal view returns (bool success, uint64 id) {\n        // First - if we already have an ID address, we can just return that\n        (success, id) = isIDAddress(_eth);\n        if (success) {\n            return (success, id);\n        }\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Convert Eth address to f4 format: 22 bytes, with prefix 0x040A.\n            // (see getEthAddress above for more details on this format)\n            //\n            // We're going to pass the 22 bytes to the precompile without any\n            // padding or length, so everything will be left-aligned. Since \n            // addresses are right-aligned, we need to shift everything left:\n            // - 0x040A prefix - shifted left 240 bits (30 bytes * 8 bits)\n            // - Eth address   - shifted left 80 bits  (10 bytes * 8 bits)\n            let input := or(\n                shl(240, 0x040A),\n                shl(80, _eth)\n            )\n            // Call RESOLVE_ADDRESS precompile\n            //\n            // Input: Eth address in f4 format. 22 bytes, no padding or length\n            //\n            // Output: RESOLVE_ADDRESS returns a uint64 actor ID in standard EVM\n            // format (left-padded to 32 bytes).\n            // \n            // NOTE: success and returndatasize checked at the end of the function\n            mstore(0, input)\n            success := staticcall(gas(), RESOLVE_ADDRESS, 0, 22, 0, 32)\n\n            // Read result and clean higher-order bits, just in case.\n            // If successful, this will be the actor id.\n            id := and(MAX_U64, mload(0))\n        }\n        // Checking these here because internal functions don't have\n        // a good way to return from inline assembly.\n        //\n        // But, it's very important we do check these. If the output\n        // wasn't exactly what we expected, we assume there's no ID\n        // address and return (false, 0).\n        if (!success || returnDataSize() != 32) {\n            return (false, 0);\n        }\n    }\n\n    /**\n     * @notice Replacement for Solidity's address.send and address.transfer\n     * This sends _amount to _recipient, forwarding all available gas and\n     * reverting if there are any errors.\n     *\n     * If _recpient is an Eth address, this works the way you'd\n     * expect the EVM to work.\n     *\n     * If _recpient is an ID address, this works if:\n     * 1. The ID corresponds to an Eth EOA address      (EthAccount actor)\n     * 2. The ID corresponds to an Eth contract address (EVM actor)\n     * 3. The ID corresponds to a BLS/SECPK address     (Account actor)\n     *\n     * If _recpient is some other Filecoin-native actor, this will revert.\n     */\n    function sendValue(address payable _recipient, uint _amount) internal {\n        if (address(this).balance < _amount) revert InsufficientFunds();\n\n        (bool success, ) = _recipient.call{value: _amount}(\"\");\n        if (!success) revert CallFailed();\n    }\n\n    function returnDataSize() private pure returns (uint size) {\n        /// @solidity memory-safe-assembly\n        assembly { size := returndatasize() }\n    }\n}\n"
    },
    "solidity-cborutils/contracts/CBOR.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@ensdomains/buffer/contracts/Buffer.sol\";\n\n/**\n* @dev A library for populating CBOR encoded payload in Solidity.\n*\n* https://datatracker.ietf.org/doc/html/rfc7049\n*\n* The library offers various write* and start* methods to encode values of different types.\n* The resulted buffer can be obtained with data() method.\n* Encoding of primitive types is staightforward, whereas encoding of sequences can result\n* in an invalid CBOR if start/write/end flow is violated.\n* For the purpose of gas saving, the library does not verify start/write/end flow internally,\n* except for nested start/end pairs.\n*/\n\nlibrary CBOR {\n    using Buffer for Buffer.buffer;\n\n    struct CBORBuffer {\n        Buffer.buffer buf;\n        uint256 depth;\n    }\n\n    uint8 private constant MAJOR_TYPE_INT = 0;\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\n    uint8 private constant MAJOR_TYPE_STRING = 3;\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\n    uint8 private constant MAJOR_TYPE_MAP = 5;\n    uint8 private constant MAJOR_TYPE_TAG = 6;\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\n\n    uint8 private constant TAG_TYPE_BIGNUM = 2;\n    uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\n\n    uint8 private constant CBOR_FALSE = 20;\n    uint8 private constant CBOR_TRUE = 21;\n    uint8 private constant CBOR_NULL = 22;\n    uint8 private constant CBOR_UNDEFINED = 23;\n\n    function create(uint256 capacity) internal pure returns(CBORBuffer memory cbor) {\n        Buffer.init(cbor.buf, capacity);\n        cbor.depth = 0;\n        return cbor;\n    }\n\n    function data(CBORBuffer memory buf) internal pure returns(bytes memory) {\n        require(buf.depth == 0, \"Invalid CBOR\");\n        return buf.buf.buf;\n    }\n\n    function writeUInt256(CBORBuffer memory buf, uint256 value) internal pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\n        writeBytes(buf, abi.encode(value));\n    }\n\n    function writeInt256(CBORBuffer memory buf, int256 value) internal pure {\n        if (value < 0) {\n            buf.buf.appendUint8(\n                uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM)\n            );\n            writeBytes(buf, abi.encode(uint256(-1 - value)));\n        } else {\n            writeUInt256(buf, uint256(value));\n        }\n    }\n\n    function writeUInt64(CBORBuffer memory buf, uint64 value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_INT, value);\n    }\n\n    function writeInt64(CBORBuffer memory buf, int64 value) internal pure {\n        if(value >= 0) {\n            writeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\n        } else{\n            writeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(-1 - value));\n        }\n    }\n\n    function writeBytes(CBORBuffer memory buf, bytes memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\n        buf.buf.append(value);\n    }\n\n    function writeString(CBORBuffer memory buf, string memory value) internal pure {\n        writeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\n        buf.buf.append(bytes(value));\n    }\n\n    function writeBool(CBORBuffer memory buf, bool value) internal pure {\n        writeContentFree(buf, value ? CBOR_TRUE : CBOR_FALSE);\n    }\n\n    function writeNull(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_NULL);\n    }\n\n    function writeUndefined(CBORBuffer memory buf) internal pure {\n        writeContentFree(buf, CBOR_UNDEFINED);\n    }\n\n    function startArray(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\n        buf.depth += 1;\n    }\n\n    function startFixedArray(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_ARRAY, length);\n    }\n\n    function startMap(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\n        buf.depth += 1;\n    }\n\n    function startFixedMap(CBORBuffer memory buf, uint64 length) internal pure {\n        writeDefiniteLengthType(buf, MAJOR_TYPE_MAP, length);\n    }\n\n    function endSequence(CBORBuffer memory buf) internal pure {\n        writeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\n        buf.depth -= 1;\n    }\n\n    function writeKVString(CBORBuffer memory buf, string memory key, string memory value) internal pure {\n        writeString(buf, key);\n        writeString(buf, value);\n    }\n\n    function writeKVBytes(CBORBuffer memory buf, string memory key, bytes memory value) internal pure {\n        writeString(buf, key);\n        writeBytes(buf, value);\n    }\n\n    function writeKVUInt256(CBORBuffer memory buf, string memory key, uint256 value) internal pure {\n        writeString(buf, key);\n        writeUInt256(buf, value);\n    }\n\n    function writeKVInt256(CBORBuffer memory buf, string memory key, int256 value) internal pure {\n        writeString(buf, key);\n        writeInt256(buf, value);\n    }\n\n    function writeKVUInt64(CBORBuffer memory buf, string memory key, uint64 value) internal pure {\n        writeString(buf, key);\n        writeUInt64(buf, value);\n    }\n\n    function writeKVInt64(CBORBuffer memory buf, string memory key, int64 value) internal pure {\n        writeString(buf, key);\n        writeInt64(buf, value);\n    }\n\n    function writeKVBool(CBORBuffer memory buf, string memory key, bool value) internal pure {\n        writeString(buf, key);\n        writeBool(buf, value);\n    }\n\n    function writeKVNull(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeNull(buf);\n    }\n\n    function writeKVUndefined(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        writeUndefined(buf);\n    }\n\n    function writeKVMap(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startMap(buf);\n    }\n\n    function writeKVArray(CBORBuffer memory buf, string memory key) internal pure {\n        writeString(buf, key);\n        startArray(buf);\n    }\n\n    function writeFixedNumeric(\n        CBORBuffer memory buf,\n        uint8 major,\n        uint64 value\n    ) private pure {\n        if (value <= 23) {\n            buf.buf.appendUint8(uint8((major << 5) | value));\n        } else if (value <= 0xFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 24));\n            buf.buf.appendInt(value, 1);\n        } else if (value <= 0xFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 25));\n            buf.buf.appendInt(value, 2);\n        } else if (value <= 0xFFFFFFFF) {\n            buf.buf.appendUint8(uint8((major << 5) | 26));\n            buf.buf.appendInt(value, 4);\n        } else {\n            buf.buf.appendUint8(uint8((major << 5) | 27));\n            buf.buf.appendInt(value, 8);\n        }\n    }\n\n    function writeIndefiniteLengthType(CBORBuffer memory buf, uint8 major)\n        private\n        pure\n    {\n        buf.buf.appendUint8(uint8((major << 5) | 31));\n    }\n\n    function writeDefiniteLengthType(CBORBuffer memory buf, uint8 major, uint64 length)\n        private\n        pure\n    {\n        writeFixedNumeric(buf, major, length);\n    }\n\n    function writeContentFree(CBORBuffer memory buf, uint8 value) private pure {\n        buf.buf.appendUint8(uint8((MAJOR_TYPE_CONTENT_FREE << 5) | value));\n    }\n}"
    },
    "usingtellor/contracts/interface/ITellor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ITellor {\n    function getNewValueCountbyQueryId(bytes32 _queryId) external view returns (uint256);\n    function getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index) external view returns (uint256);\n    function retrieveData(bytes32 _queryId, uint256 _timestamp) external view returns (bytes memory);\n    function getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp) external view returns (address);\n    function getDataBefore(bytes32 _queryId, uint256 _timestamp) external  view  returns(bool _ifRetrieve, bytes memory _value, uint256 _timestampRetrieved);\n    function getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp) external view returns (bool _found, uint256 _index);\n    function isInDispute(bytes32 _queryId, uint256 _timestamp) external view returns (bool);\n}\n"
    },
    "usingtellor/contracts/UsingTellor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./interface/ITellor.sol\";\n\n/**\n @author Tellor Inc\n @title UsingTellor\n @dev This contract helps smart contracts read data from Tellor\n */\ncontract UsingTellor{\n    ITellor public tellor;\n\n    /*Constructor*/\n    /**\n     * @dev the constructor sets the oracle address in storage\n     * @param _tellor is the Tellor Oracle address\n     */\n    constructor(address payable _tellor) {\n        tellor = ITellor(_tellor);\n    }\n\n    /*Getters*/\n    /**\n     * @dev Retrieves the next value for the queryId after the specified timestamp\n     * @param _queryId is the queryId to look up the value for\n     * @param _timestamp after which to search for next value\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function _getDataAfter(bytes32 _queryId, uint256 _timestamp)\n        internal\n        view\n        returns (bytes memory _value, uint256 _timestampRetrieved)\n    {\n        (bool _found, uint256 _index) = _getIndexForDataAfter(\n            _queryId,\n            _timestamp\n        );\n        if (!_found) {\n            return (\"\", 0);\n        }\n        _timestampRetrieved = _getTimestampbyQueryIdandIndex(_queryId, _index);\n        _value = _retrieveData(_queryId, _timestampRetrieved);\n        return (_value, _timestampRetrieved);\n    }\n\n    /**\n     * @dev Retrieves the latest value for the queryId before the specified timestamp\n     * @param _queryId is the queryId to look up the value for\n     * @param _timestamp before which to search for latest value\n     * @return _value the value retrieved\n     * @return _timestampRetrieved the value's timestamp\n     */\n    function _getDataBefore(bytes32 _queryId, uint256 _timestamp)\n        internal\n        view\n        returns (bytes memory _value, uint256 _timestampRetrieved)\n    {\n        (, _value, _timestampRetrieved) = tellor.getDataBefore(\n            _queryId,\n            _timestamp\n        );\n    }\n\n    /**\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\n     * @param _queryId is the queryId to look up the index for\n     * @param _timestamp is the timestamp before which to search for the latest index\n     * @return _found whether the index was found\n     * @return _index the latest index found before the specified timestamp\n     */\n    // slither-disable-next-line calls-loop\n    function _getIndexForDataAfter(bytes32 _queryId, uint256 _timestamp)\n        internal\n        view\n        returns (bool _found, uint256 _index)\n    {\n        uint256 _count = _getNewValueCountbyQueryId(_queryId);\n        if (_count == 0) return (false, 0);\n        _count--;\n        bool _search = true; // perform binary search\n        uint256 _middle = 0;\n        uint256 _start = 0;\n        uint256 _end = _count;\n        uint256 _timestampRetrieved;\n        // checking boundaries to short-circuit the algorithm\n        _timestampRetrieved = _getTimestampbyQueryIdandIndex(_queryId, _end);\n        if (_timestampRetrieved <= _timestamp) return (false, 0);\n        _timestampRetrieved = _getTimestampbyQueryIdandIndex(_queryId, _start);\n        if (_timestampRetrieved > _timestamp) {\n            // candidate found, check for disputes\n            _search = false;\n        }\n        // since the value is within our boundaries, do a binary search\n        while (_search) {\n            _middle = (_end + _start) / 2;\n            _timestampRetrieved = _getTimestampbyQueryIdandIndex(\n                _queryId,\n                _middle\n            );\n            if (_timestampRetrieved > _timestamp) {\n                // get immediate previous value\n                uint256 _prevTime = _getTimestampbyQueryIdandIndex(\n                    _queryId,\n                    _middle - 1\n                );\n                if (_prevTime <= _timestamp) {\n                    // candidate found, check for disputes\n                    _search = false;\n                } else {\n                    // look from start to middle -1(prev value)\n                    _end = _middle - 1;\n                }\n            } else {\n                // get immediate next value\n                uint256 _nextTime = _getTimestampbyQueryIdandIndex(\n                    _queryId,\n                    _middle + 1\n                );\n                if (_nextTime > _timestamp) {\n                    // candidate found, check for disputes\n                    _search = false;\n                    _middle++;\n                    _timestampRetrieved = _nextTime;\n                } else {\n                    // look from middle + 1(next value) to end\n                    _start = _middle + 1;\n                }\n            }\n        }\n        // candidate found, check for disputed values\n        if (!_isInDispute(_queryId, _timestampRetrieved)) {\n            // _timestampRetrieved is correct\n            return (true, _middle);\n        } else {\n            // iterate forward until we find a non-disputed value\n            while (\n                _isInDispute(_queryId, _timestampRetrieved) && _middle < _count\n            ) {\n                _middle++;\n                _timestampRetrieved = _getTimestampbyQueryIdandIndex(\n                    _queryId,\n                    _middle\n                );\n            }\n            if (\n                _middle == _count && _isInDispute(_queryId, _timestampRetrieved)\n            ) {\n                return (false, 0);\n            }\n            // _timestampRetrieved is correct\n            return (true, _middle);\n        }\n    }\n\n    /**\n     * @dev Retrieves latest array index of data before the specified timestamp for the queryId\n     * @param _queryId is the queryId to look up the index for\n     * @param _timestamp is the timestamp before which to search for the latest index\n     * @return _found whether the index was found\n     * @return _index the latest index found before the specified timestamp\n     */\n    // slither-disable-next-line calls-loop\n    function _getIndexForDataBefore(bytes32 _queryId, uint256 _timestamp)\n        internal\n        view\n        returns (bool _found, uint256 _index)\n    {\n        return tellor.getIndexForDataBefore(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Retrieves multiple uint256 values before the specified timestamp\n     * @param _queryId the unique id of the data query\n     * @param _timestamp the timestamp before which to search for values\n     * @param _maxAge the maximum number of seconds before the _timestamp to search for values\n     * @param _maxCount the maximum number of values to return\n     * @return _values the values retrieved, ordered from oldest to newest\n     * @return _timestamps the timestamps of the values retrieved\n     */\n    function _getMultipleValuesBefore(\n        bytes32 _queryId,\n        uint256 _timestamp,\n        uint256 _maxAge,\n        uint256 _maxCount\n    )\n        internal\n        view\n        returns (bytes[] memory _values, uint256[] memory _timestamps)\n    {\n        // get index of first possible value\n        (bool _ifRetrieve, uint256 _startIndex) = _getIndexForDataAfter(\n            _queryId,\n            _timestamp - _maxAge\n        );\n        // no value within range\n        if (!_ifRetrieve) {\n            return (new bytes[](0), new uint256[](0));\n        }\n        uint256 _endIndex;\n        // get index of last possible value\n        (_ifRetrieve, _endIndex) = _getIndexForDataBefore(_queryId, _timestamp);\n        // no value before _timestamp\n        if (!_ifRetrieve) {\n            return (new bytes[](0), new uint256[](0));\n        }\n        uint256 _valCount = 0;\n        uint256 _index = 0;\n        uint256[] memory _timestampsArrayTemp = new uint256[](_maxCount);\n        // generate array of non-disputed timestamps within range\n        while (_valCount < _maxCount && _endIndex + 1 - _index > _startIndex) {\n            uint256 _timestampRetrieved = _getTimestampbyQueryIdandIndex(\n                _queryId,\n                _endIndex - _index\n            );\n            if (!_isInDispute(_queryId, _timestampRetrieved)) {\n                _timestampsArrayTemp[_valCount] = _timestampRetrieved;\n                _valCount++;\n            }\n            _index++;\n        }\n\n        bytes[] memory _valuesArray = new bytes[](_valCount);\n        uint256[] memory _timestampsArray = new uint256[](_valCount);\n        // retrieve values and reverse timestamps order\n        for (uint256 _i = 0; _i < _valCount; _i++) {\n            _timestampsArray[_i] = _timestampsArrayTemp[_valCount - 1 - _i];\n            _valuesArray[_i] = _retrieveData(_queryId, _timestampsArray[_i]);\n        }\n        return (_valuesArray, _timestampsArray);\n    }\n\n    /**\n     * @dev Counts the number of values that have been submitted for the queryId\n     * @param _queryId the id to look up\n     * @return uint256 count of the number of values received for the queryId\n     */\n    function _getNewValueCountbyQueryId(bytes32 _queryId)\n        internal\n        view\n        returns (uint256)\n    {\n        return tellor.getNewValueCountbyQueryId(_queryId);\n    }\n\n    /**\n     * @dev Returns the address of the reporter who submitted a value for a data ID at a specific time\n     * @param _queryId is ID of the specific data feed\n     * @param _timestamp is the timestamp to find a corresponding reporter for\n     * @return address of the reporter who reported the value for the data ID at the given timestamp\n     */\n    function _getReporterByTimestamp(bytes32 _queryId, uint256 _timestamp)\n        internal\n        view\n        returns (address)\n    {\n        return tellor.getReporterByTimestamp(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Gets the timestamp for the value based on their index\n     * @param _queryId is the id to look up\n     * @param _index is the value index to look up\n     * @return uint256 timestamp\n     */\n    function _getTimestampbyQueryIdandIndex(bytes32 _queryId, uint256 _index)\n        internal\n        view\n        returns (uint256)\n    {\n        return tellor.getTimestampbyQueryIdandIndex(_queryId, _index);\n    }\n\n    /**\n     * @dev Determines whether a value with a given queryId and timestamp has been disputed\n     * @param _queryId is the value id to look up\n     * @param _timestamp is the timestamp of the value to look up\n     * @return bool true if queryId/timestamp is under dispute\n     */\n    function _isInDispute(bytes32 _queryId, uint256 _timestamp)\n        internal\n        view\n        returns (bool)\n    {\n        return tellor.isInDispute(_queryId, _timestamp);\n    }\n\n    /**\n     * @dev Retrieve value from oracle based on queryId/timestamp\n     * @param _queryId being requested\n     * @param _timestamp to retrieve data/value from\n     * @return bytes value for query/timestamp submitted\n     */\n    function  _retrieveData(bytes32 _queryId, uint256 _timestamp)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return tellor.retrieveData(_queryId, _timestamp);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000,
      "details": {
        "yul": true,
        "yulDetails": {
          "stackAllocation": true,
          "optimizerSteps": "dhfoDgvulfnTUtnIf"
        }
      }
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "*",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}